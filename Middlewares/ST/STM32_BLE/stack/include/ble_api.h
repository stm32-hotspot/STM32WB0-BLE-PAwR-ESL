/**
  ******************************************************************************
  * @file    ble_api.h
  * @author  GPM WBL Application Team
  * @brief   Header file for Bluetooth Low Energy stack APIs.
  *          Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

#ifndef _BLE_API_H_
#define _BLE_API_H_

#include "ble_gatt.h"
#include <stdint.h>
#include "ble_status.h"

/** Documentation for C struct Advertising_Set_Parameters_t */
typedef struct Advertising_Set_Parameters_t_s {
  /** It is used to identify an advertising set.
   *  Values:
   *  - 0x00 ... 0xEF
   */
  uint8_t Advertising_Handle;
  /** The Duration[i] parameter indicates the duration for which that advertising set
   *  is enabled. The duration begins at the start of the first advertising
   *  event of this advertising set. The Controller should not start an extended
   *  advertising event that it cannot complete within the duration. Time = N *
   *  10 ms 0x00 means no advertising duration: advertising will continue until
   *  the Host disables it.
   *  Values:
   *  - 0x0000 (0 ms) : No advertising duration
   *  - 0x0001 (10 ms)  ... 0xFFFF (655350 ms) 
   */
  uint16_t Duration;
  /** The Max_Extended_Advertising_Events[i] parameter, if non-zero, indicates the
   *  maximum number of extended advertising events that shall be sent prior to
   *  disabling the extended advertising set even if the Duration[i] parameter
   *  has not expired.
   *  Values:
   *  - 0x00: No maximum number of advertising events.
   *  - 0x01 ... 0xFF: Maximum number of extended advertising events.
   */
  uint8_t Max_Extended_Advertising_Events;
} Advertising_Set_Parameters_t;

/** Documentation for C struct Extended_Scan_Parameters_t */
typedef struct Extended_Scan_Parameters_t_s {
  /** The Scan_Type parameter specifies the type of scan to perform. 0: Passive
   *  Scanning. No scan request PDUs shall be sent. 1: Active Scanning. Scan
   *  request PDUs may be sent.
   *  Values:
   *  - 0x00: Passive Scanning
   *  - 0x01: Active Scanning
   */
  uint8_t Scan_Type;
  /** Time interval from when the Controller started its last scan until it begins the
   *  subsequent scan on the primary advertising channel.  Time = N * 0.625 ms
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Interval;
  /** Duration of the scan on the primary advertising channel.  Time = N * 0.625 ms
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Window;
} Extended_Scan_Parameters_t;

/** Documentation for C struct Extended_Create_Connection_Parameters_t */
typedef struct Extended_Create_Connection_Parameters_t_s {
  /** Time interval from when the Controller started its last scan until it begins the
   *  subsequent scan on the primary advertising channel. Time = N * 0.625 ms;
   *  Time Range: 2.5 ms to 40.959375 s.
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Interval;
  /** Duration of the scan on the primary advertising channel. Time = N * 0.625 ms;
   *  Time Range: 2.5 ms to 40.959375 s.
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Window;
  /** Minimum value for the connection interval. This shall be less than or equal to
   *  Connection_Interval_Max[i]. Time = N * 1.25 ms; Time Range: 7.5 ms to 4 s.
   *  Values:
   *  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
   */
  uint16_t Connection_Interval_Min;
  /** Maximum value for the connection interval. This shall be less than or equal to
   *  Connection_Interval_Max[i]. Time = N * 1.25 ms; Time Range: 7.5 ms to 4 s.
   *  Values:
   *  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
   */
  uint16_t Connection_Interval_Max;
  /** Peripheral latency for the connection in number of connection events
   *  Values:
   *  - 0x0000 ... 0x01F3
   */
  uint16_t Max_Latency;
  /** Supervision timeout for the LE Link. (See [Vol 6] Part B, Section 4.5.2) Time =
   *  N * 10 ms; Time Range: 100 ms to 32 s.
   *  Values:
   *  - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
   */
  uint16_t Supervision_Timeout;
  /** Informative parameter recommending the minimum length of connection event needed
   *  for this LE connection. Time = N * 0.625 ms.
   *  Values:
   *  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Min_CE_Length;
  /** Informative parameter recommending the maximum length of connection event needed
   *  for this LE connection. Time = N * 0.625 ms.
   *  Values:
   *  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Max_CE_Length;
} Extended_Create_Connection_Parameters_t;

/** Documentation for C struct CIS_Param_t */
typedef struct CIS_Param_t_s {
  /** Used to identify a CIS.
   *  Values:
   *  - 0x00 ... 0xEF
   */
  uint8_t CIS_ID;
  /** Maximum size, in octets, of the payload from the Central's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_C_To_P;
  /** Maximum size, in octets, of the payload from the Peripheral's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_P_To_C;
  /** PHY to use for transmission from the Central to the Peripheral.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_C_To_P;
  /** PHY to use for transmission from the Peripheral to the Central.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_P_To_C;
  /** Number of times every CIS Data PDU should be retransmitted from the Central to
   *  the Peripheral.
   */
  uint8_t RTN_C_To_P;
  /** Number of times every CIS Data PDU should be retransmitted from the Peripheral
   *  to the Central.
   */
  uint8_t RTN_P_To_C;
} CIS_Param_t;

/** Documentation for C struct CIS_Param_Test_t */
typedef struct CIS_Param_Test_t_s {
  /** Used to identify a CIS.
   *  Values:
   *  - 0x00 ... 0xEF
   */
  uint8_t CIS_ID;
  /** Maximum number of subevents in each CIS event.
   *  Values:
   *  - 0x01 ... 0x1F
   */
  uint8_t NSE;
  /** Maximum size, in octets, of the payload from the Central's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_C_To_P;
  /** Maximum size, in octets, of the payload from the Peripheral's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_P_To_C;
  /** Maximum size, in octets, of the payload from the Central's Link Layer to the
   *  Peripheral's Link Layer.
   *  Values:
   *  - 0x0000 ... 0x00FB
   */
  uint16_t Max_PDU_C_To_P;
  /** Maximum size, in octets, of the payload from the Peripheral's Link Layer to the
   *  Central's Link Layer.
   *  Values:
   *  - 0x0000 ... 0x00FB
   */
  uint16_t Max_PDU_P_To_C;
  /** PHY to use for transmission from the Central to the Peripheral.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_C_To_P;
  /** PHY to use for transmission from the Peripheral to the Central.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_P_To_C;
  /** The burst number for Central to Peripheral.
   *  Values:
   *  - 0x00: No data
   *  - 0x01 ... 0x0F
   */
  uint8_t BN_C_To_P;
  /** The burst number for Peripheral to Central.
   *  Values:
   *  - 0x00: No data
   *  - 0x01 ... 0x0F
   */
  uint8_t BN_P_To_C;
} CIS_Param_Test_t;

/** Documentation for C struct CIS_Handles_t */
typedef struct CIS_Handles_t_s {
  /** Connection handle of a CIS.
   *  Values:
   *  - 0x0000 ... 0x0EFF
   */
  uint16_t CIS_Connection_Handle;
  /** Connection handle of an ACL connection.
   *  Values:
   *  - 0x0000 ... 0x0EFF
   */
  uint16_t ACL_Connection_Handle;
} CIS_Handles_t;

/** Documentation for C struct Bonded_Device_Entry_t */
typedef struct Bonded_Device_Entry_t_s {
  /** Address type.
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   */
  uint8_t Address_Type;
  /** Identity Address (Public or Random) of the device.
   */
  uint8_t Address[6];
} Bonded_Device_Entry_t;

/** Documentation for C struct List_Entry_t */
typedef struct List_Entry_t_s {
  /** Address type.
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   */
  uint8_t Peer_Address_Type;
  /** Public Device Address or Random Device Address of the device to be added to the
   *  list.
   */
  uint8_t Peer_Address[6];
} List_Entry_t;

/** Documentation for C union UUID_t */
typedef union UUID_t_s {
  /** 16-bit UUID
   */
  uint16_t UUID_16;
  /** 128-bit UUID
   */
  uint8_t UUID_128[16];
} UUID_t;

/** Documentation for C struct Gatt_Srv_Notify_Attr_t */
typedef struct Gatt_Srv_Notify_Attr_t_s {
  /** 
   */
  uint16_t Handle;
  /** 
   */
  uint16_t Val_Length;
  /** 
   */
  uint8_t *Val;
} Gatt_Srv_Notify_Attr_t;

/** Documentation for C struct Subevent_Data_Ptr_Parameters_t */
typedef struct Subevent_Data_Ptr_Parameters_t_s {
  /** The number of octets in the Subevent_Data parameter.
   *  Values:
   *  - 0x00 ... 0xFB
   */
  uint8_t Subevent;
  /** The number of response slots to be used.
   */
  uint8_t Response_Slot_Start;
  /** The number of response slots to be used.
   */
  uint8_t Response_Slot_Count;
  /** The number of octets in buffer pointed by Subevent_Data parameter.
   *  Values:
   *  - 0x00 ... 0xFB
   */
  uint8_t Subevent_Data_Length;
  /** Pointer to advertising data formatted as defined in [Vol 3] Part C, Section 11.
   */
  uint8_t* Subevent_Data;
} Subevent_Data_Ptr_Parameters_t;


/**
 *@addtogroup HCI HCI
 *@brief Standard Host Controller Interface.
 *@{
 */
/**
 *@defgroup HCI_Commands HCI Commands
 * Standard HCI Commands.
 *@{
 */
/**
 * @brief The @ref hci_disconnect is used to terminate an existing connection.
 *        The Connection_Handle command parameter indicates which connection is
 *        to be disconnected. The Reason command parameter indicates the reason
 *        for ending the connection. The remote Controller will receive the
 *        Reason command parameter in the @ref hci_disconnection_complete_event_rp0
 *        event. All synchronous connections on a physical link should be
 *        disconnected before the ACL connection on the same physical connection
 *        is disconnected. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
 *        7.1.6) It is important to leave an 100 ms blank window before sending
 *        any new command (including system hardware reset), since immediately
 *        after @ref hci_disconnection_complete_event_rp0 event, system could save
 *        important information in non volatile memory.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Reason The reason for ending the connection.
 *        Values:
 *        - 0x05: Authentication Failure
 *        - 0x13: Remote User Terminated Connection
 *        - 0x14: Remote Device Terminated Connection due to Low Resources
 *        - 0x15: Remote Device Terminated Connection due to Power Off
 *        - 0x1A: Unsupported Remote Feature
 *        - 0x3B: Unacceptable Connection Parameters
 * @retval Value indicating success or error code.
 */
tBleStatus hci_disconnect(uint16_t Connection_Handle,
                          uint8_t Reason);
/**
 * @brief This command will obtain the values for the version information for
 *        the remote device identified by the Connection_Handle parameter. The
 *        Connection_Handle must be a Connection_Handle for an ACL or LE
 *        connection. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
 *        7.1.23)
 * @param Connection_Handle Specifies which Connection_Handle's version
 *        information to get.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_read_remote_version_information(uint16_t Connection_Handle);
/**
 * @brief The Set_Event_Mask command is used to control which events are
 *        generated by the HCI for the Host.  If the bit in the Event_Mask is
 *        set to a one, then the event associated with that bit will be enabled.
 *        For an LE Controller, the LE Meta Event bit in the Event_Mask shall
 *        enable or disable all LE events in the LE Meta Event (see Section
 *        7.7.65). The Host has to deal with each event that occurs. The event
 *        mask allows the Host to control how much it is interrupted. (See
 *        Bluetooth Specification v.4.1, Vol. 2, Part E, 7.3.1)
 * @param Event_Mask Event mask. Default: 0x00001FFFFFFFFFFF
 *        Flags:
 *        - 0x0000000000000000: No events specified
 *        - 0x0000000000000001: Inquiry Complete Event
 *        - 0x0000000000000002: Inquiry Result Event
 *        - 0x0000000000000004: Connection Complete Event
 *        - 0x0000000000000008: Connection Request Event
 *        - 0x0000000000000010: Disconnection Complete Event
 *        - 0x0000000000000020: Authentication Complete Event
 *        - 0x0000000000000040: Remote Name Request Complete Event
 *        - 0x0000000000000080: Encryption Change Event
 *        - 0x0000000000000100: Change Connection Link Key Complete Event
 *        - 0x0000000000000200: Central Link Key Complete Event
 *        - 0x0000000000000400: Read Remote Supported Features Complete Event
 *        - 0x0000000000000800: Read Remote Version Information Complete Event
 *        - 0x0000000000001000: QoS Setup Complete Event
 *        - 0x0000000000008000: Hardware Error Event
 *        - 0x0000000000010000: Flush Occurred Event
 *        - 0x0000000000020000: Role Change Event
 *        - 0x0000000000080000: Mode Change Event
 *        - 0x0000000000100000: Return Link Keys Event
 *        - 0x0000000000200000: PIN Code Request Event
 *        - 0x0000000000400000: Link Key Request Event
 *        - 0x0000000000800000: Link Key Notification Event
 *        - 0x0000000001000000: Loopback Command Event
 *        - 0x0000000002000000: Data Buffer Overflow Event
 *        - 0x0000000004000000: Max Slots Change Event
 *        - 0x0000000008000000: Read Clock Offset Complete Event
 *        - 0x0000000010000000: Connection Packet Type Changed Event
 *        - 0x0000000020000000: QoS Violation Event
 *        - 0x0000000040000000: Page Scan Mode Change Event
 *        - 0x0000000080000000: Page Scan Repetition Mode Change Event
 *        - 0x0000000100000000: Flow Specification Complete Event
 *        - 0x0000000200000000: Inquiry Result with RSSI Event
 *        - 0x0000000400000000: Read Remote Extended Features Complete Event
 *        - 0x0000080000000000: Synchronous Connection Complete Event
 *        - 0x0000100000000000: Synchronous Connection Changed Event
 *        - 0x0000200000000000: Sniff Subrating Event
 *        - 0x0000400000000000: Extended Inquiry Result Event
 *        - 0x0000800000000000: Encryption Key Refresh Complete Event
 *        - 0x0001000000000000: IO Capability Request Event
 *        - 0x0002000000000000: IO Capability Request Reply Event
 *        - 0x0004000000000000: User Confirmation Request Event
 *        - 0x0008000000000000: User Passkey Request Event
 *        - 0x0010000000000000: Remote OOB Data Request Event
 *        - 0x0020000000000000: Simple Pairing Complete Event
 *        - 0x0080000000000000: Link Supervision Timeout Changed Event
 *        - 0x0100000000000000: Enhanced Flush Complete Event
 *        - 0x0400000000000000: User Passkey Notification Event
 *        - 0x0800000000000000: Keypress Notification Event
 *        - 0x1000000000000000: Remote Host Supported Features Notification Event
 *        - 0x2000000000000000: LE Meta-Event
 * @retval Value indicating success or error code.
 */
tBleStatus hci_set_event_mask(uint8_t Event_Mask[8]);
/**
 * @brief The HCI_Read_Connection_Accept_Timeout command will read the value for
 *        the Connection Accept Timeout configuration parameter, which allows
 *        the Controller to automatically deny a connection request after a
 *        specified period has occurred, and to refuse a new connection.
 * @param[out] Connection_Accept_Timeout Connection Accept Timeout. Interval
 *             Length = N * 0.625 ms
 *             Values:
 *             - 0x0001 (0.625 ms)  ... 0xB540 (29000.000 ms) 
 * @retval Value indicating success or error code.
 */
tBleStatus hci_read_connection_accept_timeout(uint16_t *Connection_Accept_Timeout);
/**
 * @brief The HCI_Write_Connection_Accept_Timeout command will write the value
 *        for the Connection Accept Timeout configuration parameter, which
 *        allows the Controller to automatically deny a connection request after
 *        a specified period has occurred, and to refuse a new connection.
 * @param Connection_Accept_Timeout Connection Accept Timeout. Interval Length =
 *        N * 0.625 ms Default: 0x1FA0 Time = 5.06 s Mandatory Range for
 *        Controller: 0x00A0 to 0xB540
 *        Values:
 *        - 0x0001 (0.625 ms)  ... 0xB540 (29000.000 ms) 
 * @retval Value indicating success or error code.
 */
tBleStatus hci_write_connection_accept_timeout(uint16_t Connection_Accept_Timeout);
/**
 * @brief This command reads the values for the Transmit_Power_Level parameter
 *        for the specified Connection_Handle. The Connection_Handle shall be a
 *        Connection_Handle for an ACL connection. (See Bluetooth Specification
 *        v.4.1, Vol. 2, Part E, 7.3.35)
 * @param Connection_Handle Specifies which Connection_Handle's Transmit Power
 *        Level setting to read.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Type Current or maximum transmit power level.
 *        Values:
 *        - 0x00: Read Current Transmit Power Level.
 *        - 0x01: Read Maximum Transmit Power Level.
 * @param[out] Transmit_Power_Level Size: 1 Octet (signed integer) Units: dBm
 *             Values:
 *             - -30 ... 20
 * @retval Value indicating success or error code.
 */
tBleStatus hci_read_transmit_power_level(uint16_t Connection_Handle,
                                         uint8_t Type,
                                         int8_t *Transmit_Power_Level);
/**
 * @brief The HCI_Read_AFH_Channel_Assessment_Mode command reads the value for
 *        the AFH_Channel_Assessment_Mode parameter. The
 *        AFH_Channel_Assessment_Mode parameter controls whether the
 *        Controller's channel assessment scheme is enabled or disabled.
 * @param[out] AFH_Channel_Assessment_Mode Enable or disable channel assessment
 *             scheme.
 *             Values:
 *             - 0x00: DISABLED
 *             - 0x01: ENABLED
 * @retval Value indicating success or error code.
 */
tBleStatus hci_read_afh_channel_assessment_mode(uint8_t *AFH_Channel_Assessment_Mode);
/**
 * @brief The HCI_Write_AFH_Channel_Assessment_Mode command writes the value for
 *        the AFH_Channel_Assessment_Mode parameter. The
 *        AFH_Channel_Assessment_Mode parameter controls whether the
 *        Controller's channel assessment scheme is enabled or disabled.
 * @param AFH_Channel_Assessment_Mode
 *        Values:
 *        - 0x00: DISABLED
 *        - 0x01: ENABLED
 * @retval Value indicating success or error code.
 */
tBleStatus hci_write_afh_channel_assessment_mode(uint8_t AFH_Channel_Assessment_Mode);
/**
 * @brief The HCI_Set_Event_Mask_Page_2 command is used to control which events
 *        are generated by the HCI for the Host. The Event_Mask_Page_2 is a
 *        logical extension to the Event_Mask parameter of the
 *        HCI_Set_Event_Mask command. If the bit in the Event_Mask_Page_2 is set
 *        to a one, then the event associated with that bit shall be enabled.
 *        The event mask allows the Host to control how much it is interrupted.
 *        The Controller shall ignore those bits which are reserved for future
 *        use or represent events which it does not support. If the Host sets
 *        any of these bits to 1, the Controller shall act as if they were set
 *        to 0.
 * @param Event_Mask_Page_2 For the complete list of bits that can be set, see
 *        Core v5.1, Vol 2, part E, chapter 7.3.69. The only bit that is not
 *        ignored is: Bit 23: Authenticated Payload Timeout Expired event.
 *        Flags:
 *        - 0x0000000000800000: AUTHENTICATED_PAYLOAD_TIMEOUT_EXPIRED_EVENT
 * @retval Value indicating success or error code.
 */
tBleStatus hci_set_event_mask_page_2(uint8_t Event_Mask_Page_2[8]);
/**
 * @brief This command reads the Authenticated_Payload_Timeout parameter in the
 *        Primary Controller on the specified Connection_Handle.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param[out] Authenticated_Payload_Timeout Maximum amount of time specified
 *             between packets authenticated by a MIC. Time = N * 10 ms.
 *             Values:
 *             - 0x0001 (10 ms)  ... 0xFFFF (655350 ms) 
 * @retval Value indicating success or error code.
 */
tBleStatus hci_read_authenticated_payload_timeout(uint16_t Connection_Handle,
                                                  uint16_t *Authenticated_Payload_Timeout);
/**
 * @brief This command writes the Authenticated_Payload_Timeout parameter in the
 *        Primary Controller for the specified Connection_Handle. The
 *        Authenticated_Payload_Timeout shall be equal to or greater than
 *        connInterval * (1 + connPeripheralLatency). The Link Layer will use
 *        this parameter to determine when to use the LE ping sequence.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Authenticated_Payload_Timeout Maximum amount of time specified between
 *        packets authenticated by a valid MIC. Time = N * 10 ms.
 *        Values:
 *        - 0x0001 (10 ms)  ... 0xFFFF (655350 ms) 
 * @retval Value indicating success or error code.
 */
tBleStatus hci_write_authenticated_payload_timeout(uint16_t Connection_Handle,
                                                   uint16_t Authenticated_Payload_Timeout);
/**
 * @brief This command reads the values for the version information for the
 *        local Controller. The HCI Version information defines the version
 *        information of the HCI layer. The LMP/PAL Version information defines
 *        the version of the LMP or PAL. The Manufacturer_Name information
 *        indicates the manufacturer of the local device. The HCI Revision and
 *        LMP/PAL Subversion are implementation dependent. (See Bluetooth
 *        Specification v.4.1, Vol. 2, Part E, 7.4.1)
 * @param[out] HCI_Version See Bluetooth Assigned Numbers
 *             (https://www.bluetooth.org/en-us/specification/assigned-numbers)
 * @param[out] HCI_Revision Revision of the Current HCI in the BR/EDR
 *             Controller.
 * @param[out] LMP_PAL_Version Version of the Current LMP or PAL in the
 *             Controller. See Bluetooth Assigned Numbers
 *             (https://www.bluetooth.org/en-us/specification/assigned-numbers)
 * @param[out] Manufacturer_Name Manufacturer Name of the BR/EDR Controller. See
 *             Bluetooth Assigned Numbers (https://www.bluetooth.org/en-
 *             us/specification/assigned-numbers)
 * @param[out] LMP_PAL_Subversion Subversion of the Current LMP or PAL in the
 *             Controller. This value is implementation dependent.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_read_local_version_information(uint8_t *HCI_Version,
                                              uint16_t *HCI_Revision,
                                              uint8_t *LMP_PAL_Version,
                                              uint16_t *Manufacturer_Name,
                                              uint16_t *LMP_PAL_Subversion);
/**
 * @brief This command reads the list of HCI commands supported for the local
 *        Controller. This command shall return the Supported_Commands
 *        configuration parameter. It is implied that if a command is listed as
 *        supported, the feature underlying that command is also supported. (See
 *        Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.2)
 * @param[out] Supported_Commands Bit mask for each HCI Command. If a bit is 1,
 *             the Controller supports the corresponding command and the
 *             features required for the command. Unsupported or undefined
 *             commands shall be set to 0.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_read_local_supported_commands(uint8_t Supported_Commands[64]);
/**
 * @brief This command requests a list of the supported features for the local
 *        Controller. This command will return a list of the LMP features. For
 *        details see Part C, Link Manager Protocol Specification on page 227.
 *        (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.3)
 * @param[out] LMP_Features Bit Mask List of LMP features.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_read_local_supported_features(uint8_t LMP_Features[8]);
/**
 * @brief On an LE Controller, this command shall read the Public Device Address
 *        as defined in [Vol 6] Part B, Section 1.3, Device Address. If this
 *        Controller does not have a Public Device Address, the value
 *        0x000000000000 shall be returned. On an LE Controller, the public
 *        address shall be the same as the BD_ADDR. (See Bluetooth Specification
 *        v.4.1, Vol. 2, Part E, 7.4.6)
 * @param[out] BD_ADDR BD_ADDR ( Bluetooth Device Address) of the Device.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_read_bd_addr(uint8_t BD_ADDR[6]);
/**
 * @brief This command reads the Received Signal Strength Indication (RSSI)
 *        value from a Controller. For an LE transport, a Connection_Handle is
 *        used as the Handle command parameter and return parameter. The meaning
 *        of the RSSI metric is an absolute receiver signal strength value in
 *        dBm to +/- 6 dB accuracy. If the RSSI cannot be read, the RSSI metric
 *        shall be set to 127. (See Bluetooth Specification v.4.1, Vol. 2, Part
 *        E, 7.5.4)
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param[out] RSSI N Size: 1 Octet (signed integer) Units: dBm
 *             Values:
 *             - -127 ... 20
 *             - 127: RSSI not available
 * @retval Value indicating success or error code.
 */
tBleStatus hci_read_rssi(uint16_t Connection_Handle,
                         int8_t *RSSI);
/**
 * @brief The LE_Set_Event_Mask command is used to control which LE events are
 *        generated by the HCI for the Host. If the bit in the LE_Event_Mask is
 *        set to a one, then the event associated with that bit will be enabled.
 *        The Host has to deal with each event that is generated by an LE
 *        Controller. The event mask allows the Host to control which events
 *        will interrupt it. For LE events to be generated, the LE Meta-Event
 *        bit in the Event_Mask shall also be set. If that bit is not set, then
 *        LE events shall not be generated, regardless of how the LE_Event_Mask
 *        is set. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.1)
 * @param LE_Event_Mask LE event mask. Default: 0x000000000000001F.
 *        Flags:
 *        - 0x0000000000000000: No LE events specified
 *        - 0x0000000000000001: LE Connection Complete Event
 *        - 0x0000000000000002: LE Advertising Report Event
 *        - 0x0000000000000004: LE Connection Update Complete Event
 *        - 0x0000000000000008: LE Read Remote Used Features Complete Event
 *        - 0x0000000000000010: LE Long Term Key Request Event
 *        - 0x0000000000000020: LE Remote Connection Parameter Request Event
 *        - 0x0000000000000040: LE Data Length Change Event
 *        - 0x0000000000000080: LE Read Local P-256 Public Key Complete Event
 *        - 0x0000000000000100: LE Generate DHKey Complete Event
 *        - 0x0000000000000200: LE Enhanced Connection Complete Event
 *        - 0x0000000000000400: LE Directed Advertising Report Event
 *        - 0x0000000000000800: LE PHY Update Complete event
 *        - 0x0000000000001000: LE Extended Advertising Report event
 *        - 0x0000000000002000: LE Periodic Advertising Sync Established event
 *        - 0x0000000000004000: LE Periodic Advertising Report event
 *        - 0x0000000000008000: LE Periodic Advertising Sync Lost event
 *        - 0x0000000000010000: LE Scan Timeout event
 *        - 0x0000000000020000: LE Advertising Set Terminated event
 *        - 0x0000000000040000: LE Scan Request Received event
 *        - 0x0000000000080000: LE Channel Selection Algorithm event
 *        - 0x0000000000100000: LE Connectionless IQ Report event
 *        - 0x0000000000200000: LE Connection IQ Report event
 *        - 0x0000000000400000: LE CTE Request Failed event
 *        - 0x0000000000800000: LE Periodic Advertising Sync Transfer Received event
 *        - 0x0000000001000000: LE CIS Established event
 *        - 0x0000000002000000: LE CIS Request event
 *        - 0x0000000004000000: LE Create BIG Complete event
 *        - 0x0000000008000000: LE Terminate BIG Complete event
 *        - 0x0000000010000000: LE BIG Sync Established event
 *        - 0x0000000020000000: LE BIG Sync Lost event
 *        - 0x0000000040000000: LE Request Peer SCA Complete event
 *        - 0x0000000080000000: LE Path Loss Threshold event
 *        - 0x0000000100000000: LE Transmit Power Reporting event
 *        - 0x0000000200000000: LE BIGInfo Advertising Report event
 *        - 0x0000000400000000: LE Subrate Change event
 *        - 0x0000000800000000: LE Periodic Advertising Sync Established event [v2]
 *        - 0x0000001000000000: LE Periodic Advertising Report event [v2]
 *        - 0x0000002000000000: LE Periodic Advertising Sync Transfer Received event [v2]
 *        - 0x0000004000000000: LE Periodic Advertising Subevent Data Request event
 *        - 0x0000008000000000: LE Periodic Advertising Response Report event
 *        - 0x0000010000000000: LE Enhanced Connection Complete event [v2]
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_event_mask(uint8_t LE_Event_Mask[8]);
/**
 * @brief The LE_Read_Buffer_Size command is used to read the maximum size of
 *        the data portion of HCI LE ACL Data Packets sent from the Host to the
 *        Controller. The Host will segment the data transmitted to the
 *        Controller according to these values, so that the HCI Data Packets
 *        will contain data with up to this size. The LE_Read_Buffer_Size
 *        command also returns the total number of HCI LE ACL Data Packets that
 *        can be stored in the data buffers of the Controller. The
 *        LE_Read_Buffer_Size command must be issued by the Host before it sends
 *        any data to an LE Controller (see Section 4.1.1). If the Controller
 *        returns a length value of zero, the Host shall use the
 *        Read_Buffer_Size command to determine the size of the data buffers
 *        Note: Both the Read_Buffer_Size and LE_Read_Buffer_Size commands may
 *        return buffer length and number of packets parameter values that are
 *        nonzero. The HC_LE_ACL_Data_Packet_Length return parameter shall be
 *        used to determine the size of the L2CAP PDU segments contained in ACL
 *        Data Packets, which are transferred from the Host to the Controller to
 *        be broken up into packets by the Link Layer. Both the Host and the
 *        Controller shall support command and event packets, where the data
 *        portion (excluding header) contained in the packets is 255 octets in
 *        size. The HC_Total_Num_LE_ACL_Data_Packets return parameter contains
 *        the total number of HCI ACL Data Packets that can be stored in the
 *        data buffers of the Controller. The Host determines how the buffers
 *        are to be divided between different Connection Handles. Note: The
 *        HC_LE_ACL_Data_Packet_Length return parameter does not include the
 *        length of the HCI Data Packet header. (See Bluetooth Specification
 *        v.4.1, Vol. 2, Part E, 7.8.2)
 * @param[out] HC_LE_ACL_Data_Packet_Length 0x0000: No dedicated LE Buffer
 *             exists. Use the HCI_Read_Buffer_Size command. 0x001B - 0xFFFF
 *             Maximum length (in octets) of the data portion of each HCI ACL
 *             data packet.
 *             Values:
 *             - 0x0000: NO_BUFFER
 *             - 0x001B ... 0xFFFF
 * @param[out] HC_Total_Num_LE_ACL_Data_Packets 0x00: No dedicated LE Buffer
 *             exists. Use the HCI_Read_Buffer_Size command. 0x01 - 0xFF: Total
 *             number of HCI ACL Data Packets that can be stored in the data
 *             buffers of the Controller.
 *             Values:
 *             - 0x00: NO_BUFFER
 *             - 0x01 ... 0xFF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_buffer_size(uint16_t *HC_LE_ACL_Data_Packet_Length,
                                   uint8_t *HC_Total_Num_LE_ACL_Data_Packets);
/**
 * @brief This command requests the list of the supported LE features for the
 *        Controller. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.3)
 * @param[out] LE_Features Bit Mask List of LE features. See Core v4.1, Vol. 6,
 *             Part B, Section 4.6.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_local_supported_features(uint8_t LE_Features[8]);
/**
 * @brief The LE_Set_Random_Address command is used by the Host to set the LE
 *        Random Device Address in the Controller (see [Vol 6] Part B, Section
 *        1.3). (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.4)
 * @param Random_Address Random Device Address.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_random_address(uint8_t Random_Address[6]);
/**
 * @brief The LE_Set_Advertising_Parameters command is used by the Host to set
 *        the advertising parameters. The Advertising_Interval_Min shall be less
 *        than or equal to the Advertising_Interval_Max. The
 *        Advertising_Interval_Min and Advertising_Interval_Max should not be
 *        the same value to enable the Controller to determine the best
 *        advertising interval given other activities. For high duty cycle
 *        directed advertising, i.e. when Advertising_Type is 0x01
 *        (ADV_DIRECT_IND, high duty cycle), the Advertising_Interval_Min and
 *        Advertising_Interval_Max parameters are not used and shall be ignored.
 *        The Advertising_Type is used to determine the packet type that is used
 *        for advertising when advertising is enabled. Own_Address_Type
 *        parameter indicates the type of address being used in the advertising
 *        packets. If Own_Address_Type equals 0x02 or 0x03, the Peer_Address
 *        parameter contains the peer's Identity Address and the
 *        Peer_Address_Type parameter contains the Peer's Identity Type (i.e.
 *        0x00 or 0x01). These parameters are used to locate the corresponding
 *        local IRK in the resolving list; this IRK is used to generate the own
 *        address used in the advertisement. If directed advertising is
 *        performed, i.e. when Advertising_Type is set to 0x01 (ADV_DIRECT_IND,
 *        high duty cycle) or 0x04 (ADV_DIRECT_IND, low duty cycle mode), then
 *        the Peer_Address_Type and Peer_Address shall be valid. If
 *        Own_Address_Type equals 0x02 or 0x03, the Controller generates the
 *        peer's Resolvable Private Address using the peer's IRK corresponding
 *        to the peer's Identity Address contained in the Peer_Address parameter
 *        and peer's Identity Address Type (i.e. 0x00 or 0x01) contained in the
 *        Peer_Address_Type parameter. The Advertising_Channel_Map is a bit
 *        field that indicates the advertising channels that shall be used when
 *        transmitting advertising packets. At least one channel bit shall be
 *        set in the Advertising_Channel_Map parameter. The
 *        Advertising_Filter_Policy parameter shall be ignored when directed
 *        advertising is enabled. The Host shall not issue this command when
 *        advertising is enabled in the Controller; if it is the Command
 *        Disallowed error code shall be used. If the advertising interval range
 *        provided by the Host (Advertising_Interval_Min,
 *        Advertising_Interval_Max) is outside the advertising interval range
 *        supported by the Controller, then the Controller shall return the
 *        Unsupported Feature or Parameter Value (0x11) error code.
 * @param Advertising_Interval_Min Minimum advertising interval for undirected
 *        and low duty cycle directed advertising. Time = N * 0.625 msec.
 *        Values:
 *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) 
 * @param Advertising_Interval_Max Maximum advertising interval. Time = N *
 *        0.625 msec.
 *        Values:
 *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) 
 * @param Advertising_Type Advertising type.
 *        Values:
 *        - 0x00: ADV_IND (Connectable undirected advertising)
 *        - 0x01: ADV_DIRECT_IND, high duty cycle (Connectable high duty cycle directed advertising)
 *        - 0x02: ADV_SCAN_IND (Scannable undirected advertising)
 *        - 0x03: ADV_NONCONN_IND (Non connectable undirected advertising)
 *        - 0x04: ADV_DIRECT_IND, low duty cycle (Connectable low duty cycle directed advertising)
 * @param Own_Address_Type Own address type.  - 0x00: Public Device Address  -
 *        0x01 Random Device Address  - 0x02: Controller generates Resolvable
 *        Private Address based on the local          IRK from resolving list.
 *        If resolving list contains no matching entry,          use public
 *        address.  - 0x03: Controller generates Resolvable Private Address
 *        based on the local          IRK from resolving list. If resolving list
 *        contains no matching entry,          use random address from
 *        LE_Set_Random_Address.
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Resolvable Private Address or Public Address
 *        - 0x03: Resolvable Private Address or Random Address
 * @param Peer_Address_Type Peer Address type.
 *        Values:
 *        - 0x00: Public Device Address or Public Identity Address
 *        - 0x01: Random Device Address or Random (static) Identity Address
 * @param Peer_Address Public Device Address, Random Device Address, Public
 *        Identity Address or Random (static) Identity Address of the device to
 *        be connected.
 * @param Advertising_Channel_Map Advertising channel map. Default: 00000111b
 *        (all channels enabled).
 *        Flags:
 *        - 0x01: ch 37
 *        - 0x02: ch 38
 *        - 0x04: ch 39
 * @param Advertising_Filter_Policy Advertising Filter Policy. This parameter is
 *        ignored when directed advertising is enabled.  0x00 Process scan and
 *        connection requests from all devices (i.e., the Filter Accept List is
 *        not in use) 0x01 Process connection requests from all devices and scan
 *        requests only from devices that are in the Filter Accept List 0x02
 *        Process scan requests from all devices and connection requests only
 *        from devices that are in the Filter Accept List. 0x03 Process scan and
 *        connection requests only from devices in the Filter Accept List. All
 *        other values are reserved for future use
 *        Values:
 *        - 0x00: HCI_ADV_FILTER_NONE
 *        - 0x01: HCI_ADV_FILTER_ACCEPT_LIST_SCAN
 *        - 0x02: HCI_ADV_FILTER_ACCEPT_LIST_CONNECT
 *        - 0x03: HCI_ADV_FILTER_ACCEPT_LIST_SCAN_CONNECT
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_advertising_parameters(uint16_t Advertising_Interval_Min,
                                             uint16_t Advertising_Interval_Max,
                                             uint8_t Advertising_Type,
                                             uint8_t Own_Address_Type,
                                             uint8_t Peer_Address_Type,
                                             uint8_t Peer_Address[6],
                                             uint8_t Advertising_Channel_Map,
                                             uint8_t Advertising_Filter_Policy);
/**
 * @brief The LE_Read_Advertising_Physical_Channel_Tx_Power command is used by
 *        the Host to read the transmit power level used for LE advertising
 *        channel packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
 *        7.8.6)
 * @param[out] Transmit_Power_Level Size: 1 Octet (signed integer) Units: dBm
 *             Accuracy: +/- 4 dBm
 *             Values:
 *             - -20 ... 10
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_advertising_physical_channel_tx_power(int8_t *Transmit_Power_Level);
/**
 * @brief The LE_Set_Advertise_Enable command is used to request the Controller
 *        to start or stop advertising. The Controller manages the timing of
 *        advertisements as per the advertising parameters given in the
 *        LE_Set_Advertising_Parameters command. The Controller shall continue
 *        advertising until the Host issues an LE_Set_Advertise_Enable command
 *        with Advertising_Enable set to 0x00 (Advertising is disabled) or until
 *        a connection is created or until the Advertising is timed out due to
 *        high duty cycle Directed Advertising. In these cases, advertising is
 *        then disabled. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
 *        7.8.9)
 * @param Advertising_Enable Enable/disable advertise. Default is 0 (disabled).
 *        Values:
 *        - 0x00: Disable
 *        - 0x01: Enable
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_advertising_enable(uint8_t Advertising_Enable);
/**
 * @brief The LE_Set_Scan_Parameters command is used to set the scan parameters.
 *        The LE_Scan_Type parameter controls the type of scan to perform. The
 *        LE_Scan_Interval and LE_Scan_Window parameters are recommendations
 *        from the Host on how long (LE_Scan_Window) and how frequently
 *        (LE_Scan_Interval) the Controller should scan (See [Vol 6] Part B,
 *        Section 4.5.3). The LE_Scan_Window parameter shall always be set to a
 *        value smaller or equal to the value set for the LE_Scan_Interval
 *        parameter. If they are set to the same value scanning should be run
 *        continuously. The Own_Address_Type parameter determines the address
 *        used (Public or Random Device Address) when performing active scan.
 *        The Host shall not issue this command when scanning is enabled in the
 *        Controller; if it is the Command Disallowed error code shall be used.
 *        (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.10)
 * @param LE_Scan_Type Passive or active scanning. With active scanning SCAN_REQ
 *        packets are sent.
 *        Values:
 *        - 0x00: Passive Scanning
 *        - 0x01: Active scanning
 * @param LE_Scan_Interval This is defined as the time interval from when the
 *        Controller started its last LE scan until it begins the subsequent LE
 *        scan. Time = N * 0.625 msec.
 *        Values:
 *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) 
 * @param LE_Scan_Window The duration of the LE scan. LE_Scan_Window shall be
 *        less than or equal to LE_Scan_Interval. Time = N * 0.625 msec.
 *        Values:
 *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) 
 * @param Own_Address_Type Own address type.  - 0x00: Public Device Address  -
 *        0x01 Random Device Address  - 0x02: Controller generates Resolvable
 *        Private Address based on the local          IRK from resolving list.
 *        If resolving list contains no matching entry,          use public
 *        address.  - 0x03: Controller generates Resolvable Private Address
 *        based on the local          IRK from resolving list. If resolving list
 *        contains no matching entry,          use random address from
 *        LE_Set_Random_Address.
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Resolvable Private Address or Public Address
 *        - 0x03: Resolvable Private Address or Random Address
 * @param Scanning_Filter_Policy See Scanning filter policy in Bluetooth Core
 *        specification.
 *        Values:
 *        - 0x00: Basic unfiltered scanning filter policy
 *        - 0x01: Basic filtered scanning filter policy
 *        - 0x02: Extended unfiltered scanning filter policy
 *        - 0x03: Extended filtered scanning filter policy
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_scan_parameters(uint8_t LE_Scan_Type,
                                      uint16_t LE_Scan_Interval,
                                      uint16_t LE_Scan_Window,
                                      uint8_t Own_Address_Type,
                                      uint8_t Scanning_Filter_Policy);
/**
 * @brief The LE_Set_Scan_Enable command is used to start scanning. Scanning is
 *        used to discover advertising devices nearby. The Filter_Duplicates
 *        parameter controls whether the Link Layer shall filter duplicate
 *        advertising reports to the Host, or if the Link Layer should generate
 *        advertising reports for each packet received. (See Bluetooth
 *        Specification v.4.1, Vol. 2, Part E, 7.8.11)
 * @param LE_Scan_Enable Enable/disable scan. Default is 0 (disabled).
 *        Values:
 *        - 0x00: Scanning disabled
 *        - 0x01: Scanning enabled
 * @param Filter_Duplicates Enable/disable duplicate filtering.
 *        Values:
 *        - 0x00: Duplicate filtering disabled
 *        - 0x01: Duplicate filtering enabled
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_scan_enable(uint8_t LE_Scan_Enable,
                                  uint8_t Filter_Duplicates);
/**
 * @brief The LE_Create_Connection command is used to create a Link Layer
 *        connection to a connectable advertiser. The LE_Scan_Interval and
 *        LE_Scan_Window parameters are recommendations from the Host on how
 *        long (LE_Scan_Window) and how frequently (LE_Scan_Interval) the
 *        Controller should scan. The LE_Scan_Window parameter shall be set to a
 *        value smaller or equal to the value set for the LE_Scan_Interval
 *        parameter. If both are set to the same value, scanning should run
 *        continuously. The Initiator_Filter_Policy is used to determine whether
 *        the Filter Accept List is used. If the Filter Accept List is not used,
 *        the Peer_Address_Type and the Peer_Address parameters specify the
 *        address type and address of the advertising device to connect to. The
 *        Link Layer shall set the address in the CONNECT_REQ packets to either
 *        the Public Device Address or the Random Device Addressed based on the
 *        Own_Address_Type parameter. The Connection_Interval_Min and
 *        Connection_Interval_Max parameters define the minimum and maximum
 *        allowed connection interval. The Connection_Interval_Min parameter
 *        shall not be greater than the Connection_Interval_Max parameter. The
 *        Max_Latency parameter defines the maximum allowed connection latency
 *        (see [Vol 6] Part B, Section 4.5.1). The Supervision_Timeout parameter
 *        defines the link supervision timeout for the connection. The
 *        Supervision_Timeout in milliseconds shall be larger than (1 +
 *        Max_Latency) * Connection_Interval_Max * 2, where
 *        Connection_Interval_Max is given in milliseconds. (See [Vol 6] Part B,
 *        Section 4.5.2). The Min_CE_Length and Max_CE_Length parameters are
 *        informative parameters providing the Controller with the expected
 *        minimum and maximum length of the connection events. The Min_CE_Length
 *        parameter shall be less than or equal to the Max_CE_Length parameter.
 *        The Host shall not issue this command when another
 *        LE_Create_Connection is pending in the Controller; if this does occur
 *        the Controller shall return the Command Disallowed error code shall be
 *        used. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.12)
 * @param LE_Scan_Interval This is defined as the time interval from when the
 *        Controller started its last LE scan until it begins the subsequent LE
 *        scan. Time = N * 0.625 msec.
 *        Values:
 *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) 
 * @param LE_Scan_Window The duration of the LE scan. LE_Scan_Window shall be
 *        less than or equal to LE_Scan_Interval. Time = N * 0.625 msec.
 *        Values:
 *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) 
 * @param Initiator_Filter_Policy 0x00 Filter Accept List is not used to
 *        determine which advertiser to connect to. Peer_Address_Type and
 *        Peer_Address shall be used. 0x01 Filter Accept List is used to
 *        determine which advertiser to connect to. Peer_Address_Type and
 *        Peer_Address shall be ignored.
 *        Values:
 *        - 0x00: Filter Accept List not used
 *        - 0x01: Filter Accept List used
 * @param Peer_Address_Type 0x00 Public Device Address 0x01 Random Device
 *        Address 0x02 Public Identity Address (Corresponds to Resolved Private
 *        Address) 0x03 Random (Static) Identity Address (Corresponds to
 *        Resolved Private Address)
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Public Identity Address
 *        - 0x03: Random (Static) Identity Address
 * @param Peer_Address Public Device Address, Random Device Address, Public
 *        Identity Address or Random (static) Identity Address of the
 *        advertising device.
 * @param Own_Address_Type Own address type.  - 0x00: Public Device Address  -
 *        0x01 Random Device Address  - 0x02: Controller generates Resolvable
 *        Private Address based on the local          IRK from resolving list.
 *        If resolving list contains no matching entry,          use public
 *        address.  - 0x03: Controller generates Resolvable Private Address
 *        based on the local          IRK from resolving list. If resolving list
 *        contains no matching entry,          use random address from
 *        LE_Set_Random_Address.
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Resolvable Private Address or Public Address
 *        - 0x03: Resolvable Private Address or Random Address
 * @param Connection_Interval_Min Minimum value for the connection event
 *        interval. This shall be less than or equal to Connection_Interval_Max.
 *        Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Connection_Interval_Max Maximum value for the connection event
 *        interval. This shall be greater than or equal to
 *        Connection_Interval_Min. Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Max_Latency Maximum Peripheral latency for the connection in number of
 *        connection events.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Supervision_Timeout Supervision timeout for the LE Link. It shall be a
 *        multiple of 10 ms and larger than (1 + connPeripheralLatency) *
 *        connInterval * 2. Time = N * 10 msec.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 * @param Min_CE_Length The minimum length of connection event recommended for
 *        this LE connection. Time = N * 0.625 msec.
 * @param Max_CE_Length The maximum length of connection event recommended for
 *        this LE connection. Time = N * 0.625 msec.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_create_connection(uint16_t LE_Scan_Interval,
                                    uint16_t LE_Scan_Window,
                                    uint8_t Initiator_Filter_Policy,
                                    uint8_t Peer_Address_Type,
                                    uint8_t Peer_Address[6],
                                    uint8_t Own_Address_Type,
                                    uint16_t Connection_Interval_Min,
                                    uint16_t Connection_Interval_Max,
                                    uint16_t Max_Latency,
                                    uint16_t Supervision_Timeout,
                                    uint16_t Min_CE_Length,
                                    uint16_t Max_CE_Length);
/**
 * @brief The LE_Create_Connection_Cancel command is used to cancel the
 *        LE_Create_Connection command. This command shall only be issued after
 *        the LE_Create_Connection command has been issued, a Command Status
 *        event has been received for the LE Create Connection command and
 *        before the LE Connection Complete event. (See Bluetooth Specification
 *        v.4.1, Vol. 2, Part E, 7.8.13)
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_create_connection_cancel(void);
/**
 * @brief The LE_Read_Filter_Accept_List_Size command is used to read the total
 *        number of Filter Accept list entries that can be stored in the
 *        Controller.
 * @param[out] Filter_Accept_List_Size Total number of Filter Accept List
 *             entries that can be stored in the Controller.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_filter_accept_list_size(uint8_t *Filter_Accept_List_Size);
/**
 * @brief The LE_Clear_Filter_Accept_List command is used to clear the Filter
 *        Accept list stored in the Controller. This command can be used at any
 *        time except when: - the advertising filter policy uses the Filter
 *        Accept list and advertising is enabled. - the scanning filter policy
 *        uses the Filter Accept list and scanning is enabled. - the initiator
 *        filter policy uses the Filter Accept list and an LE_Create_Connection
 *        command is outstanding.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_clear_filter_accept_list(void);
/**
 * @brief The LE_Add_Device_To_Filter_Accept_List command is used to add a
 *        single device to the Filter Accept list stored in the Controller. This
 *        command can be used at any time except when: - the advertising filter
 *        policy uses the Filter Accept list and advertising is enabled. - the
 *        scanning filter policy uses the Filter Accept list and scanning is
 *        enabled. - the initiator filter policy uses the Filter Accept list and
 *        a create connection command is outstanding.
 * @param Address_Type Address type.
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 * @param Address Public Device Address or Random Device Address of the device
 *        to be added to the list.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_add_device_to_filter_accept_list(uint8_t Address_Type,
                                                   uint8_t Address[6]);
/**
 * @brief The LE_Remove_Device_From_Filter_Accept_List command is used to remove
 *        a single device from the Filter Accept list stored in the Controller.
 *        This command can be used at any time except when: - the advertising
 *        filter policy uses the Filter Accept list and advertising is enabled.
 *        - the scanning filter policy uses the Filter Accept list and scanning
 *        is enabled. - the initiator filter policy uses the Filter Accept list
 *        and a create connection command is outstanding.
 * @param Address_Type Address type.
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 * @param Address Public Device Address or Random Device Address of the device
 *        to be removed from the Filter Accept List.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_remove_device_from_filter_accept_list(uint8_t Address_Type,
                                                        uint8_t Address[6]);
/**
 * @brief The LE_Connection_Update command is used to change the Link Layer
 *        connection parameters of a connection. This command is supported only
 *        on central side. The Connection_Interval_Min and
 *        Connection_Interval_Max parameters are used to define the minimum and
 *        maximum allowed connection interval. The Connection_Interval_Min
 *        parameter shall not be greater than the Connection_Interval_Max
 *        parameter. The Max_Latency parameter shall define the maximum allowed
 *        connection latency. The Supervision_Timeout parameter shall define the
 *        link supervision timeout for the LE link. The Supervision_Timeout in
 *        milliseconds shall be larger than (1 + Max_Latency) *
 *        Connection_Interval_Max * 2, where Connection_Interval_Max is given in
 *        milliseconds. The Min_CE_Length and Max_CE_Length are information
 *        parameters providing the Controller with a hint about the expected
 *        minimum and maximum length of the connection events. The Min_CE_Length
 *        shall be less than or equal to the Max_CE_Length. The actual parameter
 *        values selected by the Link Layer may be different from the parameter
 *        values provided by the Host through this command. (See Bluetooth
 *        Specification v.4.1, Vol. 2, Part E, 7.8.18)
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Connection_Interval_Min Minimum value for the connection event
 *        interval. This shall be less than or equal to Connection_Interval_Max.
 *        Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Connection_Interval_Max Maximum value for the connection event
 *        interval. This shall be greater than or equal to
 *        Connection_Interval_Min. Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Max_Latency Maximum Peripheral latency for the connection in number of
 *        connection events.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Supervision_Timeout Supervision timeout for the LE Link. It shall be a
 *        multiple of 10 ms and larger than (1 + connPeripheralLatency) *
 *        connInterval * 2. Time = N * 10 msec.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 * @param Min_CE_Length The minimum length of connection event recommended for
 *        this LE connection. Time = N * 0.625 msec.
 * @param Max_CE_Length The maximum length of connection event recommended for
 *        this LE connection. Time = N * 0.625 msec.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_connection_update(uint16_t Connection_Handle,
                                    uint16_t Connection_Interval_Min,
                                    uint16_t Connection_Interval_Max,
                                    uint16_t Max_Latency,
                                    uint16_t Supervision_Timeout,
                                    uint16_t Min_CE_Length,
                                    uint16_t Max_CE_Length);
/**
 * @brief The HCI_LE_Set_Host_Channel_Classification command allows the Host to
 *        specify a channel classification for the data, secondary advertising,
 *        periodic, and isochronous physical channels based on its local
 *        information. This classification persists until overwritten with a
 *        subsequent HCI_LE_Set_Host_Channel_Classification command or until the
 *        Controller is reset using the HCI_Reset command. If this command is
 *        used, the Host should send it within 10 seconds of knowing that the
 *        channel classification has changed. The interval between two
 *        successive commands sent shall be at least one second.
 * @param LE_Channel_Map This parameter contains 37 1-bit fields. The nth such
 *        field (in the range 0 to 36) contains the value for the link layer
 *        channel index n. Channel n is bad = 0. Channel n is unknown = 1. The
 *        most significant bits are reserved and shall be set to 0. At least one
 *        channel shall be marked as unknown.
 *        Flags:
 *        - 0x0000000000 ... 0x1FFFFFFFFF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_host_channel_classification(uint8_t LE_Channel_Map[5]);
/**
 * @brief The LE_Read_Channel_Map command returns the current Channel_Map for
 *        the specified Connection_Handle. The returned value indicates the
 *        state of the Channel_Map specified by the last transmitted or received
 *        Channel_Map (in a CONNECT_REQ or LL_CHANNEL_MAP_REQ message) for the
 *        specified Connection_Handle, regardless of whether the Central has
 *        received an acknowledgement. (See Bluetooth Specification v.4.1, Vol.
 *        2, Part E, 7.8.20)
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param[out] LE_Channel_Map This parameter contains 37 1-bit fields. The nth
 *             such field (in the range 0 to 36) contains the value for the link
 *             layer channel index n. Channel n is unused = 0. Channel n is used
 *             = 1. The most significant bits are reserved and shall be set to
 *             0.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_channel_map(uint16_t Connection_Handle,
                                   uint8_t LE_Channel_Map[5]);
/**
 * @brief This command requests a list of the used LE features from the remote
 *        device. This command shall return a list of the used LE features. For
 *        details see [Vol 6] Part B, Section 4.6. This command may be issued on
 *        both the central and peripheral. (See Bluetooth Specification v.4.1,
 *        Vol. 2, Part E, 7.8.21)
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_remote_features(uint16_t Connection_Handle);
/**
 * @brief The LE_Encrypt command is used to request the Controller to encrypt
 *        the Plaintext_Data in the command using the Key given in the command
 *        and returns the Encrypted_Data to the Host. The AES-128 bit block
 *        cypher is defined in NIST Publication FIPS-197
 *        (http://csrc.nist.gov/publications/fips/ fips197/fips-197.pdf). (See
 *        Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.22)
 * @param Key 128 bit key for the encryption of the data given in the command.
 * @param Plaintext_Data 128 bit data block that is requested to be encrypted.
 * @param[out] Encrypted_Data 128 bit encrypted data block.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_encrypt(uint8_t Key[16],
                          uint8_t Plaintext_Data[16],
                          uint8_t Encrypted_Data[16]);
/**
 * @brief The LE_Rand command is used to request the Controller to generate 8
 *        octets of random data to be sent to the Host. The Random_Number shall
 *        be generated according to [Vol 2] Part H, Section 2 if the LE Feature
 *        (LL Encryption) is supported. (See Bluetooth Specification v.4.1, Vol.
 *        2, Part E, 7.8.23)
 * @param[out] Random_Number Random Number
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_rand(uint8_t Random_Number[8]);
/**
 * @brief The LE_Enable_Encryption command is used to authenticate the given
 *        encryption key associated with the remote device specified by the
 *        connection handle, and once authenticated will encrypt the connection.
 *        The parameters are as defined in [Vol 3] Part H, Section 2.4.4. If the
 *        connection is already encrypted then the Controller shall pause
 *        connection encryption before attempting to authenticate the given
 *        encryption key, and then re-encrypt the connection. While encryption
 *        is paused no user data shall be transmitted. On an authentication
 *        failure, the connection shall be automatically disconnected by the
 *        Link Layer. If this command succeeds, then the connection shall be
 *        encrypted. This command shall only be used when the local device's
 *        role is Central.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Random_Number 64 bit random number.
 * @param Encrypted_Diversifier 16 bit encrypted diversifier.
 * @param Long_Term_Key 128 bit long term key.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_enable_encryption(uint16_t Connection_Handle,
                                    uint8_t Random_Number[8],
                                    uint16_t Encrypted_Diversifier,
                                    uint8_t Long_Term_Key[16]);
/**
 * @brief The LE_Long_Term_Key_Request_Reply command is used to reply to an LE
 *        Long Term Key Request event from the Controller, and specifies the
 *        Long_Term_Key parameter that shall be used for this Connection_Handle.
 *        The Long_Term_Key is used as defined in [Vol 6] Part B, Section 5.1.3.
 *        (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.25)
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Long_Term_Key 128 bit long term key.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_long_term_key_request_reply(uint16_t Connection_Handle,
                                              uint8_t Long_Term_Key[16]);
/**
 * @brief The LE_Long_Term_Key_Request_Negative_Reply command is used to reply
 *        to an LE Long Term Key Request event from the Controller if the Host
 *        cannot provide a Long Term Key for this Connection_Handle. (See
 *        Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.26)
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_long_term_key_request_negative_reply(uint16_t Connection_Handle);
/**
 * @brief The LE_Read_Supported_States command reads the states and state
 *        combinations that the link layer supports. See [Vol 6] Part B, Section
 *        1.1.1. LE_States is an 8-octet bit field. If a bit is set to 1 then
 *        this state or state combination is supported by the Controller.
 *        Multiple bits in LE_States may be set to 1 to indicate support for
 *        multiple state and state combinations. All the Advertising type with
 *        the Initiate State combinations shall be set only if the corresponding
 *        Advertising types and Central Role combination are set. All the
 *        Scanning types and the Initiate State combinations shall be set only
 *        if the corresponding Scanning types and Central Role combination are
 *        set. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.27)
 * @param[out] LE_States State or state combination is supported by the
 *             Controller. See Core v4.1, Vol.2, part E, Ch. 7.8.27.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_supported_states(uint8_t LE_States[8]);
/**
 * @brief The LE_Set_Data_Length command allows the Host to suggest maximum
 *        transmission packet size and maximum packet transmission time
 *        (connMaxTxOctets and connMaxTxTime - see [Vol 6] Part B, Section
 *        4.5.10) to be used for a given connection. The Controller may use
 *        smaller or larger values based on local information.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param TxOctets Preferred maximum number of payload octets that the local
 *        Controller should include in a single Link Layer Data Channel PDU.
 *        Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF) Reserved for
 *        future use). Default: 27 bytes.
 *        Values:
 *        - 0x001B ... 0x00FB
 * @param TxTime Preferred maximum number of microseconds that the local
 *        Controller should use to transmit a single Link Layer Data Channel
 *        PDU. Range 0x0148-0x0848 (0x0000 - 0x0147 and 0x0849 - 0xFFFF Reserved
 *        for future use). Default: 328 bytes.
 *        Values:
 *        - 0x0148 ... 0x0848
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_data_length(uint16_t Connection_Handle,
                                  uint16_t TxOctets,
                                  uint16_t TxTime);
/**
 * @brief The LE_Read_Suggested_Default_Data_Length command allows the Host to
 *        read the Host preferred values for the Controller maximum transmitted
 *        number of payload octets and maximum packet transmission time to be
 *        used for new connections (connInitialMaxTxOctets and
 *        connInitialMaxTxTime - see ([Vol 6] Part B, Section 4.5.10).
 * @param[out] SuggestedMaxTxOctets The Host suggested value for the Controller
 *             maximum transmitted number of payload octets to be used for new
 *             connections - connInitialMaxTxOctets. Range 0x001B-0x00FB (0x0000
 *             - 0x001A and 0x00FC - 0xFFFF Reserved for future use) Default:
 *             0x001B
 * @param[out] SuggestedMaxTxTime The Host suggested value for the Controller
 *             maximum packet transmission time to be used for new connections -
 *             connInitialMaxTx-Time. Range 0x0148-0x0848 (0x0000 - 0x0147 and
 *             0x0849 - 0xFFFF Reserved for future use) Default: 0x0148
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_suggested_default_data_length(uint16_t *SuggestedMaxTxOctets,
                                                     uint16_t *SuggestedMaxTxTime);
/**
 * @brief The LE_Write_Suggested_Default_Data_Length command allows the Host to
 *        specify its preferred values for the Controller maximum transmission
 *        number of payload octets and maximum packet transmission time to be
 *        used for new connections (connInitialMaxTxOctets and
 *        connInitialMaxTxTime - see [Vol 6] Part B, Section 4.5.10). The
 *        Controller may use smaller or larger values based on local
 *        information.
 * @param SuggestedMaxTxOctets The Host suggested value for the Controller
 *        maximum transmitted number of payload octets to be used for new
 *        connections - connInitialMaxTxOctets. Range 0x001B-0x00FB (0x0000 -
 *        0x001A and 0x00FC - 0xFFFF Reserved for future use)
 *        Values:
 *        - 0x001B ... 0x00FB
 * @param SuggestedMaxTxTime The Host suggested value for the Controller maximum
 *        packet transmission time to be used for new connections -
 *        connInitialMaxTx-Time. Range 0x0148-0x0848 (0x0000 - 0x0147 and 0x0849
 *        - 0xFFFF Reserved for future use)
 *        Values:
 *        - 0x0148 ... 0x0848
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_write_suggested_default_data_length(uint16_t SuggestedMaxTxOctets,
                                                      uint16_t SuggestedMaxTxTime);
/**
 * @brief The LE_Read_Local_P-256_Public_Key command is used to return the local
 *        P-256 public key from the Controller. The Controller shall generate a
 *        new P-256 public/private key pair upon receipt of this command. (See
 *        Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.36)
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_local_p256_public_key(void);
/**
 * @brief The LE_Generate_DHKey command is used to initiate generation of a
 *        Diffie- Hellman key in the Controller for use over the LE transport.
 *        This command takes the remote P-256 public key as input. The Diffie-
 *        Hellman key generation uses the private key generated by
 *        LE_Read_Local_P256_Public_Key command. (See Bluetooth Specification
 *        v.4.2, Vol. 2, Part E, 7.8.37)
 * @param Remote_P256_Public_Key The remote P-256 public key: X, Y format Octets
 *        31-0: X coordinate Octets 63-32: Y coordinate Little Endian Format
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_generate_dhkey(uint8_t Remote_P256_Public_Key[64]);
/**
 * @brief The LE_Add_Device_To_Resolving_List command is used to add one device
 *        to the list of address translations used to resolve Resolvable Private
 *        Addresses in the Controller. This command cannot be used when address
 *        translation is enabled in the Controller and: - Advertising is enabled
 *        - Scanning is enabled - Create connection command is outstanding This
 *        command can be used at any time when address translation is disabled
 *        in the Controller. When a Controller cannot add a device to the
 *        resolving list because the list is full, it shall respond with error
 *        code 0x07 (Memory Capacity Exceeded). (See Bluetooth Specification
 *        v.4.2, Vol. 2, Part E, 7.8.38)
 * @param Peer_Identity_Address_Type Identity address type.
 *        Values:
 *        - 0x00: Public Identity Address
 *        - 0x01: Random (static) Identity Address
 * @param Peer_Identity_Address Public or Random (static) Identity address of
 *        the peer device
 * @param Peer_IRK IRK of the peer device
 * @param Local_IRK IRK of the local device
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_add_device_to_resolving_list(uint8_t Peer_Identity_Address_Type,
                                               uint8_t Peer_Identity_Address[6],
                                               uint8_t Peer_IRK[16],
                                               uint8_t Local_IRK[16]);
/**
 * @brief The LE_Remove_Device_From_Resolving_List command is used to remove one
 *        device from the list of address translations used to resolve
 *        Resolvable Private Addresses in the controller. This command cannot be
 *        used when address translation is enabled in the Controller and: -
 *        Advertising is enabled - Scanning is enabled - Create connection
 *        command is outstanding This command can be used at any time when
 *        address translation is disabled in the Controller. When a Controller
 *        cannot remove a device from the resolving list because it is not
 *        found, it shall respond with error code 0x02 (Unknown Connection
 *        Identifier). (See Bluetooth Specification v.4.2, Vol. 2, Part E,
 *        7.8.39)
 * @param Peer_Identity_Address_Type Identity address type.
 *        Values:
 *        - 0x00: Public Identity Address
 *        - 0x01: Random (static) Identity Address
 * @param Peer_Identity_Address Public or Random (static) Identity address of
 *        the peer device
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_remove_device_from_resolving_list(uint8_t Peer_Identity_Address_Type,
                                                    uint8_t Peer_Identity_Address[6]);
/**
 * @brief The LE_Clear_Resolving_List command is used to remove all devices from
 *        the list of address translations used to resolve Resolvable Private
 *        Addresses in the Controller. This command cannot be used when address
 *        translation is enabled in the Controller and: - Advertising is enabled
 *        - Scanning is enabled - Create connection command is outstanding This
 *        command can be used at any time when address translation is disabled
 *        in the Controller. (See Bluetooth Specification v.4.2, Vol. 2, Part E,
 *        7.8.40)
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_clear_resolving_list(void);
/**
 * @brief The LE_Read_Resolving_List_Size command is used to read the total
 *        number of address translation entries in the resolving list that can
 *        be stored in the Controller. (See Bluetooth Specification v.4.2, Vol.
 *        2, Part E, 7.8.41)
 * @param[out] Resolving_List_Size Number of address translation entries in the
 *             resolving list
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_resolving_list_size(uint8_t *Resolving_List_Size);
/**
 * @brief The LE_Read_Peer_Resolvable_Address command is used to get the current
 *        peer Resolvable Private Address being used for the corresponding peer
 *        Public and Random (static) Identity Address. The peer's resolvable
 *        address being used may change after the command is called. This
 *        command can be used at any time. When a Controller cannot find a
 *        Resolvable Private Address associated with the Peer Identity Address,
 *        it shall respond with error code 0x02 (Unknown Connection Identifier).
 *        (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.42)
 * @param Peer_Identity_Address_Type Identity address type.
 *        Values:
 *        - 0x00: Public Identity Address
 *        - 0x01: Random (static) Identity Address
 * @param Peer_Identity_Address Public or Random (static) Identity address of
 *        the peer device
 * @param[out] Peer_Resolvable_Address Resolvable Private Address being used by
 *             the peer device
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_peer_resolvable_address(uint8_t Peer_Identity_Address_Type,
                                               uint8_t Peer_Identity_Address[6],
                                               uint8_t Peer_Resolvable_Address[6]);
/**
 * @brief The LE_Read_Local_Resolvable_Address command is used to get the
 *        current local Resolvable Private Address being used for the
 *        corresponding peer Identity Address. The local's resolvable address
 *        being used may change after the command is called. This command can be
 *        used at any time. When a Controller cannot find a Resolvable Private
 *        Address associated with the Peer Identity Address, it shall respond
 *        with error code 0x02 (Unknown Connection Identifier). (See Bluetooth
 *        Specification v.4.2, Vol. 2, Part E, 7.8.43)
 * @param Peer_Identity_Address_Type Identity address type.
 *        Values:
 *        - 0x00: Public Identity Address
 *        - 0x01: Random (static) Identity Address
 * @param Peer_Identity_Address Public or Random (static) Identity address of
 *        the peer device
 * @param[out] Local_Resolvable_Address Resolvable Private Address being used by
 *             the local device
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_local_resolvable_address(uint8_t Peer_Identity_Address_Type,
                                                uint8_t Peer_Identity_Address[6],
                                                uint8_t Local_Resolvable_Address[6]);
/**
 * @brief The LE_Set_Address_Resolution_Enable command is used to enable
 *        resolution of Resolvable Private Addresses in the Controller. This
 *        causes the Controller to use the resolving list whenever the
 *        Controller receives a local or peer Resolvable Private Address. This
 *        command can be used at any time except when: - Advertising is enabled
 *        - Scanning is enabled - Create connection command is outstanding (See
 *        Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.44)
 * @param Address_Resolution_Enable Enable/disable address resolution in the
 *        controller. 0x00: Address Resolution in controller disabled (default),
 *        0x01: Address Resolution in controller enabled
 *        Values:
 *        - 0x00: Address Resolution in controller disabled (default)
 *        - 0x01: Address Resolution in controller enabled
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_address_resolution_enable(uint8_t Address_Resolution_Enable);
/**
 * @brief The LE_Set_Resolvable_Private_Address_Timeout command set the length
 *        of time the controller uses a Resolvable Private Address before a new
 *        resolvable private address is generated and starts being used. This
 *        timeout applies to all addresses generated by the controller. (See
 *        Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.45)
 * @param RPA_Timeout RPA_Timeout measured in seconds. Range for N: 0x0001 -
 *        0xA1B8 (1 sec - approximately 11.5 hours) Default: N= 0x0384 (900 secs
 *        or 15 minutes)
 *        Values:
 *        - 0x0001 ... 0xA1B8
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_resolvable_private_address_timeout(uint16_t RPA_Timeout);
/**
 * @brief The LE_Read_Maximum_Data_Length command allows the Host to read the
 *        Controller  maximum supported payload octets and packet duration times
 *        for transmission and reception (supportedMaxTxOctets and
 *        supportedMaxTxTime, supportedMaxRxOctets, and supportedMaxRxTime, see
 *        [Vol 6] Part B, Section 4.5.10).
 * @param[out] supportedMaxTxOctets Maximum number of payload octets that the
 *             local Controller supports for transmission of a single Link Layer
 *             Data Channel PDU. Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC
 *             - 0xFFFF Reserved for future use)
 * @param[out] supportedMaxTxTime Maximum time, in microseconds, that the local
 *             Controller supports for transmission of a single Link Layer Data
 *             Channel PDU. Range 0x0148-0x0848 (0x0000 - 0x0147 and 0x0849 -
 *             0xFFFF Reserved for future use)
 * @param[out] supportedMaxRxOctets Maximum number of payload octets that the
 *             local Controller supports for reception of a single Link Layer
 *             Data Channel PDU. Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC
 *             - 0xFFFF Reserved for future use)
 * @param[out] supportedMaxRxTime Maximum time, in microseconds, that the local
 *             Controller supports for reception of a single Link Layer Data
 *             Channel PDU. Range 0x0148-0x0848 (0x0000 - 0x0147 and 0x0849 -
 *             0xFFFF Reserved for future use)
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_maximum_data_length(uint16_t *supportedMaxTxOctets,
                                           uint16_t *supportedMaxTxTime,
                                           uint16_t *supportedMaxRxOctets,
                                           uint16_t *supportedMaxRxTime);
/**
 * @brief The LE_Read_PHY command is used to read the current transmitter PHY
 *        and receiver PHY on the connection identified by the
 *        Connection_Handle.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param[out] TX_PHY Transmitter PHY for the connection 0x01: The transmitter
 *             PHY for the connection is LE 1M 0x02: The transmitter PHY for the
 *             connection is LE 2M 0x03: The transmitter PHY for the connection
 *             is LE Coded
 *             Values:
 *             - 0x01: LE_1M_PHY
 *             - 0x02: LE_2M_PHY
 *             - 0x03: LE_CODED_PHY
 * @param[out] RX_PHY Receiver PHY for the connection. 0x01: The receiver PHY
 *             for the connection is LE 1M 0x02: The receiver PHY for the
 *             connection is LE 2M 0x03: The receiver PHY for the connection is
 *             LE Coded All other values: Reserved for future use
 *             Values:
 *             - 0x01: The receiver PHY for the connection is LE 1M
 *             - 0x02: The receiver PHY for the connection is LE 2M
 *             - 0x03: The receiver PHY for the connection is LE Coded
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_phy(uint16_t Connection_Handle,
                           uint8_t *TX_PHY,
                           uint8_t *RX_PHY);
/**
 * @brief The LE_Set_Default_PHY command allows the Host to specify its
 *        preferred values for the transmitter PHY and receiver PHY to be used
 *        for all subsequent connections over the LE transport.
 * @param ALL_PHYS The ALL_PHYS parameter is a bit field that allows the Host to
 *        specify, for each direction, whether it has no preference among the
 *        PHYs that the Controller supports in a given direction or whether it
 *        has specified particular PHYs that it prefers in the TX_PHYS or
 *        RX_PHYS parameter. Bits: 0: The Host has no preference among the
 *        transmitter PHYs supported by the Controller 1: The Host has no
 *        preference among the receiver PHYs supported by the Controller
 *        Flags:
 *        - 0x01: No preference for TX
 *        - 0x02: No preference for RX
 * @param TX_PHYS The TX_PHYS parameter is a bit field that indicates the
 *        transmitter PHYs that the Host prefers the Controller to use. If the
 *        ALL_PHYS parameter specifies that the Host has no preference, the
 *        TX_PHYS parameter is ignored; otherwise at least one bit shall be set
 *        to 1. Bits: 0: The Host prefers to use the LE 1M transmitter PHY
 *        (possibly among others) 1: The Host prefers to use the LE 2M
 *        transmitter PHY (possibly among others) 2: The Host prefers to use the
 *        LE Coded transmitter PHY (possibly among others) 3-7: Reserved for
 *        future use
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x02: LE_2M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param RX_PHYS The RX_PHYS parameter is a bit field that indicates the
 *        receiver PHYs that the Host prefers the Controller to use. If the
 *        ALL_PHYS parameter specifies that the Host has no preference, the
 *        RX_PHYS parameter is ignored; otherwise at least one bit shall be set
 *        to 1. Bits: 0: The Host prefers to use the LE 1M receiver PHY
 *        (possibly among others) 1: The Host prefers to use the LE 2M receiver
 *        PHY (possibly among others) 2: The Host prefers to use the LE Coded
 *        receiver PHY (possibly among others) 3-7: Reserved for future use
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x02: LE_2M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_default_phy(uint8_t ALL_PHYS,
                                  uint8_t TX_PHYS,
                                  uint8_t RX_PHYS);
/**
 * @brief The LE_Set_PHY command is used to set the PHY preferences for the
 *        connection identified by the Connection_Handle. The Controller might
 *        not be able to make the change (e.g. because the peer does not support
 *        the requested PHY) or may decide that the current PHY is preferable.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param ALL_PHYS The ALL_PHYS parameter is a bit field that allows the Host to
 *        specify, for each direction, whether it has no preference among the
 *        PHYs that the Controller supports in a given direction or whether it
 *        has specified particular PHYs that it prefers in the TX_PHYS or
 *        RX_PHYS parameter. Bits: 0: The Host has no preference among the
 *        transmitter PHYs supported by the Controller 1: The Host has no
 *        preference among the receiver PHYs supported by the Controller
 *        Flags:
 *        - 0x01: No preference for TX
 *        - 0x02: No preference for RX
 * @param TX_PHYS The TX_PHYS parameter is a bit field that indicates the
 *        transmitter PHYs that the Host prefers the Controller to use. If the
 *        ALL_PHYS parameter specifies that the Host has no preference, the
 *        TX_PHYS parameter is ignored; otherwise at least one bit shall be set
 *        to 1. Bits: 0: The Host prefers to use the LE 1M transmitter PHY
 *        (possibly among others) 1: The Host prefers to use the LE 2M
 *        transmitter PHY (possibly among others) 2: The Host prefers to use the
 *        LE Coded transmitter PHY (possibly among others) 3-7: Reserved for
 *        future use
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x02: LE_2M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param RX_PHYS The RX_PHYS parameter is a bit field that indicates the
 *        receiver PHYs that the Host prefers the Controller to use. If the
 *        ALL_PHYS parameter specifies that the Host has no preference, the
 *        RX_PHYS parameter is ignored; otherwise at least one bit shall be set
 *        to 1. Bits: 0: The Host prefers to use the LE 1M receiver PHY
 *        (possibly among others) 1: The Host prefers to use the LE 2M receiver
 *        PHY (possibly among others) 2: The Host prefers to use the LE Coded
 *        receiver PHY (possibly among others) 3-7: Reserved for future use
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x02: LE_2M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param PHY_options The PHY_options parameter is a bit field that allows the
 *        Host to specify options for PHYs. The default value for a new
 *        connection shall be all zero bits. The Controller may override any
 *        preferred coding for transmitting on the LE Coded PHY. The Host may
 *        specify a preferred coding even if it prefers not to use the LE Coded
 *        transmitter PHY since the Controller may override the PHY preference.
 *        0 = the Host has no preferred coding when transmitting on the LE Coded
 *        PHY 1 = the Host prefers that S=2 coding be used when transmitting on
 *        the LE Coded PHY 2 = the Host prefers that S=8 coding be used when
 *        transmitting on the LE Coded PHY
 *        Values:
 *        - 0: No preferred LE Coded PHY
 *        - 1: S=2 preferred on LE Coded PHY
 *        - 2: S=8 preferred on LE Coded PHY
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_phy(uint16_t Connection_Handle,
                          uint8_t ALL_PHYS,
                          uint8_t TX_PHYS,
                          uint8_t RX_PHYS,
                          uint16_t PHY_options);
/**
 * @brief The LE_Set_Advertising_Set_Random_Address command is used by the Host
 *        to set the random device address specified by the Random_Address
 *        parameter. This address is used in the Controller (see [Vol 6] Part B,
 *        Section 1.3.2) for the advertiser's address contained in the
 *        advertising PDUs for the advertising set specified by the
 *        Advertising_Handle parameter. If the Host issues this command while an
 *        advertising set using connectable advertising is enabled, the
 *        Controller shall return the error code Command Disallowed (0x0C). The
 *        Host may issue this command at any other time. If this command is used
 *        to change the address, the new random address shall take effect for
 *        advertising no later than the next successful LE Extended Set
 *        Advertising Enable Command and for periodic advertising no later than
 *        the next successful LE Periodic Advertising Enable Command.
 * @param Advertising_Handle It is used to identify an advertising set
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Advertising_Random_Address Random Device Address as defined by [Vol 6]
 *        Part B, Section 1.3.2
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_advertising_set_random_address(uint8_t Advertising_Handle,
                                                     uint8_t Advertising_Random_Address[6]);
/**
 * @brief The LE_Set_Extended_Advertising_Parameters command is used by the Host
 *        to set the advertising parameters. The Advertising_Handle parameter
 *        identifies the advertising set whose parameters are being configured.
 *        The Advertising_Event_Properties parameter describes the type of
 *        advertising event that is being configured and its basic properties.
 *        The type shall be one supported by the Controller.
 * @param Advertising_Handle The Advertising_Handle parameter identifies the
 *        advertising set whose parameters are being configured.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Advertising_Event_Properties The Advertising_Event_Properties
 *        parameter describes the type of advertising event that is being
 *        configured and its basic properties. The type shall be one supported
 *        by the Controller. Bits: 0 Connectable advertising 1 Scannable
 *        advertising 2 Directed advertising 3 High Duty Cycle Directed
 *        Connectable advertising (<= 3.75 ms Advertising Interval) 4 Use legacy
 *        advertising PDUs 5 Omit advertiser's address from all PDUs ("anonymous
 *        advertising") 6 Include TxPower in the extended header of the
 *        advertising PDU
 *        Flags:
 *        - 0x0001: Connectable
 *        - 0x0002: Scannable
 *        - 0x0004: Directed
 *        - 0x0008: HDC Directed Connectable
 *        - 0x0010: Legacy
 *        - 0x0020: Anonymous
 *        - 0x0040: TxPower in ext header
 * @param Primary_Advertising_Interval_Min Minimum advertising interval for
 *        undirected and low duty cycle directed advertising. Time = N * 0.625
 *        ms; Time Range: 20 ms to 10,485.759375 s.
 *        Values:
 *        - 0x000020 (20.000 ms)  ... 0xFFFFFF (10485759.375 ms) 
 * @param Primary_Advertising_Interval_Max Maximum advertising interval for
 *        undirected and low duty cycle directed advertising. Time = N * 0.625
 *        ms; Time Range: 20 ms to 10,485.759375 s.
 *        Values:
 *        - 0x000020 (20.000 ms)  ... 0xFFFFFF (10485759.375 ms) 
 * @param Primary_Advertising_Channel_Map The Primary_Advertising_Channel_Map is
 *        a bit field that indicates the advertising channels that shall be used
 *        when transmitting advertising packets. At least one channel bit shall
 *        be set in the Primary_Advertising_Channel_Map parameter.
 *        Flags:
 *        - 0x01: CH_37
 *        - 0x02: CH_38
 *        - 0x04: CH_39
 * @param Own_Address_Type The Own_Address_Type parameter specifies the type of
 *        address being used in the advertising packets. For random addresses,
 *        the address is specified by the LE_Set_Advertising_Set_Random_Address
 *        command.  0x00 Public Device Address 0x01 Random Device Address 0x02
 *        Controller generates the Resolvable Private Address based on the local
 *        IRK from the resolving list. If the resolving list contains no
 *        matching entry, use the public address. 0x03 Controller generates the
 *        Resolvable Private Address based on the local IRK from the resolving
 *        list. If the resolving list contains no matching entry, use the random
 *        address from LE_Set_Advertising_Set_Random_Address. All other values
 *        Reserved for future use
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Resolvable Private Address / Public Address
 *        - 0x03: Resolvable Private Address / Random Address
 * @param Peer_Address_Type Peer Address type
 *        Values:
 *        - 0x00: Public Device Address or Public Identity Address
 *        - 0x01: Random Device Address or Random (static) Identity Address
 * @param Peer_Address Public Device Address, Random Device Address, Public
 *        Identity Address, or Random (static) Identity Address of the device to
 *        be connected.
 * @param Advertising_Filter_Policy Advertising Filter Policy. This parameter is
 *        ignored when directed advertising is enabled.  0x00 Process scan and
 *        connection requests from all devices (i.e., the Filter Accept List is
 *        not in use) 0x01 Process connection requests from all devices and scan
 *        requests only from devices that are in the Filter Accept List 0x02
 *        Process scan requests from all devices and connection requests only
 *        from devices that are in the Filter Accept List. 0x03 Process scan and
 *        connection requests only from devices in the Filter Accept List. All
 *        other values are reserved for future use
 *        Values:
 *        - 0x00: HCI_ADV_FILTER_NONE
 *        - 0x01: HCI_ADV_FILTER_ACCEPT_LIST_SCAN
 *        - 0x02: HCI_ADV_FILTER_ACCEPT_LIST_CONNECT
 *        - 0x03: HCI_ADV_FILTER_ACCEPT_LIST_SCAN_CONNECT
 * @param Advertising_Tx_Power Units: dBm  The Advertising_Tx_Power parameter
 *        indicates the maximum power level at which the advertising packets are
 *        to be transmitted on the advertising channels. The Controller shall
 *        choose a power level lower than or equal to the one specified by the
 *        Host.
 *        Values:
 *        - -127 ... 126
 *        - 127: No preference
 * @param Primary_Advertising_PHY The Primary_Advertising_PHY parameter
 *        indicates the PHY on which the advertising packets are transmitted on
 *        the primary advertising channel. If legacy advertising PDUs are being
 *        used, the Primary_Advertising_PHY shall indicate the LE 1M PHY.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x03: LE_CODED_PHY
 * @param Secondary_Advertising_Max_Skip The Secondary_Advertising_Max_Skip
 *        parameter is the maximum number of advertising events that can be
 *        skipped before the AUX_ADV_IND can be sent. 0x00 AUX_ADV_IND shall be
 *        sent prior to the next advertising event 0x01-0xFF Maximum advertising
 *        events the Controller can skip before sending the AUX_ADV_IND packets
 *        on the secondary advertising channel
 *        Values:
 *        - 0x00 ... 0xFF
 * @param Secondary_Advertising_PHY The Secondary_Advertising_PHY parameter
 *        indicates the PHY on which the advertising packets are transmitted on
 *        the secondary advertising channel.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY
 * @param Advertising_SID The Advertising_SID parameter specifies the value to
 *        be transmitted in the Advertising SID subfield of the ADI field of the
 *        Extended Header of those advertising channel PDUs that have an ADI
 *        field. If the advertising set only uses PDUs that do not contain an
 *        ADI field, Advertising_SID is ignored.
 *        Values:
 *        - 0x00 ... 0x0F
 * @param Scan_Request_Notification_Enable The Scan_Request_Notification_Enable
 *        parameter indicates whether the Controller shall send notifications
 *        upon the receipt of a scan request PDU that is in response to an
 *        advertisement from the specified advertising set that contains its
 *        device address and is from a scanner that is allowed by the
 *        advertising filter policy.
 *        Values:
 *        - 0x00: Scan request notifications disabled
 *        - 0x01: Scan request notifications enabled
 * @param[out] Selected_Tx_Power Units: dBm. The Selected_Tx_Power return
 *             parameter indicates the transmit power selected by the
 *             Controller. The Controller shall not change the transmit power
 *             for this advertising set without being directed to by the Host.
 *             Values:
 *             - -127 ... 126
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_extended_advertising_parameters(uint8_t Advertising_Handle,
                                                      uint16_t Advertising_Event_Properties,
                                                      uint8_t Primary_Advertising_Interval_Min[3],
                                                      uint8_t Primary_Advertising_Interval_Max[3],
                                                      uint8_t Primary_Advertising_Channel_Map,
                                                      uint8_t Own_Address_Type,
                                                      uint8_t Peer_Address_Type,
                                                      uint8_t Peer_Address[6],
                                                      uint8_t Advertising_Filter_Policy,
                                                      int8_t Advertising_Tx_Power,
                                                      uint8_t Primary_Advertising_PHY,
                                                      uint8_t Secondary_Advertising_Max_Skip,
                                                      uint8_t Secondary_Advertising_PHY,
                                                      uint8_t Advertising_SID,
                                                      uint8_t Scan_Request_Notification_Enable,
                                                      int8_t *Selected_Tx_Power);
/**
 * @brief The LE_Set_Extended_Advertising_Enable command is used to request the
 *        Controller to enable or disable one or more advertising sets using the
 *        advertising sets identified by the Advertising_Handle[i] parameter.
 *        The Controller manages the timing of advertisements in accordance with
 *        the advertising parameters given in the
 *        LE_Set_Extended_Advertising_Parameters command.
 * @param Enable It allows to enable or disable one or more advertising sets
 *        using the advertising sets identified by the Advertising_Handle[i]
 *        parameter.
 *        Values:
 *        - 0x00: Disable
 *        - 0x01: Enable
 * @param Number_of_Sets The Number_of_Sets parameter is the number of
 *        advertising sets contained in the parameter arrays.
 *        Values:
 *        - 0x00: Disable all advertising sets
 *        - 0x01 ... 0x3F: Number of advertising sets to enable or disable
 * @param Advertising_Set_Parameters See @ref Advertising_Set_Parameters_t
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_extended_advertising_enable(uint8_t Enable,
                                                  uint8_t Number_of_Sets,
                                                  Advertising_Set_Parameters_t Advertising_Set_Parameters[]);
/**
 * @brief The LE_Read_Number_of_Supported_Advertising_Sets command is used to
 *        read the maximum number of advertising sets supported by the
 *        advertising Controller at the same time. Note: The number of
 *        advertising sets that can be supported is not fixed and the Controller
 *        can change it at any time because the memory used to store advertising
 *        sets can also be used for other purposes.
 * @param[out] Num_Supported_Advertising_Sets Maximum number of advertising sets
 *             supported by the advertising Controller at the same time.
 *             Values:
 *             - 0x01 ... 0xF0: Number of advertising sets supported at the same time
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_number_of_supported_advertising_sets(uint8_t *Num_Supported_Advertising_Sets);
/**
 * @brief The LE_Remove_Advertising_Set command is used to remove an advertising
 *        set from the Controller. If the advertising set corresponding to the
 *        Advertising_Handle parameter does not exist, then the Controller shall
 *        return the error code Unknown Advertising Identifier (0x42). If
 *        advertising on the advertising set is enabled, then the Controller
 *        shall return the error code Command Disallowed (0x0C).
 * @param Advertising_Handle It is used to identify an advertising set
 *        Values:
 *        - 0x00 ... 0xEF: Used to identify an advertising set
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_remove_advertising_set(uint8_t Advertising_Handle);
/**
 * @brief The LE_Clear_Advertising_Sets command is used to remove all existing
 *        advertising sets from the Controller. If advertising is enabled on any
 *        advertising set, then the Controller shall return the error code
 *        Command Disallowed (0x0C). Note: All advertising sets are cleared on
 *        HCI reset.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_clear_advertising_sets(void);
/**
 * @brief The LE_Set_Periodic_Advertising_Parameters command is used by the Host
 *        to set the parameters for periodic advertising. The Advertising_Handle
 *        parameter identifies the advertising set whose periodic advertising
 *        parameters are being configured. If the corresponding advertising set
 *        does not already exist, then the Controller shall return the error
 *        code Unknown Advertising Identifier (0x42). The
 *        Periodic_Advertising_Interval_Min parameter shall be less than or
 *        equal to the Periodic_Advertising_Interval_Max parameter. The
 *        Periodic_Advertising_Interval_Min and
 *        Periodic_Advertising_Interval_Max parameters should not be the same
 *        value to enable the Controller to determine the best advertising
 *        interval given other activities. The Periodic_Advertising_Properties
 *        parameter indicates which fields should be included in the advertising
 *        packet. If the advertising set identified by the Advertising_Handle
 *        specified anonymous advertising, the Controller shall return the error
 *        code Invalid HCI Parameters (0x12). If the Host issues this command
 *        when periodic advertising is enabled for the specified advertising
 *        set, the Controller shall return the error code Command Disallowed
 *        (0x0C). If the Advertising_Handle does not identify an advertising set
 *        that is already configured for periodic advertising and the Controller
 *        is unable to support more periodic advertising at present, the
 *        Controller shall return the error code Memory Capacity Exceeded (0x07)
 * @param Advertising_Handle It is used to identify an advertising set
 *        Values:
 *        - 0x00 ... 0xEF: Used to identify a periodic advertisement
 * @param Periodic_Advertising_Interval_Min Minimum advertising interval for
 *        periodic advertising. Time = N * 1.25 ms; Time Range: 7.5ms to
 *        81.91875 s.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 * @param Periodic_Advertising_Interval_Max Maximum advertising interval for
 *        periodic advertising. Time = N * 1.25 ms; Time Range: 7.5ms to
 *        81.91875 s.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 * @param Periodic_Advertising_Properties The Periodic_Advertising_Properties
 *        parameter indicates which fields should be included in the advertising
 *        packet.
 *        Flags:
 *        - 0x0040: Include TxPower in the advertising PDU
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_periodic_advertising_parameters(uint8_t Advertising_Handle,
                                                      uint16_t Periodic_Advertising_Interval_Min,
                                                      uint16_t Periodic_Advertising_Interval_Max,
                                                      uint16_t Periodic_Advertising_Properties);
/**
 * @brief The HCI_LE_Set_Periodic_Advertising_Enable command is used to request
 *        the Controller to enable or disable the periodic advertising for the
 *        advertising set specified by the Advertising_Handle parameter
 *        (ordinary advertising is not affected). If the advertising set is not
 *        currently enabled (see the HCI_LE_Set_Extended_Advertising_Enable
 *        command), the periodic advertising is not started until the
 *        advertising set is enabled. Once the advertising set has been enabled,
 *        the Controller shall continue periodic advertising until the Host
 *        issues an HCI_LE_Set_Periodic_Advertising_Enable command with bit 0 of
 *        Enable set to 0 (periodic advertising is disabled). Disabling the
 *        advertising set has no effect on the periodic advertising once the
 *        advertising set has been enabled. The Controller manages the timing of
 *        advertisements in accordance with the advertising parameters given in
 *        the HCI_LE_Set_Periodic_Advertising_Parameters command. If the
 *        advertising set corresponding to the Advertising_Handle parameter does
 *        not exist, the Controller shall return the error code Unknown
 *        Advertising Identifier (0x42). If bit 0 of Enable is set to 1
 *        (periodic advertising is enabled) and the advertising set contains
 *        partial periodic advertising data, the Controller shall return the
 *        error code Command Disallowed (0x0C). If bit 0 of Enable is set to 1
 *        and the Host has not issued the
 *        HCI_LE_Set_Periodic_Advertising_Parameters command for the advertising
 *        set, the Controller shall either use vendor-specified parameters or
 *        return the error code Command Disallowed (0x0C). If bit 0 of Enable is
 *        set to 1 and the length of the periodic advertising data is greater
 *        than the maximum that the Controller can transmit within the chosen
 *        periodic advertising interval, the Controller shall return the error
 *        code Packet Too Long (0x45). If advertising on the LE Coded PHY, the
 *        S=8 coding shall be assumed. If bit 0 of Enable is set to 1 and the
 *        advertising set identified by the Advertising_Handle specified
 *        scannable, connectable, legacy, or anonymous (0x0C). If bit 0 of
 *        Enable is set to 0 and the Controller supports the Periodic
 *        Advertising ADI Support feature, then the Controller shall ignore bit
 *        1. If bit 1 of Enable is set to 1 and the Controller does not support
 *        the Periodic Advertising ADI Support feature, the Controller shall
 *        return an error which should use the error code Unsupported Feature or
 *        Parameter Value (0x11). Enabling periodic advertising when it is
 *        already enabled can cause the random address to change. Disabling
 *        periodic advertising when it is already disabled has no effect.
 * @param Enable It is used to enabled advertising and include ADI field. If bit
 *        0 is set, enable periodic advertising. if bit 1 is set, Include the
 *        ADI field in AUX_SYNC_IND PDUs.
 *        Flags:
 *        - 0x01: ENABLE_PERIODIC_ADV
 *        - 0x02: INCLUDE_ADI_FIELD
 * @param Advertising_Handle Used to identify an advertising set.
 *        Values:
 *        - 0x00 ... 0xEF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_periodic_advertising_enable(uint8_t Enable,
                                                  uint8_t Advertising_Handle);
/**
 * @brief The LE_Set_Extended_Scan_Parameters command is used to set the
 *        extended scan parameters to be used on the advertising channels. The
 *        Scanning_PHYs parameter indicates the PHY(s) on which the advertising
 *        packets should be received on the primary advertising channel. The
 *        Host may enable one or more scanning PHYs. The Scan_Type[i],
 *        Scan_Interval[i], and Scan_Window[i] parameters array elements are
 *        ordered in the same order as the set bits in the Scanning_PHY
 *        parameter, starting from bit 0. The number of array elements is
 *        determined by the number of bits set in the Scanning_PHY parameter.
 *        The Scan_Type[i] parameter specifies the type of scan to perform. The
 *        Scan_Interval[i] and Scan_Window[i] parameters are recommendations
 *        from the Host on how long (Scan_Window[i]) and how frequently
 *        (Scan_Interval[i]) the Controller should scan (see [Vol 6] Part B,
 *        Section 4.5.3); however the frequency and length of the scan is
 *        implementation specific. If the requested scan cannot be supported by
 *        the implementation, the Controller shall return the error code Invalid
 *        HCI Command Parameters (0x12). The Own_Address_Type parameter
 *        indicates the type of address being used in the scan request packets.
 *        If the Host issues this command when scanning is enabled in the
 *        Controller, the Controller shall return the error code Command
 *        Disallowed (0x0C).
 * @param Own_Address_Type The Own_Address_Type parameter indicates the type of
 *        address being used in the scan request packets.
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the public address.
 *        - 0x03: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the random address from LE_Set_Random_Address.
 * @param Scanning_Filter_Policy 0x00 Accept all advertisement packets. Directed
 *        advertising packets which are not addressed for this device shall be
 *        ignored. 0x01 Ignore advertisement packets from devices not in the
 *        Filter Accept List Only. Directed advertising packets which are not
 *        addressed for this device shall be ignored 0x02 Accept all undirected
 *        advertisement packets. Directed advertisement packets where initiator
 *        address is a RPA and  Directed advertisement packets addressed to this
 *        device shall be accepted. 0x03 Accept all undirected advertisement
 *        packets from devices that are in the Filter Accept List.Directed
 *        advertisement packets where initiator address is RPA and Directed
 *        advertisement packets addressed to this device shall be accepted.
 *        Values:
 *        - 0x00: Accept all
 *        - 0x01: Ignore devices not in the Filter Accept List
 *        - 0x02: Accept all (use resolving list)
 *        - 0x03: Ignore devices not in the Filter Accept List (use resolving list)
 * @param Scanning_PHYs The Scanning_PHYs parameter indicates the PHY(s) on
 *        which the advertising packets should be received on the primary
 *        advertising channel. The Host may enable one or more scanning PHYs.
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param Extended_Scan_Parameters See @ref Extended_Scan_Parameters_t
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_extended_scan_parameters(uint8_t Own_Address_Type,
                                               uint8_t Scanning_Filter_Policy,
                                               uint8_t Scanning_PHYs,
                                               Extended_Scan_Parameters_t Extended_Scan_Parameters[]);
/**
 * @brief The LE_Set_Extended_Scan_Enable command is used to enable or disable
 *        scanning. The Enable parameter determines whether scanning is enabled
 *        or disabled. If it is disabled, the remaining parameters are ignored.
 *        The Filter_Duplicates parameter controls whether the Link Layer should
 *        filter out duplicate advertising reports (filtering duplicates
 *        enabled) to the Host or if the Link Layer should generate advertising
 *        reports for each packet received (filtering duplicates disabled). See
 *        [Vol 6] Part B, Section 4.4.3.5. If the Filter_Duplicates parameter is
 *        set to 0x00, all advertisements received from advertisers shall be
 *        sent to the Host in advertising report events. If the
 *        Filter_Duplicates parameter is set to 0x01, duplicate advertisements
 *        should not be sent to the Host in advertising report events until
 *        scanning is disabled. If the Filter_Duplicates parameter is set to
 *        0x02, duplicate advertisements in a single scan period should not be
 *        sent to the Host in advertising report events; this setting shall only
 *        be used if Period is non-zero. If Filter_Duplicates is set to 0x2 and
 *        Period to zero, the Controller shall return the Invalid error code HCI
 *        Command Parameters (0x12). If the Duration parameter is zero or both
 *        the Duration parameter and Period parameter are non-zero, the
 *        Controller shall continue scanning until scanning is disabled by the
 *        Host issuing an LE_Set_Extended_Scan_Enable command with the Enable
 *        parameter set to 0x00 (Scanning is disabled). The Period parameter is
 *        ignored when the Duration parameter is zero. If the Duration parameter
 *        is non-zero and the Period parameter is zero, the Controller shall
 *        continue scanning until the duration specified in the Duration
 *        parameter has expired. If both the Duration and Period parameters are
 *        non-zero and the Duration parameter is greater than or equal to the
 *        Period parameter, the Controller shall return the error code Invalid
 *        HCI Command Parameters (0x12). When the Duration and Period parameters
 *        are non-zero, the Controller shall scan for the duration of the
 *        Duration parameter within a scan period specified by the Period
 *        parameter. After the scan period has expired, a new scan period shall
 *        begin and scanning shall begin again for the duration specified. The
 *        scan periods continue until the Host disables scanning. If the
 *        LE_Set_Extended_Scan_Enable command is sent while scanning is enabled,
 *        the timers used for duration and period are reset to the new parameter
 *        values and a new scan period is started. Any change to the
 *        Filter_Duplicates setting or the random address shall take effect.
 *        Note: Disabling scanning when it is disabled has no effect. Note: The
 *        duration of a scan period refers to the time spent scanning on both
 *        the primary and secondary advertising channels. However, expiry of the
 *        duration does not prevent the Link Layer from scanning for and
 *        receiving auxiliary packets of received advertisements. If the
 *        scanning parameters' Own_Address_Type parameter is set to 0x01 or 0x03
 *        and the random address for the device has not been initialized, the
 *        Controller shall return the error code Invalid HCI Command Parameters
 *        (0x12).
 * @param Enable The Enable parameter determines whether scanning is enabled or
 *        disabled. If it is disabled, the remaining parameters are ignored.
 *        Values:
 *        - 0x00: Scanning disabled
 *        - 0x01: Scanning enabled
 * @param Filter_Duplicates The Filter_Duplicates parameter controls whether the
 *        Link Layer should filter out duplicate advertising reports (filtering
 *        duplicates enabled) to the Host or if the Link Layer should generate
 *        advertising reports for each packet received (filtering duplicates
 *        disabled). See [Vol 6] Part B, Section 4.4.3.5.
 *        Values:
 *        - 0x00: Duplicate filtering disabled
 *        - 0x01: Duplicate filtering enabled
 *        - 0x02: Duplicate filtering enabled, reset for each scan period
 * @param Duration Scan duration. Time = N * 10 ms; Time Range: 10 ms to 655.35
 *        s.
 *        Values:
 *        - 0x0000 (0.000 ms) : Scan continuously until explicitly disable
 *        - 0x0001 (0.625 ms)  ... 0xFFFF (40959.375 ms) : Scan duration
 * @param Period Time interval from when the Controller started its last
 *        Scan_Duration until it begins the subsequent Scan_Duration. Time = N *
 *        1.28 sec; Time Range: 1.28 s to 83,884.8 s.
 *        Values:
 *        - 0x0000: Periodic scanning disabled
 *        - 0x0001 ... 0xFFFF: Time interval from when the Controller started its last Scan_Duration
until it begins the subsequent Scan_Duration
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_extended_scan_enable(uint8_t Enable,
                                           uint8_t Filter_Duplicates,
                                           uint16_t Duration,
                                           uint16_t Period);
/**
 * @brief The LE_Extended_Create_Connection command is used to create a Link
 *        Layer connection to a connectable advertiser.
 *        LE_Extended_Create_Connection command can be used in place of
 *        LE_Create_Connection command.
 * @param Initiator_Filter_Policy The Initiator_Filter_Policy parameter is used
 *        to determine whether the Filter Accept List is used. If the Filter
 *        Accept List is not used, the Peer_Address_Type and the Peer_Address
 *        parameters specify the address type and address of the advertising
 *        device to connect to. 0x00 - Filter Accept List is not used to
 *        determine which advertiser to connect to. Peer_Address_Type and
 *        Peer_Address shall be used. 0x01 - Filter Accept List is used to
 *        determine which advertiser to connect to. Peer_Address_Type and
 *        Peer_Address shall be ignored.
 *        Values:
 *        - 0x00: FILTER_ACCEPT_LIST_NOT_USED
 *        - 0x01: FILTER_ACCEPT_LIST_USED
 * @param Own_Address_Type The Own_Address_Type parameter indicates the type of
 *        address being used in the connection request packets.
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the public address.
 *        - 0x03: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the random address from the most recent successful
LE_Set_Random_Address Command.
 * @param Peer_Address_Type The Peer_Address_Type parameter indicates the type
 *        of address used in the connectable advertisement sent by the peer.
 *        0x00: Public Device Address or Public Identity Address 0x01: Random
 *        Device Address or Random (static) Identity Address
 *        Values:
 *        - 0x00: Public Address
 *        - 0x01: Random Address
 * @param Peer_Address Public Device Address, Random Device Address, Public
 *        Identity Address, or Random (static) Identity Address of the device to
 *        be connected.
 * @param Initiating_PHYs The Initiating_PHYs parameter indicates the PHY(s) on
 *        which the advertising packets should be received on the primary
 *        advertising channel and the PHYs for which connection parameters have
 *        been specified. The Host may enable one or more initiating PHYs. 0x01:
 *        Scan connectable advertisements on the LE 1M PHY. Connection
 *        parameters for the LE 1M PHY are provided. 0x02: Connection parameters
 *        for the LE 2M PHY are provided 0x04: Scan connectable advertisements
 *        on the LE Coded PHY. Connection parameters for the LE Coded PHY are
 *        provided.
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x02: LE_2M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param Extended_Create_Connection_Parameters See @ref
 *        Extended_Create_Connection_Parameters_t
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_extended_create_connection(uint8_t Initiator_Filter_Policy,
                                             uint8_t Own_Address_Type,
                                             uint8_t Peer_Address_Type,
                                             uint8_t Peer_Address[6],
                                             uint8_t Initiating_PHYs,
                                             Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[]);
/**
 * @brief The HCI_LE_Periodic_Advertising_Create_Sync command is used to
 *        synchronize with a periodic advertising train from an advertiser and
 *        begin receiving periodic advertising packets. This command may be
 *        issued whether or not scanning is enabled and scanning may be enabled
 *        and disabled (see the LE Set Extended Scan Enable command) while this
 *        command is pending. However, synchronization can only occur when
 *        scanning is enabled. While scanning is disabled, no attempt to
 *        synchronize will take place. The Options parameter is used to
 *        determine whether the Periodic Advertiser List is used, whether
 *        HCI_LE_Periodic_Advertising_Report events for this periodic
 *        advertising train are initially enabled or disabled, and whether
 *        duplicate reports are filtered or not. If the Periodic Advertiser List
 *        is not used, the Advertising_SID, Advertiser Address_Type, and
 *        Advertiser Address parameters specify the periodic advertising device
 *        to listen to; otherwise they shall be ignored. The Advertising_SID
 *        parameter, if used, specifies the value that must match the
 *        Advertising SID subfield in the ADI field of the received
 *        advertisement for it to be used to synchronize. The Skip parameter
 *        specifies the maximum number of consecutive periodic advertising
 *        events that the receiver may skip after successfully receiving a
 *        periodic advertising packet. The Sync_Timeout parameter specifies the
 *        maximum permitted time between successful receives. If this time is
 *        exceeded, synchronization is lost. The Sync_CTE_Type parameter
 *        specifies whether to only synchronize to periodic advertising with
 *        certain types of Constant Tone Extension (a value of 0 indicates that
 *        the presence or absence of a Constant Tone Extension is irrelevant).
 *        If the periodic advertising has the wrong type of Constant Tone
 *        Extension then: - If bit 0 of Options is set, the Controller shall
 *        ignore this address and SID and continue to search for other periodic
 *        advertisements. - Otherwise, the Controller shall cancel the
 *        synchronization with the error code Unsupported Remote Feature (0x1A).
 *        If the periodic advertiser changes the type of Constant Tone Extension
 *        after the scanner has synchronized with the periodic advertising, the
 *        scanner's Link Layer shall remain synchronized. If the Host sets all
 *        the non-reserved bits of the Sync_CTE_Type parameter to 1, the
 *        Controller shall return the error code Command Disallowed (0x0C).
 *        Irrespective of the value of the Skip parameter, the Controller should
 *        stop skipping packets before the Sync_Timeout would be exceeded. If
 *        the Host issues this command when another
 *        HCI_LE_Periodic_Advertising_- Create_Sync command is pending, the
 *        Controller shall return the error code Command Disallowed (0x0C). If
 *        the Host issues this command with bit 0 of Options not set and with
 *        Advertising_SID, Advertiser_Address_Type, and Advertiser_Address the
 *        same as those of a periodic advertising train that the Controller is
 *        already synchronized to, the Controller shall return the error code
 *        Connection Already Exists (0x0B). If the Host issues this command and
 *        the Controller has insufficient resources to handle any more periodic
 *        advertising trains, the Controller shall return the error code Memory
 *        Capacity Exceeded (0x07). If bit 1 of Options is set to 1 and the
 *        Controller supports the Periodic Advertising ADI Support feature, then
 *        the Controller shall ignore bit 2. If bit 1 of Options is set to 0,
 *        bit 2 is set to 1, and the Controller does not support the Periodic
 *        Advertising ADI Support feature, then the Controller shall return an
 *        error which should use the error code Unsupported Feature or Parameter
 *        Value (0x11). If bit 1 of the Options parameter is set to 1 and the
 *        Controller does not support the
 *        HCI_LE_Set_Periodic_Advertising_Receive_Enable command, the Controller
 *        shall return the error code Connection Failed to be Established /
 *        Synchronization Timeout (0x3E).
 * @param Options The Options parameter is a bitmask used to determine whether
 *        the Periodic Advertiser List is used, whether
 *        HCI_LE_Periodic_Advertising_Report events for this periodic
 *        advertising train are initially enabled or disabled, and whether
 *        duplicate reports are filtered or not. If bit 0 is 0: use the
 *        Advertising_SID, Advertiser_Address_Type, and Advertiser_Address
 *        parameters to determine which advertiser to listen to. If bit 0 is 1:
 *        use the Periodic Advertiser List to determine which advertiser to
 *        listen to. If bit 1 is 0, reporting is initially enabled, otherwise it
 *        is enabled. If bit 2 is 0, duplicate filtering is initially disabled,
 *        otherwise it is enabled.
 *        Flags:
 *        - 0x01: USE_PERIODIC_ADV_LIST
 *        - 0x02: DISABLE_REPORTING
 *        - 0x04: ENABLE_DUPLICATE_FILTERING
 * @param Advertising_SID The Advertising_SID parameter, if used, specifies the
 *        value that must match the Advertising SID subfield in the ADI field of
 *        the received advertisement for it to be used to synchronize.
 *        Values:
 *        - 0x00 ... 0x0F: Advertising SID subfield in the ADI field used to identify the Periodic
Advertising
 * @param Advertiser_Address_Type Advertising address type
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 * @param Advertiser_Address Public Device Address, Random Device Address,
 *        Public Identity Address, or Random (static) Identity Address of the
 *        advertiser
 * @param Skip The Skip parameter specifies the number of consecutive periodic
 *        advertising packets that the receiver may skip after successfully
 *        receiving a periodic advertising packet.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Sync_Timeout Synchronization timeout for the periodic advertising
 *        train. Time = N*10 ms.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x4000 (163840 ms) 
 * @param Sync_CTE_Type The Sync_CTE_Type parameter specifies whether to only
 *        synchronize to periodic advertising with certain types of Constant
 *        Tone Extension (a value of 0 indicates that the presence or absence of
 *        a Constant Tone Extension is irrelevant). If the periodic advertising
 *        has the wrong type of Constant Tone Extension then: - If bit 0 of
 *        Options is set, the Controller shall ignore this address and SID and
 *        continue to search for other periodic advertisements. - Otherwise, the
 *        Controller shall cancel the synchronization with the error code
 *        Unsupported Remote Feature/Unsupported LMP Feature (0x1A).
 *        Flags:
 *        - 0x01: Do not sync to packets with an AoA Constant Tone Extension
 *        - 0x02: Do not sync to packets with an AoD Constant Tone Extension with 1 microsecondslots
 *        - 0x04: Do not sync to packets with an AoD Constant Tone Extension with 2 microsecondsslots
 *        - 0x08: Do not sync to packets with a type 3 Constant Tone Extension (currentlyreserved for future use)
 *        - 0x10: Do not sync to packets without a Constant Tone Extension
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_periodic_advertising_create_sync(uint8_t Options,
                                                   uint8_t Advertising_SID,
                                                   uint8_t Advertiser_Address_Type,
                                                   uint8_t Advertiser_Address[6],
                                                   uint16_t Skip,
                                                   uint16_t Sync_Timeout,
                                                   uint8_t Sync_CTE_Type);
/**
 * @brief The LE_Periodic_Advertising_Create_Sync_Cancel command is used to
 *        cancel the LE_Periodic_Advertising_Create_Sync command while it is
 *        pending. If the Host issues this command while no
 *        LE_Periodic_Advertising_Create_Sync command is pending, the Controller
 *        shall return the error code Command Disallowed (0x0C).
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_periodic_advertising_create_sync_cancel(void);
/**
 * @brief The LE_Periodic_Advertising_Terminate_Sync command is used to stop
 *        reception of the periodic advertising identified by the Sync_Handle
 *        parameter. If the Host issues this command when another
 *        LE_Periodic_Advertising_Create_Sync command is pending (see below),
 *        the Controller shall return the error code Command Disallowed (0x0C).
 *        If the periodic advertising corresponding to the Sync_Handle parameter
 *        does not exist, then the Controller shall return the error code
 *        Unknown Advertising Identifier (0x42).
 * @param Sync_Handle It is used to identify the periodic advertiser
 *        Values:
 *        - 0x0000 ... 0x0EFF: Sync_Handle to be used to identify the periodic advertiser
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_periodic_advertising_terminate_sync(uint16_t Sync_Handle);
/**
 * @brief The LE_Add_Device_To_Periodic_Advertiser_List command is used to add a
 *        single device to the Periodic Advertiser list stored in the
 *        Controller. Any additions to the Periodic Advertiser list take effect
 *        immediately. If the device is already on the list, the Controller
 *        shall return the error code Invalid HCI Command Parameters (0x12). If
 *        the Host issues this command when an
 *        LE_Periodic_Advertising_Create_Sync command is pending, the Controller
 *        shall return the error code Command Disallowed (0x0C). When a
 *        Controller cannot add a device to the Periodic Advertiser list because
 *        the list is full, the Controller shall return the error code Memory
 *        Capacity Exceeded (0x07).
 * @param Advertiser_Address_Type Advertiser Address Type
 *        Values:
 *        - 0x00: Public Device Address or Public Identity Address
 *        - 0x01: Random Device Address or Random (static) Identity Address
 * @param Advertiser_Address Public Device Address, Random Device Address,
 *        Public Identity Address, or Random (static) Identity Address of the
 *        advertiser
 * @param Advertising_SID Advertising SID subfield in the ADI field used to
 *        identify the Periodic Advertising
 *        Values:
 *        - 0x00 ... 0x0F: Advertising SID subfield in the ADI field used to identify the Periodic
Advertising
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_add_device_to_periodic_advertiser_list(uint8_t Advertiser_Address_Type,
                                                         uint8_t Advertiser_Address[6],
                                                         uint8_t Advertising_SID);
/**
 * @brief The LE_Remove_Device_From_Periodic_Advertiser_List command is used to
 *        remove one device from the list of Periodic Advertisers stored in the
 *        Controller. Removals from the Periodic Advertisers List take effect
 *        immediately. If the Host issues this command when an
 *        LE_Periodic_Advertising_Create_Sync command is pending, the Controller
 *        shall return the error code Command Disallowed (0x0C). When a
 *        Controller cannot remove a device from the Periodic Advertiser list
 *        because it is not found, the Controller shall return the error code
 *        Unknown Advertising Identifier (0x42).
 * @param Advertiser_Address_Type Advertising Address type
 *        Values:
 *        - 0x00: Public Device Address or Public Identity Address
 *        - 0x01: Random Device Address or Random (static) Identity Address
 * @param Advertiser_Address Public Device Address, Random Device Address,
 *        Public Identity Address, or Random (static) Identity Address of the
 *        advertiser
 * @param Advertising_SID It is used to  identify the Periodic Advertising
 *        Values:
 *        - 0x00 ... 0x0F: Advertising SID subfield in the ADI field used to identify the Periodic
Advertising
All other values Reserved for future
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_remove_device_from_periodic_advertiser_list(uint8_t Advertiser_Address_Type,
                                                              uint8_t Advertiser_Address[6],
                                                              uint8_t Advertising_SID);
/**
 * @brief The LE_Clear_Periodic_Advertiser_List command is used to remove all
 *        devices from the list of Periodic Advertisers in the Controller. If
 *        this command is used when an LE_Periodic_Advertising_Create_Sync
 *        command is pending, the Controller shall return the error code Command
 *        Disallowed (0x0C).
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_clear_periodic_advertiser_list(void);
/**
 * @brief The LE_Read_Periodic_Advertiser_List_Size command is used to read the
 *        total number of Periodic Advertiser list entries that can be stored in
 *        the Controller. Note: The number of entries that can be stored is not
 *        fixed and the Controller can change it at any time (e.g., because the
 *        memory used to store the list can also be used for other purposes).
 * @param[out] Periodic_Advertiser_List_Size Total number of Periodic Advertiser
 *             list entries that can be stored in the Controller
 *             Values:
 *             - 0x1F ... 0xFF: Total number of Periodic Advertiser list entries that can be stored in the
Controller
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_periodic_advertiser_list_size(uint8_t *Periodic_Advertiser_List_Size);
/**
 * @brief The HCI_LE_Read_Transmit_Power command is used to read the minimum and
 *        maximum transmit powers supported by the Controller.
 * @param[out] Min_Tx_Power Minimum supported TX power (units: dBm).
 *             Values:
 *             - -127 ... 20
 * @param[out] Max_Tx_Power Maximum supported TX power (units: dBm).
 *             Values:
 *             - -127 ... 20
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_transmit_power(int8_t *Min_Tx_Power,
                                      int8_t *Max_Tx_Power);
/**
 * @brief The HCI_LE_Read_RF_Path_Compensation command is used to read the RF
 *        Path Compensation Values parameter used in the Tx Power Level and RSSI
 *        calculation.
 * @param[out] RF_TX_Path_Compensation_Value
 * @param[out] RF_RX_Path_Compensation_Value
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_rf_path_compensation(int16_t *RF_TX_Path_Compensation_Value,
                                            int16_t *RF_RX_Path_Compensation_Value);
/**
 * @brief The HCI_LE_Write_RF_Path_Compensation command is used to indicate the
 *        RF path gain or loss between the RF transceiver and the antenna
 *        contributed by intermediate components. A positive value means a net
 *        RF path gain and a negative value means a net RF path loss. The RF Tx
 *        Path Compensation Value parameter shall be used by the Controller to
 *        calculate radiative Tx Power Level used in HCI commands, HCI events,
 *        Advertising physical channel PDUs, and Link Layer Control PDUs using
 *        the following equation: Radiative Tx Power Level = Tx Power Level at
 *        RF transceiver output + RF Tx Path Compensation Value. For example, if
 *        the Tx Power Level is +4 (dBm) at RF transceiver output and the RF
 *        Path Compensation Value is -1.5 (dB), the radiative Tx Power Level is
 *        +4+(-1.5) = 2.5 (dBm). The RF Rx Path Compensation Value parameter
 *        shall be used by the Controller to calculate the RSSI value reported
 *        to the Host.
 * @param RF_TX_Path_Compensation_Value
 * @param RF_RX_Path_Compensation_Value
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_write_rf_path_compensation(int16_t RF_TX_Path_Compensation_Value,
                                             int16_t RF_RX_Path_Compensation_Value);
/**
 * @brief The HCI_LE_Set_Privacy_Mode command is used to allow the Host to
 *        specify the privacy mode to be used for a given entry on the resolving
 *        list. The effect of this setting is specified in [Vol 6] Part B,
 *        Section 4.7. When an entry on the resolving list is removed, the mode
 *        associated with that entry shall also be removed. This command cannot
 *        be used when address translation is enabled in the Controller and:
 *        Advertising is enabled Scanning is enabled Create connection command
 *        is outstanding This command can be used at any time when address
 *        translation is disabled in the Controller. If the device is not on the
 *        resolving list, the Controller shall return the error code Unknown
 *        Connection Identifier (0x02).
 * @param Peer_Identity_Address_Type Peer Address type
 *        Values:
 *        - 0x00: Public Identity Address
 *        - 0x01: Random (static) Identity Address
 * @param Peer_Identity_Address Public Identity Address or Random (static)
 *        Identity Address of the advertiser
 * @param Privacy_Mode 0x00 Use Network Privacy Mode for this peer device
 *        (default) 0x01 Use Device Privacy Mode for this peer device
 *        Values:
 *        - 0x00: Network Privacy Mode
 *        - 0x01: Device Privacy Mode
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_privacy_mode(uint8_t Peer_Identity_Address_Type,
                                   uint8_t Peer_Identity_Address[6],
                                   uint8_t Privacy_Mode);
/**
 * @brief The HCI_LE_Set_Connectionless_CTE_Transmit_Parameters command is used
 *        to set the type, length, and antenna switching pattern for the
 *        transmission of Constant Tone Extensions in any periodic advertising
 *        on the advertising set identified by the Advertising_Handle parameter.
 *        The CTE_Count parameter specifies how many packets with a Constant
 *        Tone Extension are to be transmitted in each periodic advertising
 *        event. If the number of packets that would otherwise be transmitted is
 *        less than this, the Controller shall transmit sufficient AUX_CHAIN_IND
 *        PDUs with no AdvData to make up the number. However, if a change in
 *        circumstances since this command was issued means that the Controller
 *        can no longer schedule all of these packets, it should transmit as
 *        many as possible. If the Host issues this command when Constant Tone
 *        Extensions have been enabled in the advertising set, the Controller
 *        shall return the error code Command Disallowed (0x0C). The
 *        Switching_Pattern_Length and Antenna_IDs[i] parameters are only used
 *        when transmitting an AoD Constant Tone Extension and shall be ignored
 *        if CTE_Type specifies an AoA Constant Tone Extension. If the
 *        CTE_Length parameter is greater than the maximum length of Constant
 *        Tone Extension supported, the Controller shall return the error code
 *        Unsupported Feature or Parameter Value (0x11). If the Host requests a
 *        type of Constant Tone Extension that the Controller does not support,
 *        the Controller shall return the error code Unsupported Feature or
 *        Parameter Value (0x11). If the Controller is unable to schedule
 *        CTE_Count packets in each event, the Controller shall return the error
 *        code Unsupported Feature or Parameter Value (0x11). If the advertising
 *        set corresponding to the Advertising_Handle parameter does not exist,
 *        the Controller shall return the error code Unknown Advertising
 *        Identifier (0x42). If Switching_Pattern_Length is greater than the
 *        maximum length of switching pattern supported by the Controller (see
 *        Section 7.8.87), the Controller shall return the error code
 *        Unsupported Feature or Parameter Value (0x11). If the Controller
 *        determines that any of the Antenna_IDs[i] values do not identify an
 *        antenna in the device's antenna array, it shall return the error code
 *        Unsupported Feature or Parameter Value (0x11). Note: Some Controllers
 *        may be unable to determine which values do or do not identify an
 *        antenna.
 * @param Advertising_Handle It is used to identify an advertising set
 *        Values:
 *        - 0x00 ... 0xEF
 * @param CTE_Length
 *        Values:
 *        - 0x02 ... 0x14: Constant Tone Extension length in 8 microseconds units
 * @param CTE_Type
 *        Values:
 *        - 0x00: AoA Constant Tone Extension
 *        - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 *        - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 * @param CTE_Count The CTE_Count parameter specifies how many packets with a
 *        Constant Tone Extension are to be transmitted in each periodic
 *        advertising event. If the number of packets that would otherwise be
 *        transmitted is less than this, the Controller shall transmit
 *        sufficient AUX_CHAIN_IND PDUs with no AdvData to make up the number.
 *        However, if a change in circumstances since this command was issued
 *        means that the Controller can no longer schedule all of these packets,
 *        it should transmit as many as possible.
 *        Values:
 *        - 0x01 ... 0x10: The number of Constant Tone Extensions to transmit in each periodic advertising interval
 * @param Switching_Pattern_Length
 *        Values:
 *        - 0x02 ... 0x4B: The number of Antenna IDs in the pattern.
 * @param Antenna_IDs List of Antenna IDs in the pattern
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_connectionless_cte_transmit_parameters(uint8_t Advertising_Handle,
                                                             uint8_t CTE_Length,
                                                             uint8_t CTE_Type,
                                                             uint8_t CTE_Count,
                                                             uint8_t Switching_Pattern_Length,
                                                             uint8_t Antenna_IDs[]);
/**
 * @brief The HCI_LE_Set_Connectionless_CTE_Transmit_Enable command is used to
 *        request that the Controller enables or disables the use of Constant
 *        Tone Extensions in any periodic advertising on the advertising set
 *        identified by Advertising_Handle. In order to start sending periodic
 *        advertisements containing a Constant Tone Extension, the Host must
 *        also enable periodic advertising using the
 *        HCI_LE_Set_Periodic_Advertising_Enable command (see Section 7.8.63).
 *        Note: Periodic advertising can only be enabled when advertising is
 *        enabled on the same advertising set, but can continue after
 *        advertising has been disabled. If the Host issues this command before
 *        it has issued the HCI_LE_Set_Periodic_Advertising_Parameters command
 *        (see Section 7.8.61) for the advertising set, the Controller shall
 *        return the error code Command Disallowed (0x0C). Once enabled, the
 *        Controller shall continue advertising with Constant Tone Extensions
 *        until either one of the following occurs: - The Host issues an
 *        HCI_LE_Set_Connectionless_CTE_Transmit_Enable command with CTE_Enable
 *        set to 0x00 (disabling Constant Tone Extensions but allowing periodic
 *        advertising to continue). - The Host issues an
 *        HCI_LE_Set_Periodic_Advertising_Enable command (see Section 7.8.63)
 *        with Enable set to 0x00 (disabling periodic advertising). If periodic
 *        advertising is re-enabled then it shall continue to contain Constant
 *        Tone Extensions. If the Host issues this command before it has issued
 *        the HCI_LE_Set_Connectionless_CTE_Transmit_Parameters command for the
 *        advertising set, the Controller shall return the error code Command
 *        Disallowed (0x0C). If the periodic advertising is on a PHY that does
 *        not allow Constant Tone Extensions, the Controller shall return the
 *        error code Command Disallowed (0x0C).
 * @param Advertising_Handle Identifier for the advertising set in which
 *        Constant Tone Extension is being enabled or disabled
 *        Values:
 *        - 0x00 ... 0xEF
 * @param CTE_Enable It enables or disables the use of Constant Tone Extensions.
 *        Values:
 *        - 0x00: Advertising with Constant Tone Extension is disabled (default)
 *        - 0x01: Advertising with Constant Tone Extension is enabled
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_connectionless_cte_transmit_enable(uint8_t Advertising_Handle,
                                                         uint8_t CTE_Enable);
/**
 * @brief The HCI_LE_Set_Connectionless_IQ_Sampling_Enable command is used to
 *        request that the Controller enables or disables capturing IQ samples
 *        from the Constant Tone Extension of periodic advertising packets in
 *        the periodic advertising train identified by the Sync_Handle
 *        parameter. If that periodic advertising train does not exist, then the
 *        Controller shall return the error code Unknown Advertising Identifier
 *        (0x42). The Max_Sampled_CTEs parameter specifies the maximum number of
 *        Constant Tone Extensions in each periodic advertising event that the
 *        Controller should collect and report IQ samples from. The Controller
 *        should sample all Constant Tone Extensions up to this number. If the
 *        Sampling_Enable parameter is set to 0x01 (sampling is enabled), the
 *        Controller starts attempting to capture IQ samples from the periodic
 *        advertisements. Once sampling has been enabled, the Controller shall
 *        continue taking IQ samples until the Host issues an
 *        HCI_LE_Set_Connectionless_IQ_Enable command with Sampling_Enable set
 *        to 0x00 (sampling is disabled) or synchronization with the periodic
 *        advertising train is lost. If Sampling_Enable is set to 0x00,
 *        Slot_Durations, Max_Sampled_CTEs, Switching_Pattern_Length, and
 *        Antenna_IDs shall be ignored. The command is also used to set the
 *        antenna switching pattern and switching and sampling slot durations to
 *        be used while receiving the Constant Tone Extension. If Slot_Durations
 *        is set to 0x01 and the Controller does not support 1 microsecond
 *        switching and sampling, the Controller shall return the error code
 *        Unsupported Feature or Parameter Value (0x11). The Slot_Durations,
 *        Switching_Pattern_Length, and Antenna_IDs parameters are only used
 *        when receiving an AoA Constant Tone Extension and do not affect the
 *        reception of an AoD Constant Tone Extension. If
 *        Switching_Pattern_Length is greater than the maximum length of
 *        switching pattern supported by the Controller, the Controller shall
 *        return the error code Unsupported Feature or Parameter Value (0x11).
 *        If the Controller determines that any of the Antenna_IDs[i] values do
 *        not identify an antenna in the device's antenna array, it shall return
 *        the error code Unsupported Feature or Parameter Value (0x11). Note:
 *        Some Controllers may be unable to determine which values do or do not
 *        identify an antenna. If Sampling_Enable is set to 0x01 and the
 *        periodic advertising is on a PHY that does not allow Constant Tone
 *        Extensions, the Controller shall return the error code Command
 *        Disallowed (0x0C).
 * @param Sync_Handle Sync handle that identifies the synchronization
 *        information about the periodic advertising train.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Sampling_Enable If the Sampling_Enable parameter is set to 0x01
 *        (sampling is enabled), the Controller starts attempting to capture IQ
 *        samples from the periodic advertisements.
 *        Values:
 *        - 0x00: DISABLE
 *        - 0x01: ENABLE
 * @param Slot_Durations Sampling rate used by the Controller.
 *        Values:
 *        - 0x01: CTE_SLOT_1us
 *        - 0x02: CTE_SLOT_2us
 * @param Max_Sampled_CTEs It specifies the maximum number of Constant Tone
 *        Extensions in each periodic advertising event that the Controller
 *        should collect and report IQ samples from. The Controller should
 *        sample all Constant Tone Extensions up to this number.
 *        Values:
 *        - 0x00: REPORT_ALL_CTES
 *        - 0x01 ... 0x10
 * @param Switching_Pattern_Length The number of Antenna IDs in the pattern.
 *        Values:
 *        - 0x02 ... 0x4B
 * @param Antenna_IDs List of Antenna IDs in the pattern
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_connectionless_iq_sampling_enable(uint16_t Sync_Handle,
                                                        uint8_t Sampling_Enable,
                                                        uint8_t Slot_Durations,
                                                        uint8_t Max_Sampled_CTEs,
                                                        uint8_t Switching_Pattern_Length,
                                                        uint8_t Antenna_IDs[]);
/**
 * @brief The HCI_LE_Set_Connection_CTE_Receive_Parameters command is used to
 *        enable or disable sampling received Constant Tone Extension fields on
 *        the connection identified by the Connection_Handle parameter and to
 *        set the antenna switching pattern and switching and sampling slot
 *        durations to be used. If the Sampling_Enable parameter is set to 0x01,
 *        the Controller shall sample Constant Tone Extensions on the specified
 *        connection and report the samples to the Host. If it is set to 0x00,
 *        the Controller shall cease sampling on the specified connection; the
 *        remaining parameters shall be ignored. If Slot_Durations is set to
 *        0x01 and the Controller does not support 1 microsecond switching and
 *        sampling, the Controller shall return the error code Unsupported
 *        Feature or Parameter Value (0x11). The Slot_Durations,
 *        Switching_Pattern_Length, and Antenna_IDs parameters are only used
 *        when receiving an AoA Constant Tone Extension and do not affect the
 *        reception of an AoD Constant Tone Extension. If
 *        Switching_Pattern_Length is greater than the maximum length of
 *        switching pattern supported by the Controller, the Controller shall
 *        return the error code Unsupported Feature or Parameter Value (0x11).
 *        If the Controller determines that any of the Antenna_IDs[i] values do
 *        not identify an antenna in the device's antenna array, it shall return
 *        the error code Unsupported Feature or Parameter Value (0x11). Note:
 *        Some Controllers may be unable to determine which values do or do not
 *        identify an antenna.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Sampling_Enable
 *        Values:
 *        - 0x00: Connection IQ sampling is disabled (default)
 *        - 0x01: Connection IQ sampling is enabled
 * @param Slot_Durations Sampling rate used by the Controller.
 *        Values:
 *        - 0x01: CTE_SLOT_1us
 *        - 0x02: CTE_SLOT_2us
 * @param Switching_Pattern_Length
 *        Values:
 *        - 0x02 ... 0x4B: The number of Antenna IDs in the pattern.
 * @param Antenna_IDs List of Antenna IDs in the pattern
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_connection_cte_receive_parameters(uint16_t Connection_Handle,
                                                        uint8_t Sampling_Enable,
                                                        uint8_t Slot_Durations,
                                                        uint8_t Switching_Pattern_Length,
                                                        uint8_t Antenna_IDs[]);
/**
 * @brief The HCI_LE_Set_Connection_CTE_Transmit_Parameters command is used to
 *        set the antenna switching pattern and permitted Constant Tone
 *        Extension types used for transmitting Constant Tone Extensions
 *        requested by the peer device on the connection identified by the
 *        Connection_Handle parameter. If the Host issues this command when
 *        Constant Tone Extension responses have been enabled on the connection,
 *        the Controller shall return the error code Command Disallowed (0x0C).
 *        If the CTE_Types parameter has a bit set for a type of Constant Tone
 *        Extension that the Controller does not support, the Controller shall
 *        return the error code Unsupported Feature or Parameter Value (0x11).
 *        The Switching_Pattern_Length and Antenna_IDs[i] parameters are only
 *        used when transmitting an AoD Constant Tone Extension and shall be
 *        ignored when CTE_Types does not have a bit set for an AoD Constant
 *        Tone Extension; they do not affect the transmission of an AoA Constant
 *        Tone Extension. If Switching_Pattern_Length is greater than the
 *        maximum length of switching pattern supported by the Controller, the
 *        Controller shall return the error code Unsupported Feature or
 *        Parameter Value (0x11). If the Controller determines that any of the
 *        Antenna_IDs[i] values do not identify an antenna in the device's
 *        antenna array, it shall return the error code Unsupported Feature or
 *        Parameter Value (0x11). Note: Some Controllers may be unable to
 *        determine which values do or do not identify an antenna.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CTE_Type
 *        Flags:
 *        - 0x01: Allow AoA Constant Tone Extension Response
 *        - 0x02: Allow AoD Constant Tone Extension Response with 1 microsecond slots
 *        - 0x04: Allow AoD Constant Tone Extension Response with 2 microseconds slots
 * @param Switching_Pattern_Length
 *        Values:
 *        - 0x02 ... 0x4B: The number of Antenna IDs in the pattern.
 * @param Antenna_IDs List of Antenna IDs in the pattern
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_connection_cte_transmit_parameters(uint16_t Connection_Handle,
                                                         uint8_t CTE_Type,
                                                         uint8_t Switching_Pattern_Length,
                                                         uint8_t Antenna_IDs[]);
/**
 * @brief The HCI_LE_Connection_CTE_Request_Enable command is used to request
 *        the Controller to start or stop initiating the Constant Tone Extension
 *        Request procedure (see [Vol 6] Part B, Section 5.1.12) on a connection
 *        identified by the Connection_Handle parameter. If the Host issues this
 *        command when the Controller is aware (e.g. through a previous feature
 *        exchange) that the peer device's Link Layer does not support the
 *        Connection CTE Response feature, the Controller shall return the error
 *        code Unsupported Remote Feature / Unsupported LMP Feature (0x1A). If
 *        the Host issues this command when the Controller is aware that the
 *        peer device's Link Layer does not support the requested CTE type, the
 *        Controller should return the error code Unsupported Remote Feature /
 *        Unsupported LMP Feature (0x1A). If Enable is set to 0x00, the
 *        remaining parameters shall be ignored. The CTE_Request_Interval
 *        parameter defines whether the Constant Tone Extension Request
 *        procedure is initiated only once or periodically. In the case of
 *        periodic operation, the procedure is initiated every
 *        CTE_Request_Interval. However, the Controller may delay initiating the
 *        procedure beyond the requested interval (e.g., in order to prioritize
 *        other activities). The Requested_CTE_Length parameter indicates the
 *        minimum length of the Constant Tone Extension and the
 *        Requested_CTE_Type parameter indicates the type of Constant Tone
 *        Extension that the Controller shall request from the remote device. A
 *        request is active on a connection from when the Host issues a
 *        successful command with Enable set to 0x01 until the single procedure
 *        has been performed, the period specified by CTE_Request_Interval has
 *        ended, or a command with Enable set to 0x00 has succeeded, whichever
 *        happens first. If the Host issues this command with Enable set to 0x01
 *        while a request is active for the specified connection, the Controller
 *        shall return the error code Command Disallowed (0x0C). Note: The
 *        failed command will not affect the behavior of the Link Layer in
 *        respect of the currently-active request. If the Host issues this
 *        command before issuing the
 *        HCI_LE_Set_Connection_CTE_Receive_Parameters command at least once on
 *        the connection, the Controller shall return the error code Command
 *        Disallowed (0x0C). If the Host issues this command when the receiver
 *        PHY for the connection is not a PHY that allows Constant Tone
 *        Extensions, the Controller shall return the error code Command
 *        Disallowed (0x0C). If the Host sets CTE_Request_Interval to a non-zero
 *        value less than or equal to connPeripheralLatency, the Controller
 *        shall return the error code Command Disallowed (0x0C). If Enable is
 *        set to 0x01 and the receiver PHY for the connection changes to a PHY
 *        that does not allow Constant Tone Extensions, then the Controller
 *        shall automatically disable Constant Tone Extension requests as if the
 *        Host had issued this command with Enable set to 0x00. Note: If the PHY
 *        changes back to a PHY that allows Constant Tone Extensions, then the
 *        Controller will not automatically re-enable Constant Tone Extension
 *        requests.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Enable If it is set to 0x00, the remaining parameters shall be
 *        ignored.
 *        Values:
 *        - 0x00: Disable Constant Tone Extension Request for the connection (default)
 *        - 0x01: Enable Constant Tone Extension Request for the connection
 * @param CTE_Request_Interval It defines whether the Constant Tone Extension
 *        Request procedure is initiated only once or periodically. In the case
 *        of periodic operation, the procedure is initiated every
 *        CTE_Request_Interval. However, the Controller may delay initiating the
 *        procedure beyond the requested interval (e.g., in order to prioritize
 *        other activities).
 *        Values:
 *        - 0x0000: Initiate the Constant Tone Extension Request procedure once, at the nearliest practical opportunity.
 *        - 0x0001 ... 0xFFFF: Requested interval for initiating the Constant Tone Extension Request procedure in number of connection events.
 * @param Requested_CTE_Length It indicates the minimum length of the Constant
 *        Tone Extension and the Requested_CTE_Type parameter indicates the type
 *        of Constant Tone Extension that the Controller shall request from the
 *        remote device.
 *        Values:
 *        - 0x02 ... 0x14: Minimum length of the Constant Tone Extension being requested in 8 nmicroseconds units
 * @param Requested_CTE_Type
 *        Flags:
 *        - 0x00: AoA Constant Tone Extension
 *        - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 *        - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_connection_cte_request_enable(uint16_t Connection_Handle,
                                                uint8_t Enable,
                                                uint16_t CTE_Request_Interval,
                                                uint8_t Requested_CTE_Length,
                                                uint8_t Requested_CTE_Type);
/**
 * @brief The HCI_LE_Connection_CTE_Response_Enable command is used to request
 *        the Controller to respond to LL_CTE_REQ PDUs with LL_CTE_RSP PDUs on
 *        the specified connection. If the Host issues this command before
 *        issuing the HCI_LE_Set_Connection_CTE_Transmit_Parameters command at
 *        least once on the connection, the Controller shall return the error
 *        code Command Disallowed (0x0C). If the Host issues this command when
 *        the transmitter PHY for the connection is not a PHY that allows
 *        Constant Tone Extensions, the Controller shall return the error code
 *        Command Disallowed (0x0C). If the transmitter PHY for the connection
 *        changes to a PHY that does not allow Constant Tone Extensions, then
 *        the Controller shall automatically disable Constant Tone Extension
 *        responses.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Enable
 *        Values:
 *        - 0x00: Disable Constant Tone Extension Response for the connection (default)
 *        - 0x01: Enable Constant Tone Extension Response for the connection
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_connection_cte_response_enable(uint16_t Connection_Handle,
                                                 uint8_t Enable);
/**
 * @brief The HCI_LE_Read_Antenna_Information command allows the Host to read
 *        the switching rates, the sampling rates, the number of antennae, and
 *        the maximum length of a transmitted Constant Tone Extension supported
 *        by the Controller.
 * @param[out] Supported_Switching_Sampling_Rates
 *             Flags:
 *             - 0x00: 1 microsecond switching supported for AoD transmission
 *             - 0x02: 1 microsecond switching supported for AoD reception
 *             - 0x04: 1 microsecond switching and sampling supported for AoA reception
 * @param[out] Num_Antennae
 *             Values:
 *             - 0x01 ... 0x4B: The number of antennae supported by the Controller
 * @param[out] Max_Switching_Pattern_Length
 *             Values:
 *             - 0x02 ... 0x4B: Maximum length of antenna switching pattern supported by the Controller
 * @param[out] Max_CTE_Length
 *             Values:
 *             - 0x02 ... 0x14: Maximum length of a transmitted Constant Tone Extension supported in 8 microseconds units
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_antenna_information(uint8_t *Supported_Switching_Sampling_Rates,
                                           uint8_t *Num_Antennae,
                                           uint8_t *Max_Switching_Pattern_Length,
                                           uint8_t *Max_CTE_Length);
/**
 * @brief The HCI_LE_Set_Periodic_Advertising_Receive_Enable command will enable
 *        or disable reports for the periodic advertising train identified by
 *        the Sync_Handle parameter. The Enable parameter determines whether
 *        reporting and duplicate filtering are enabled or disabled. If the
 *        value is the same as the current state, the command has no effect. If
 *        the periodic advertising train corresponding to the Sync_Handle
 *        parameter does not exist, the Controller shall return the error code
 *        Unknown Advertising Identifier (0x42).
 * @param Sync_Handle Sync_Handle identifying the periodic advertising train.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Enable Bit 0 to enable reporting. Bit 1 to enable duplicate filtering.
 *        Flags:
 *        - 0x01: ENABLE_REPORTING
 *        - 0x02: ENABLE_DUPLICATE_FILTERING
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_periodic_advertising_receive_enable(uint16_t Sync_Handle,
                                                          uint8_t Enable);
/**
 * @brief The HCI_LE_Periodic_Advertising_Sync_Transfer command is used to
 *        instruct the Controller to send synchronization information about the
 *        periodic advertising train identified by the Sync_Handle parameter to
 *        a connected device. The Service_Data parameter is a value provided by
 *        the Host for use by the Host of the peer device. It is not used by the
 *        Controller. The connected device is identified by the
 *        Connection_Handle parameter. If the periodic advertising train
 *        corresponding to the Sync_Handle parameter does not exist, the
 *        Controller shall return the error code Unknown Advertising Identifier
 *        (0x42). If the Connection_Handle parameter does not identify a current
 *        connection, the Controller shall return the error code Unknown
 *        Connection Identifier (0x02). If the remote device has not indicated
 *        support for the Periodic Advertising Sync Transfer - Recipient
 *        feature, the Controller shall return the error code Unsupported Remote
 *        Feature / Unsupported LMP Feature (0x1A). Note: This command may
 *        complete before the periodic advertising synchronization information
 *        is sent. No indication is given as to how the recipient handled the
 *        information.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Service_Data The Service_Data parameter is a value provided by the
 *        Host for use by the Host of the peer device. It is not used by the
 *        Controller.
 * @param Sync_Handle Sync handle that identifies the synchronization
 *        information about the periodic advertising train.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_periodic_advertising_sync_transfer(uint16_t Connection_Handle,
                                                     uint16_t Service_Data,
                                                     uint16_t Sync_Handle);
/**
 * @brief The HCI_LE_Periodic_Advertising_Set_Info_Transfer command is used to
 *        instruct the Controller to send synchronization information about the
 *        periodic advertising in an advertising set to a connected device. The
 *        Advertising_Handle parameter identifies the advertising set. If the
 *        parameters in the advertising set have changed since the periodic
 *        advertising was first enabled, the current parameters - not the
 *        original ones - are sent. The Service_Data parameter is a value
 *        provided by the Host to identify the periodic advertising train to the
 *        peer device. It is not used by the Controller. The connected device is
 *        identified by the Connection_Handle parameter. If the advertising set
 *        corresponding to the Advertising_Handle parameter does not exist, the
 *        Controller shall return the error code Unknown Advertising Identifier
 *        (0x42). If periodic advertising is not currently in progress for the
 *        advertising set, the Controller shall return the error code Command
 *        Disallowed (0x0C). If the Connection_Handle parameter does not
 *        identify a current connection, the Controller shall return the error
 *        code Unknown Connection Identifier (0x02). If the remote device has
 *        not indicated support for the Periodic Advertising Sync Transfer -
 *        Recipient feature, the Controller shall return the error code
 *        Unsupported Remote Feature / Unsupported LMP Feature (0x1A). Note:
 *        This command may complete before the periodic advertising
 *        synchronization information is sent. No indication is given as to how
 *        the recipient handled the information.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Service_Data It is a value provided by the Host to identify the
 *        periodic advertising train to the peer device. It is not used by the
 *        Controller.
 * @param Advertising_Handle It is used to identify an advertising set
 *        Values:
 *        - 0x00 ... 0xEF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_periodic_advertising_set_info_transfer(uint16_t Connection_Handle,
                                                         uint16_t Service_Data,
                                                         uint8_t Advertising_Handle);
/**
 * @brief The HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command
 *        is used to specify how the Controller will process periodic
 *        advertising synchronization information received from the device
 *        identified by the Connection_Handle parameter (the "transfer mode").
 *        The Mode parameter specifies the action to be taken when periodic
 *        advertising synchronization information is received. If Mode is 0x00,
 *        the Controller will ignore the information. Otherwise it will notify
 *        the Host and synchronize to the periodic advertising. Mode also
 *        specifies whether periodic advertising reports are initially enabled
 *        or disabled and whether duplicates are filtered. The Skip parameter
 *        specifies the number of consecutive periodic advertising packets that
 *        the receiver may skip after successfully receiving a periodic
 *        advertising packet. The Sync_Timeout parameter specifies the maximum
 *        permitted time between successful receives. If this time is exceeded,
 *        synchronization is lost. Irrespective of the value of the Skip
 *        parameter, the Controller should stop skipping packets before the
 *        Sync_Timeout would be exceeded. The CTE_Type parameter specifies
 *        whether to only synchronize to periodic advertising with certain types
 *        of Constant Tone Extension. If the periodic advertiser changes the
 *        type of the Constant Tone Extension after the Controller has
 *        synchronized with the periodic advertising, it shall remain
 *        synchronized. Note: A value of 0 (i.e. all bits clear) indicates that
 *        the presence or absence of a Constant Tone Extension is irrelevant.
 *        This command does not affect any processing of any periodic
 *        advertising synchronization information already received from the peer
 *        device, whether or not the Controller has yet synchronized to the
 *        periodic advertising train it describes. The parameter values provided
 *        by this command override those provided via the HCI_LE_Set_Default_Per
 *        iodic_Advertising_Sync_Transfer_Parameterscommand or any preferences
 *        previously set using the
 *        HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command on
 *        the same connection. If the Connection_Handle parameter does not
 *        identify a current connection, the Controller shall return the error
 *        code Unknown Connection Identifier (0x02).
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Mode The action to be taken when periodic advertising synchronization
 *        information is received. If 0, no attempt is made to synchronize to
 *        the periodic advertising and no
 *        HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to
 *        the Host. If 1, an HCI_LE_Periodic_Advertising_Sync_Transfer_Received
 *        event is sent to the Host. HCI_LE_Periodic_Advertising_Report events
 *        will be disabled. If 2, an
 *        HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to
 *        the Host. HCI_LE_Periodic_Advertising_Report events will be enabled
 *        with duplicate filtering disabled. If 3, an
 *        HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to
 *        the Host. HCI_LE_Periodic_Advertising_Report events will be enabled
 *        with duplicate filtering enabled.
 *        Values:
 *        - 0x00: NO_SYNC
 *        - 0x01: REPORTS_DISABLED
 *        - 0x02: REPORTS_ENABLED
 *        - 0x03: REPORTS_ENABLED_WITH_DUPLICATE_FILTERING
 * @param Skip The number of periodic advertising packets that can be skipped
 *        after a successful receive.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Sync_Timeout Synchronization timeout for the periodic advertising
 *        train. Time = N*10 ms.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x4000 (163840 ms) 
 * @param CTE_Type It specifies whether to only synchronize to periodic
 *        advertising with certain types of Constant Tone Extension.  If bit 0
 *        is set: do not sync to packets with an AoA Constant Tone Extension. If
 *        bit 1 is set: Do not sync to packets with an AoD Constant Tone
 *        Extension with 1 us slots. If bit 2 is set: Do not sync to packets
 *        with an AoD Constant Tone Extension with 2 us slots. If bit 3 is set:
 *        Do not sync to packets without a Constant Tone Extension.
 *        Flags:
 *        - 0x01: DO_NOT_SYNC_WITH_AOA
 *        - 0x02: DO_NOT_SYNC_WITH_AOD_1US
 *        - 0x04: DO_NOT_SYNC_WITH_AOD_2US
 *        - 0x10: DO_NOT_SYNC_WITHOUT_CTE
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_periodic_advertising_sync_transfer_parameters(uint16_t Connection_Handle,
                                                                    uint8_t Mode,
                                                                    uint16_t Skip,
                                                                    uint16_t Sync_Timeout,
                                                                    uint8_t CTE_Type);
/**
 * @brief The HCI_LE_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters
 *        command is used to specify the initial value for the mode, skip,
 *        timeout, and Constant Tone Extension type (set by the
 *        HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command; see
 *        Section 7.8.91) to be used for all subsequent connections over the LE
 *        transport. The Mode parameter specifies the initial action to be
 *        taken. If Mode is 0x00, the Controller will ignore the information.
 *        Otherwise it will notify the Host and synchronize to the periodic
 *        advertising. Mode also specifies whether periodic advertising reports
 *        are initially enabled or disabled. The Skip parameter specifies the
 *        number of consecutive periodic advertising packets that the receiver
 *        may skip after successfully receiving a periodic advertising packet.
 *        The Sync_Timeout parameter specifies the maximum permitted time
 *        between successful receives. If this time is exceeded, synchronization
 *        is lost. The CTE_Type parameter specifies whether to only synchronize
 *        to periodic advertising with certain types of Constant Tone Extension.
 *        If the periodic advertiser changes the type of the Constant Tone
 *        Extension after the Controller has synchronized with the periodic
 *        advertising, it shall remain synchronized. Note: A value of 0 (i.e.
 *        all bits clear) indicates that the presence or absence of a Constant
 *        Tone Extension is irrelevant. This command does not affect any
 *        existing connection.
 * @param Mode The action to be taken when periodic advertising synchronization
 *        information is received. If 0, no attempt is made to synchronize to
 *        the periodic advertising and no
 *        HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to
 *        the Host. If 1, an HCI_LE_Periodic_Advertising_Sync_Transfer_Received
 *        event is sent to the Host. HCI_LE_Periodic_Advertising_Report events
 *        will be disabled. If 2, an
 *        HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to
 *        the Host. HCI_LE_Periodic_Advertising_Report events will be enabled
 *        with duplicate filtering disabled. If 3, an
 *        HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to
 *        the Host. HCI_LE_Periodic_Advertising_Report events will be enabled
 *        with duplicate filtering enabled.
 *        Values:
 *        - 0x00: NO_SYNC
 *        - 0x01: REPORTS_DISABLED
 *        - 0x02: REPORTS_ENABLED
 *        - 0x03: REPORTS_ENABLED_WITH_DUPLICATE_FILTERING
 * @param Skip The number of periodic advertising packets that can be skipped
 *        after a successful receive.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Sync_Timeout Synchronization timeout for the periodic advertising
 *        train. Time = N*10 ms.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x4000 (163840 ms) 
 * @param CTE_Type It specifies whether to only synchronize to periodic
 *        advertising with certain types of Constant Tone Extension.  If bit 0
 *        is set: do not sync to packets with an AoA Constant Tone Extension. If
 *        bit 1 is set: Do not sync to packets with an AoD Constant Tone
 *        Extension with 1 us slots. If bit 2 is set: Do not sync to packets
 *        with an AoD Constant Tone Extension with 2 us slots. If bit 3 is set:
 *        Do not sync to packets without a Constant Tone Extension.
 *        Flags:
 *        - 0x01: DO_NOT_SYNC_WITH_AOA
 *        - 0x02: DO_NOT_SYNC_WITH_AOD_1US
 *        - 0x04: DO_NOT_SYNC_WITH_AOD_2US
 *        - 0x10: DO_NOT_SYNC_WITHOUT_CTE
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_default_periodic_advertising_sync_transfer_parameters(uint8_t Mode,
                                                                            uint16_t Skip,
                                                                            uint16_t Sync_Timeout,
                                                                            uint8_t CTE_Type);
/**
 * @brief This command is used to read the maximum size of the data portion of
 *        ACL data packets and isochronous data packets sent from the Host to
 *        the Controller. The Host shall segment the data transmitted to the
 *        Controller according to these values so that the HCI Data packets and
 *        isochronous data packets will contain data up to this size. The
 *        HCI_LE_Read_Buffer_Size command also returns the total number of HCI
 *        LE ACL Data packets and isochronous data packets that can be stored in
 *        the data buffers of the Controller. The HCI_LE_Read_Buffer_Size
 *        command shall be issued by the Host before it sends any data to an LE
 *        Controller (see Section 4.1.1). If the Controller supports HCI ISO
 *        Data packets, it shall return non-zero values for the
 *        ISO_Data_Packet_Length and Total_Num_ISO_Data_Packets parameters.
 * @param[out] HC_LE_ACL_Data_Packet_Length 0x0000: No dedicated LE Buffer
 *             exists. Use the HCI_Read_Buffer_Size command. 0x001B - 0xFFFF
 *             Maximum length (in octets) of the data portion of each HCI ACL
 *             data packet.
 *             Values:
 *             - 0x0000: NO_BUFFER
 *             - 0x001B ... 0xFFFF
 * @param[out] HC_Total_Num_LE_ACL_Data_Packets 0x00: No dedicated LE Buffer
 *             exists. Use the HCI_Read_Buffer_Size command. 0x01 - 0xFF: Total
 *             number of HCI ACL Data Packets that can be stored in the data
 *             buffers of the Controller.
 *             Values:
 *             - 0x00: NO_BUFFER
 *             - 0x01 ... 0xFF
 * @param[out] ISO_Data_Packet_Length 0x0000: No dedicated ISO Buffer exists.
 *             0x0001 to 0xFFFF: The maximum length (in octets) of the data
 *             portion of each HCI ISO data packet.
 *             Values:
 *             - 0x0000: NO_BUFFER
 *             - 0x0001 ... 0xFFFF
 * @param[out] Total_Num_ISO_Data_Packets 0x00: No dedicated ISO Buffer exists.
 *             0x01 to 0xFF: The total number of HCI ISO data packets that can
 *             be stored in the ISO buffers of the Controller.
 *             Values:
 *             - 0x00: NO_BUFFER
 *             - 0x01 ... 0xFF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_buffer_size_v2(uint16_t *HC_LE_ACL_Data_Packet_Length,
                                      uint8_t *HC_Total_Num_LE_ACL_Data_Packets,
                                      uint16_t *ISO_Data_Packet_Length,
                                      uint8_t *Total_Num_ISO_Data_Packets);
/**
 * @brief transmitted SDU identified by the Packet_Sequence_Number on a CIS or
 *        BIS identified by the Connection_Handle parameter on the Central or
 *        Peripheral. The Packet_Sequence_Number parameter contains the sequence
 *        number of a transmitted SDU. The TX_Time_Stamp and Time_Offset
 *        parameters are described in [Vol 6] Part G, Section 3.3 and [Vol 6]
 *        Part G, Section 3.1 respectively. When the Connection_Handle
 *        identifies a CIS or BIS that is transmitting unframed PDUs, the value
 *        of Time_Offset returned shall be zero. If the Host issues this command
 *        with a connection handle that does not exist, or the connection handle
 *        is not associated with a CIS or BIS, the Controller shall return the
 *        error code Unknown Connection Identifier (0x02). If the Host issues
 *        this command on an existing connection handle for a CIS or BIS that is
 *        not configured for transmitting SDUs, the Controller shall return the
 *        error code Command Disallowed (0x0C). If the Host issues this command
 *        before an SDU has been transmitted by the Controller, the Controller
 *        shall return the error code Command Disallowed (0x0C).
 * @param Connection_Handle Connection handle of the CIS or BIS.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param[out] Packet_Sequence_Number The packet sequence number of an SDU.
 * @param[out] TX_Time_Stamp The CIG reference point or BIG anchor point of a
 *             transmitted SDU derived using the Controller's free running
 *             reference clock (in microseconds).
 * @param[out] Time_Offset The time offset, in microseconds, that is associated
 *             with a transmitted SDU.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_iso_tx_sync(uint16_t Connection_Handle,
                                   uint16_t *Packet_Sequence_Number,
                                   uint32_t *TX_Time_Stamp,
                                   uint8_t Time_Offset[3]);
/**
 * @brief The HCI_LE_Set_CIG_Parameters command is used by a Central's Host to
 *        create a CIG and to set the parameters of one or more CISes that are
 *        associated with a CIG in the Controller. The CIG_ID parameter
 *        identifies a CIG. This parameter is allocated by the Central's Host
 *        and passed to the Peripheral's Host through the Link Layers during the
 *        process of creating a CIS. If the CIG_ID does not exist, then the
 *        Controller shall first create a new CIG. Once the CIG is created
 *        (whether through this command or previously), the Controller shall
 *        modify or add CIS configurations in the CIG that is identified by the
 *        CIG_ID and update all the parameters that apply to the CIG. The
 *        SDU_Interval_C_To_P parameter specifies the time interval between the
 *        start of consecutive SDUs from the Central's Host for all the CISes in
 *        the CIG. This parameter shall be ignored for all CISes that are
 *        unidirectional from Peripheral to Central. The SDU_Interval_P_To_C
 *        parameter specifies the time interval between the start of consecutive
 *        SDUs from the Peripheral's Host for all the CISes in the CIG. This
 *        parameter shall be ignored for all CISes that are unidirectional from
 *        Central to Peripheral. The Worst_Case_SCA parameter shall be the
 *        worst-case sleep clock accuracy of all the Peripherals that will
 *        participate in the CIG. The Host should get the sleep clock accuracy
 *        from all the Peripherals before issuing this command. If the Host
 *        cannot get the sleep clock accuracy from all the Peripherals, it shall
 *        set the Worst_Case_SCA parameter to zero. Note: The Worst_Case_SCA
 *        parameter can be used by the Link Layer to better allow for clock
 *        drift when scheduling the CISes in the CIG. For example, if a CIS has
 *        more than two subevents, the Link Layer of the Central can set the
 *        timing of the subevents such that the worst case drift in the
 *        Peripheral's clock will not exceed 2 x Sub_Interval. This prevents the
 *        Peripheral from synchronizing its timing to the wrong subevent
 *        (adjacent subevents cannot be on the same channel). The Packing
 *        parameter indicates the preferred method of arranging subevents of
 *        multiple CISes. The subevents can be arranged in Sequential or
 *        Interleaved arrangement (see [Vol 6] Part B, Section 4.5.14.2). This
 *        is a recommendation to the Controller which the Controller may ignore.
 *        This parameter shall be ignored when there is only one CIS in the CIG.
 *        The Framing parameter indicates the format of the CIS Data PDUs of the
 *        specified CISes. If the Framing parameter is set to 1 then the CIS
 *        Data PDUs of the specified CISes shall be framed. If the Framing
 *        parameter is set to 0 the CIS Data PDUs of a given CIS may be either
 *        unframed or framed (determined separately for each specified CIS) (see
 *        [Vol 6] Part G, Section 1). The Max_Transport_Latency_C_To_P parameter
 *        contains the maximum transport latency from the Central to the
 *        Peripheral, in milliseconds, as described in [Vol 6] Part G, Section
 *        3.2.1 and [Vol 6] Part G, Section 3.2.2. This parameter shall be
 *        ignored for all CISes that are unidirectional from Peripheral to
 *        Central. The Max_Transport_Latency_P_To_C parameter contains the
 *        maximum transport latency from the Peripheral to the Central, in
 *        milliseconds, as described in [Vol 6] Part G, Section 3.2.1 and [Vol
 *        6] Part G, Section 3.2.2. This parameter shall be ignored for all
 *        CISes that are unidirectional from Central to Peripheral. The
 *        CIS_Count parameter indicates the number of CIS configurations being
 *        modified or added by this command. The Controller shall set the
 *        CIS_Count return parameter equal to this. The CIS_ID[i] parameter
 *        identifies a CIS and is set by the Central's Host and passed to the
 *        Peripheral's Host through the Link Layers during the process of
 *        establishing a CIS. The Max_SDU_C_To_P[i] parameter identifies the
 *        maximum size of an SDU from the Central's Host. If the CIS is
 *        unidirectional from Peripheral to Central, this parameter shall be set
 *        to 0. If a CIS configuration that is being modified has a data path
 *        set in the Central to Peripheral direction and the Host has specified
 *        that Max_SDU_C_To_P[i] shall be set to zero, the Controller shall
 *        return the error code Command Disallowed (0x0C). The Max_SDU_P_To_C[i]
 *        parameter identifies the maximum size of an SDU from the Peripheral's
 *        Host. If the CIS is unidirectional from Central to Peripheral, this
 *        parameter shall be set to 0. If a CIS configuration that is being
 *        modified has a data path set in the Peripheral to Central direction
 *        and the Host has specified that Max_SDU_P_To_C[i] shall be set to
 *        zero, the Controller shall return the error code Command Disallowed
 *        (0x0C). The PHY_C_To_P[i] parameter identifies which PHY to use for
 *        transmission from the Central to the Peripheral. The Host shall set at
 *        least one bit in this parameter and the Controller shall pick a PHY
 *        from the bits that are set. The PHY_P_To_C[i] parameter identifies
 *        which PHY to use for transmission from the Peripheral to the Central.
 *        The Host shall set at least one bit in this parameter and the
 *        Controller shall pick a PHY from the bits that are set. The
 *        RTN_C_To_P[i] (Retransmission Number) parameter contains the number of
 *        times that a CIS Data PDU should be retransmitted from the Central to
 *        Peripheral before being acknowledged or flushed (irrespective of which
 *        isochronous events the retransmission opportunities occur in). If the
 *        CIS is unidirectional from Peripheral to Central, this parameter shall
 *        be ignored. Otherwise, this parameter is a recommendation to the
 *        Controller which the Controller may ignore. The RTN_P_To_C[i]
 *        parameter contains the number of times that a CIS Data PDU should be
 *        retransmitted from the Peripheral to Central before being acknowledged
 *        or flushed (irrespective of which isochronous events the
 *        retransmission opportunities occur in). If the CIS is unidirectional
 *        from Central to Peripheral, this parameter shall be ignored.
 *        Otherwise, this parameter is a recommendation to the Controller which
 *        the Controller may ignore. If the Status return parameter is non-zero,
 *        then the state of the CIG and its CIS configurations shall not be
 *        changed by the command. If the CIG did not already exist, it shall not
 *        be created. If the Status return parameter is zero, then the
 *        Controller shall set the Connection_Handle arrayed return parameter to
 *        the connection handle(s) corresponding to the CIS configurations
 *        specified in the CIS_IDs command parameter, in the same order. If the
 *        same CIS_ID is being reconfigured, the same connection handle shall be
 *        returned. The connection handle of a CIS shall refer to the CIS when
 *        it exists and to the configuration of the CIS stored in a CIG when the
 *        CIG exists but the CIS with that CIS_ID does not. If the Host issues
 *        this command when the CIG is not in the configurable state, the
 *        Controller shall return the error code Command Disallowed (0x0C). If
 *        the Host attempts to create a CIG or set parameters that exceed the
 *        maximum supported resources in the Controller, the Controller shall
 *        return the error code Memory Capacity Exceeded (0x07). If the Host
 *        attempts to set CIS parameters that exceed the maximum supported
 *        connections in the Controller, the Controller shall return the error
 *        code Connection Limit Exceeded (0x09). If the Host sets, in the
 *        PHY_C_To_P[i] or PHY_P_To_C[i] parameters, a bit for a PHY that the
 *        Controller does not support, including a bit that is reserved for
 *        future use, the Controller shall return the error code Unsupported
 *        Feature or Parameter Value (0x11). If the Controller does not support
 *        asymmetric PHYs and the Host sets PHY_C_To_P[i] to a different value
 *        than PHY_P_To_C[i], the Controller shall return the error code
 *        Unsupported Feature or Parameter Value (0x11). If the Host specifies
 *        an invalid combination of CIS parameters, the Controller shall return
 *        the error code Unsupported Feature or Parameter Value (0x11).
 * @param CIG_ID Used to identify the CIG.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param SDU_Interval_C_To_P The interval, in microseconds, of periodic SDUs.
 *        Values:
 *        - 0x0000FF ... 0x0FFFFF
 * @param SDU_Interval_P_To_C The interval, in microseconds, of periodic SDUs.
 *        Values:
 *        - 0x0000FF ... 0x0FFFFF
 * @param Worst_Case_SCA Worst-case sleep clock accuracy of all the Peripherals.
 *        Values:
 *        - 0x00: 251 ppm to 500 ppm
 *        - 0x01: 151 ppm to 250 ppm
 *        - 0x02: 101 ppm to 150 ppm
 *        - 0x03: 76 ppm to 100 ppm
 *        - 0x04: 51 ppm to 75 ppm
 *        - 0x05: 31 ppm to 50 ppm
 *        - 0x06: 21 ppm to 30 ppm
 *        - 0x07: 0 ppm to 20 ppm
 * @param Packing Preferred method of arranging subevents of multiple CISes.
 *        Values:
 *        - 0x00: Sequential
 *        - 0x01: Interleaved
 * @param Framing Format of the CIS Data PDUs of the specified CISes.
 *        Values:
 *        - 0x00: Unframed
 *        - 0x01: Framed
 * @param Max_Transport_Latency_C_To_P Maximum transport latency, in
 *        milliseconds, from the Central's Controller to the Peripheral's
 *        Controller.
 *        Values:
 *        - 0x0005 ... 0x0FA0
 * @param Max_Transport_Latency_P_To_C Maximum transport latency, in
 *        milliseconds, from the Peripheral's Controller to the Central's
 *        Controller.
 *        Values:
 *        - 0x0005 ... 0x0FA0
 * @param CIS_Count Total number of CIS configurations in the CIG being added or
 *        modified.
 *        Values:
 *        - 0x00 ... 0x1F
 * @param CIS_Param See @ref CIS_Param_t
 * @param[out] Connection_Handle Connection handle of the CIS in the CIG.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_cig_parameters(uint8_t CIG_ID,
                                     uint8_t SDU_Interval_C_To_P[3],
                                     uint8_t SDU_Interval_P_To_C[3],
                                     uint8_t Worst_Case_SCA,
                                     uint8_t Packing,
                                     uint8_t Framing,
                                     uint16_t Max_Transport_Latency_C_To_P,
                                     uint16_t Max_Transport_Latency_P_To_C,
                                     uint8_t CIS_Count,
                                     CIS_Param_t CIS_Param[],
                                     uint16_t Connection_Handle[]);
/**
 * @brief The HCI_LE_Set_CIG_Parameters_Test command should only be used for
 *        testing purposes. The command is used by a Central's Host to create a
 *        CIG and to set the parameters of one or more CISes that are associated
 *        with a CIG in the Controller. The CIG_ID parameter identifies a CIG.
 *        This parameter is allocated by the Central's Host and passed to the
 *        Peripheral's Host through the Link Layers during the process of
 *        creating a CIS. If the CIG_ID does not exist, then the Controller
 *        shall first create a new CIG. Once the CIG is created (whether through
 *        this command or previously), the Controller shall modify or add CIS
 *        configurations in the CIG that is identified by the CIG_ID and update
 *        all the parameters that apply to the CIG. The SDU_Interval_C_To_P
 *        parameter specifies the time interval of periodic SDUs from the
 *        Central's Host. The SDU_Interval_P_To_C parameter specifies the time
 *        interval of periodic SDUs from the Peripheral's Host. The FT_C_To_P
 *        parameter identifies the maximum time for a payload from the Central
 *        to Peripheral to be transmitted and re-transmitted, after which it is
 *        flushed (see [Vol 6] Part B, Section 4.5.13.5). This parameter is
 *        expressed in multiples of ISO_Interval. The FT_P_To_C parameter
 *        identifies the maximum time for a payload from the Peripheral to
 *        Central to be transmitted and re-transmitted, after which it is
 *        flushed (see[Vol 6] Part B, Section 4.5.13.5). This parameter is
 *        expressed in multiples of ISO_Interval. The ISO_Interval parameter
 *        specifies the time between two consecutive CIS anchor points. The
 *        CIS_Count parameter contains the number of CIS configurations being
 *        added or modified by this command. The Controller shall set the
 *        CIS_Count return parameter equal to this. The CIS_ID[i] parameter
 *        identifies the CIS and is set by the Central's Host and passed to the
 *        Peripheral's Host through the Link Layers during the process of
 *        establishing a CIS. The Worst_Case_SCA parameter is the worst-case
 *        sleep clock accuracy of all the Peripherals that will participate in
 *        the CIG. The Host should get the sleep clock accuracy from all the
 *        Peripherals before issuing this command. In case the Host cannot get
 *        the sleep clock accuracy from all the Peripherals, it shall set the
 *        Worst_Case_SCA parameter to zero. Note: The Worst_Case_SCA parameter
 *        can be used by the Link Layer to better allow for clock drift when
 *        scheduling the CISes in the CIG. For example, if a CIS has more than
 *        two subevents, the Link Layer of the Central can set the timing of the
 *        subevents such that the worst case drift in the Peripheral's clock
 *        will not exceed 2 x Sub_Interval. This prevents the Peripheral from
 *        synchronizing its timing to the wrong subevent (adjacent subevents
 *        cannot be on the same channel). The Packing parameter is used to
 *        indicate the preferred method of arranging subevents of multiple
 *        CISes. The subevents can be arranged in Sequential or Interleaved
 *        arrangement. This is a recommendation to the Controller which it may
 *        ignore. This parameter shall be ignored when there is only one CIS in
 *        the CIG. The Framing parameter indicates the format of the CIS Data
 *        PDUs of all the CISes. If the Framing parameter is set to 1 then the
 *        CIS Data PDUs of the specified CISes shall be framed, and when set to
 *        0 they shall be unframed (see [Vol 6] Part G, Section 1). The
 *        CIS_ID[i] parameter is used to identify a CIS. The NSE[i] parameter
 *        identifies the maximum number of subevents for each CIS in a CIG
 *        event. The Max_SDU_C_To_P[i] parameter identifies the maximum size of
 *        SDU from the Central's Host. If the CIS is unidirectional from
 *        Peripheral to Central, this parameter shall be set to 0. If a CIS
 *        configuration that is being modified has a data path set in the
 *        Central to Peripheral direction and the Host has specified that
 *        Max_SDU_C_To_P[i] shall be set to zero, the Controller shall return
 *        the error code Command Disallowed (0x0C). The minimum value of the
 *        Max_SDU_Size parameter in the ISO Transmit Test mode when the
 *        Payload_Type = 1 or 2 shall be 4 octets. The Max_SDU_P_To_C[i]
 *        parameter identifies the maximum size of SDU from the Peripheral's
 *        Host. If the CIS is unidirectional from Central to Peripheral, this
 *        parameter shall be set to 0. If a CIS configuration that is being
 *        modified has a data path set in the Peripheral to Central direction
 *        and the Host has specified that Max_SDU_P_To_C[i] shall be set to
 *        zero, the Controller shall return the error code Command Disallowed
 *        (0x0C).The minimum value of the Max_SDU parameter in the ISO Transmit
 *        Test mode when the Payload_Type = 1 or 2 shall be 4 octets. The
 *        Max_PDU_C_To_P[i] parameter identifies the maximum size PDU from the
 *        Central to Peripheral. The Max_PDU_P_To_C[i] parameter identifies the
 *        maximum size PDU from the Peripheral to Central. The PHY_C_To_P[i]
 *        parameter identifies the PHY to be used for transmission of packets
 *        from the Central to the Peripheral. The Host shall set only one bit in
 *        this parameter and the Controller shall use the PHY set by the Host.
 *        The PHY_P_To_C[i] parameter identifies the PHY to be used for
 *        transmission of packets from the Peripheral to the Central. The Host
 *        shall set only one bit in this parameter and the Controller shall use
 *        the PHY set by the Host. The BN_C_To_P[i] parameter identifies the
 *        burst number for Central to Peripheral (see [Vol 6] Part B, Section
 *        4.5.13). If the CIS is unidirectional from Peripheral to Central, this
 *        parameter shall be set to zero. The BN_P_To_C[i] parameter identifies
 *        the burst number for Peripheral to Central (see [Vol 6] Part B,
 *        Section 4.5.13). If the CIS is unidirectional from Central to
 *        Peripheral, this parameter shall be set to zero. If the Status return
 *        parameter is non-zero, then the state of the CIG and its CIS
 *        configurations shall not be changed by the command. If the CIG did not
 *        already exist, it shall not be created. If the Status return parameter
 *        is zero, then the Controller shall set the Connection_Handle arrayed
 *        return parameter to the connection handle(s) corresponding to the CIS
 *        configurations specified in the CIS_IDs command parameter, in the same
 *        order. If the same CIS_ID is being reconfigured, the same connection
 *        handle shall be returned. If the Host issues this command when the CIG
 *        is not in the configurable state, the Controller shall return the
 *        error code Command Disallowed (0x0C). If the Host attempts to create a
 *        CIG or set parameters that exceed the maximum supported resources in
 *        the Controller, the Controller shall return the error code Memory
 *        Capacity Exceeded (0x07). If the Host attempts to set CIS parameters
 *        that exceed the maximum supported connections in the Controller, the
 *        Controller shall return the error code Connection Limit Exceeded
 *        (0x09). If the Host attempts to set an invalid combination of CIS
 *        parameters, the Controller shall return the error code Unsupported
 *        Feature or Parameter Value (0x11). If the Host sets, in the
 *        PHY_C_To_P[i] or PHY_P_To_C[i] parameters, a bit for a PHY that the
 *        Controller does not support, including a bit that is reserved for
 *        future use, the Controller shall return the error code Unsupported
 *        Feature or Parameter Value (0x11). If the Controller does not support
 *        asymmetric PHYs and the Host sets PHY_C_To_P[i] to a different value
 *        than PHY_P_To_C[i], the Controller shall return the error code
 *        Unsupported Feature or Parameter Value (0x11).
 * @param CIG_ID Used to identify the CIG.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param SDU_Interval_C_To_P The interval, in microseconds, of periodic SDUs.
 *        Values:
 *        - 0x0000FF ... 0x0FFFFF
 * @param SDU_Interval_P_To_C The interval, in microseconds, of periodic SDUs.
 *        Values:
 *        - 0x0000FF ... 0x0FFFFF
 * @param FT_C_To_P The flush timeout in multiples of ISO_Interval for each
 *        payload sent from the Central to Peripheral.
 *        Values:
 *        - 0x01 ... 0xFF
 * @param FT_P_To_C The flush timeout in multiples of ISO_Interval for each
 *        payload sent from the Peripheral to Central.
 *        Values:
 *        - 0x01 ... 0xFF
 * @param ISO_Interval Time between consecutive CIS anchor points. Time = N *
 *        1.25 ms
 *        Values:
 *        - 0x0004 (5.00 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Worst_Case_SCA Worst-case sleep clock accuracy of all the Peripherals.
 *        Values:
 *        - 0x00: 251 ppm to 500 ppm
 *        - 0x01: 151 ppm to 250 ppm
 *        - 0x02: 101 ppm to 150 ppm
 *        - 0x03: 76 ppm to 100 ppm
 *        - 0x04: 51 ppm to 75 ppm
 *        - 0x05: 31 ppm to 50 ppm
 *        - 0x06: 21 ppm to 30 ppm
 *        - 0x07: 0 ppm to 20 ppm
 * @param Packing Preferred method of arranging subevents of multiple CISes.
 *        Values:
 *        - 0x00: Sequential
 *        - 0x01: Interleaved
 * @param Framing Format of the CIS Data PDUs of the specified CISes.
 *        Values:
 *        - 0x00: Unframed
 *        - 0x01: Framed
 * @param CIS_Count Total number of CIS configurations in the CIG being added or
 *        modified.
 *        Values:
 *        - 0x00 ... 0x1F
 * @param CIS_Param_Test See @ref CIS_Param_Test_t
 * @param[out] Connection_Handle Connection handle of the CIS in the CIG.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_cig_parameters_test(uint8_t CIG_ID,
                                          uint8_t SDU_Interval_C_To_P[3],
                                          uint8_t SDU_Interval_P_To_C[3],
                                          uint8_t FT_C_To_P,
                                          uint8_t FT_P_To_C,
                                          uint16_t ISO_Interval,
                                          uint8_t Worst_Case_SCA,
                                          uint8_t Packing,
                                          uint8_t Framing,
                                          uint8_t CIS_Count,
                                          CIS_Param_Test_t CIS_Param_Test[],
                                          uint16_t Connection_Handle[]);
/**
 * @brief The HCI_LE_Create_CIS command is used by the Central's Host to create
 *        one or more CISes using the connections identified by the
 *        ACL_Connection_Handle arrayed parameter. The CIS_Count parameter is
 *        the total number of CISes created by this command. The
 *        CIS_Connection_Handle[i] parameter specifies the connection handle
 *        corresponding to the configuration of the CIS to be created and whose
 *        configuration is already stored in a CIG. The ACL_Connection_Handle[i]
 *        parameter specifies the connection handle of the ACL connection
 *        associated with each CIS to be created. The list of the
 *        ACL_Connection_Handles shall be in the same order as the list of the
 *        CIS_Connection_Handles e.g., CIS_Connection_Handle[1] will connect to
 *        the Peripheral associated with the ACL_Connection_Handle[1]. If any
 *        ACL_Connection_Handle[i] is not the handle of an existing ACL
 *        connection or any CIS_Connection_Handle[i] is not the handle of a CIS
 *        or CIS configuration, the Controller shall return the error code
 *        Unknown Connection Identifier (0x02). If the Host attempts to create a
 *        CIS that has already been created, the Controller shall return the
 *        error code Connection Already Exists (0x0B). If two different elements
 *        of the CIS_Connection_Handle arrayed parameter identify the same CIS,
 *        the Controller shall return the error code Invalid HCI Command
 *        Parameters (0x12). If the Host issues this command before all the
 *        HCI_LE_CIS_Established events from the previous use of the command
 *        have been generated, the Controller shall return the error code
 *        Command Disallowed (0x0C). If the Host issues this command on an
 *        ACL_Connection_Handle where the Controller is the Peripheral, the
 *        Controller shall return the error code Command Disallowed (0x0C).
 *        Note: The order of the CIS connection handles in this command does not
 *        relate to the order of connection handles in the return parameters of
 *        the HCI_LE_Set_CIG_Parameters command or the
 *        HCI_LE_Set_CIG_Parameters_Test command. If the Host issues this
 *        command when the Connected Isochronous Stream (Host Support) feature
 *        bit (see [Vol 6] Part B, Section 4.6.27) is not set, the Controller
 *        shall return the error code Command Disallowed (0x0C).
 * @param CIS_Count Total number of CISes to be created.
 *        Values:
 *        - 0x01 ... 0x1F
 * @param CIS_Handles See @ref CIS_Handles_t
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_create_cis(uint8_t CIS_Count,
                             CIS_Handles_t CIS_Handles[]);
/**
 * @brief The HCI_LE_Remove_CIG command is used by the Central's Host to remove
 *        the CIG identified by CIG_ID. The CIG_ID parameter contains the
 *        identifier of the CIG. This command shall delete the CIG_ID and also
 *        delete the Connection_Handles of the CIS configurations stored in the
 *        CIG. This command shall also remove the isochronous data paths that
 *        are associated with the Connection_Handles of the CIS configurations,
 *        which is equivalent to issuing the HCI_LE_Remove_ISO_Data_Path command
 *        (see Section 7.8.109). If the Host tries to remove a CIG which is in
 *        the active state, then the Controller shall return the error code
 *        Command Disallowed (0x0C). If the Host issues this command with a
 *        CIG_ID that does not exist, the Controller shall return the error code
 *        Unknown Connection Identifier (0x02).
 * @param CIG_ID Identifier of a CIG.
 *        Values:
 *        - 0x00 ... 0xEF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_remove_cig(uint8_t CIG_ID);
/**
 * @brief The HCI_LE_Accept_CIS_Request command is used by the Peripheral's Host
 *        to inform the Controller to accept the request for the CIS that is
 *        identified by the Connection_Handle. The command shall only be issued
 *        after an HCI_LE_CIS_Request event has occurred. The event contains the
 *        Connection_Handle of the CIS. If the Peripheral's Host issues this
 *        command with a Connection_Handle that does not exist, or the
 *        Connection_Handle is not for a CIS, the Controller shall return the
 *        error code Unknown Connection Identifier (0x02). If the Peripheral's
 *        Host issues this command with a Connection_Handle for a CIS that has
 *        already been established or that already has an
 *        HCI_LE_Accept_CIS_Request or HCI_LE_Reject_CIS_Request command in
 *        progress, the Controller shall return the error code Command
 *        Disallowed (0x0C). If the Central's Host issues this command, the
 *        Controller shall return the error code Command Disallowed (0x0C).
 * @param Connection_Handle Connection handle of the CIS.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_accept_cis_request(uint16_t Connection_Handle);
/**
 * @brief The HCI_LE_Reject_CIS_Request command is used by the Peripheral's Host
 *        to inform the Controller to reject the request for the CIS that is
 *        identified by the Connection_Handle. The command shall only be issued
 *        after an HCI_LE_CIS_Request event has occurred. The event contains the
 *        Connection_Handle of the CIS. When this command succeeds, the
 *        Controller shall delete the Connection_Handle of the requested CIS.
 *        The Reason command parameter indicates the reason for rejecting the
 *        CIS request. If the Peripheral's Host issues this command with a
 *        Connection_Handle that is not for a CIS, the Controller shall return
 *        the error code Unknown Connection Identifier (0x02). If the
 *        Peripheral's Host issues this command with a Connection_Handle for a
 *        CIS that has already been established or that already has an HCI_LE_-
 *        Accept_CIS_Request or HCI_LE_Reject_CIS_Request command in progress,
 *        the Controller shall return the error code Command Disallowed (0x0C).
 *        If the Central's Host issues this command, the Controller shall return
 *        the error code Command Disallowed (0x0C).
 * @param Connection_Handle Reason the CIS request was rejected. See [Vol 1]
 *        Part F, Controller Error Codes for a list of error codes and
 *        descriptions.
 * @param Reason Reason the CIS request was rejected. See [Vol 1] Part F,
 *        Controller Error Codes for a list of error codes and descriptions.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_reject_cis_request(uint16_t Connection_Handle,
                                     uint8_t Reason);
/**
 * @brief The HCI_LE_Create_BIG command is used to create a BIG with one or more
 *        BISes (see [Vol 6] Part B, Section 4.4.6). All BISes in a BIG have the
 *        same value for all parameters. The BIG_Handle contains the identifier
 *        of the BIG. This parameter is allocated by the Host and used by the
 *        Controller and the Host to identify a BIG. The Advertising_Handle
 *        identifies the associated periodic advertising train of the BIG (see
 *        [Vol 6] Part B, Section 4.4.5.1). The Num_BIS parameter contains the
 *        total number of BISes in the BIG. The SDU_Interval parameter contains
 *        the time interval of the periodic SDUs. The Max_SDU parameter contains
 *        the maximum size of an SDU. The Max_Transport_Latency parameter is the
 *        maximum transport latency (in milliseconds) as described in [Vol 6]
 *        Part G, Section 3.2.1 and [Vol 6] Part G, Section 3.2.2. This includes
 *        pre-transmissions. The RTN (Retransmission Number) parameter contains
 *        the number of times every PDU should be retransmitted, irrespective of
 *        which isochronous events the retransmissions occur in. This is a
 *        recommendation to the Controller which the Controller may ignore. The
 *        PHY parameter is a bit field that indicates the PHY used for
 *        transmission of PDUs of BISes in the BIG. The Host shall set at least
 *        one bit in this parameter and the Controller shall pick a PHY from the
 *        bits set. If the Host sets, in the PHY parameter, a bit for a PHY that
 *        the Controller does not support, including a bit that is reserved for
 *        future use, the Controller shall return the error code Unsupported
 *        Feature or Parameter Value (0x11). The Packing parameter is used to
 *        indicate the preferred method of arranging subevents of multiple
 *        BISes. The subevents can be arranged in Sequential or Interleaved
 *        arrangement. This is a recommendation to the Controller which it may
 *        ignore. This parameter shall be ignored when there is only one BIS in
 *        the BIG. The Framing parameter indicates the format for sending BIS
 *        Data PDUs. If the Framing parameter is set to 1 then BIS Data PDUs
 *        shall be Framed and when set to 0 they may be unframed (see [Vol 6]
 *        Part G, Section 1). The Encryption parameter identifies the encryption
 *        mode of the BISes. If the Encryption parameter is set to 1
 *        (encrypted), the Broadcast_Code is used in the encryption of payloads
 *        (see [Vol 6] Part B, Section 4.4.6.10). The Broadcast_Code parameter
 *        is used to generate the encryption key for encrypting payloads of all
 *        BISes. When the Encryption parameter is set to 0 (unencrypted), the
 *        Broadcast_Code parameter shall be set to zero by the Host and ignored
 *        by the Controller. If the Controller cannot create all BISes of the
 *        BIG or if Num_BIS exceeds the maximum value supported by the
 *        Controller, it shall return the error code Connection Rejected due to
 *        Limited Resources (0x0D). If the Advertising_Handle does not identify
 *        a periodic advertising train or the periodic advertising train is
 *        associated with another BIG, the Controller shall return the error
 *        code Unknown Advertising Identifier (0x42). If the Host issues this
 *        command with a BIG_Handle for a BIG that is already created, the
 *        Controller shall return the error code Command Disallowed (0x0C). If
 *        the Host specifies an invalid combination of BIG parameters, the
 *        Controller shall return an error which should use the error code
 *        Unsupported Feature or Parameter Value (0x11).
 * @param BIG_Handle Used to identify the BIG.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Advertising_Handle Used to identify the periodic advertising train.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Num_BIS Total number of BISes in the BIG.
 *        Values:
 *        - 0x01 ... 0x1F
 * @param SDU_Interval The interval, in microseconds, of periodic SDUs.
 *        Values:
 *        - 0x0000FF ... 0x0FFFFF
 * @param Max_SDU Maximum size of an SDU, in octets.
 *        Values:
 *        - 0x0001 ... 0x0FFF
 * @param Max_Transport_Latency Maximum transport latency, in milliseconds.
 *        Values:
 *        - 0x0005 ... 0x0FA0
 * @param RTN The number of times that every BIS Data PDU should be
 *        retransmitted.
 *        Values:
 *        - 0x00 ... 0x1E
 * @param PHY Transmitter PHY of packets.
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x02: LE_2M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param Packing Used to indicate the preferred method of arranging subevents
 *        of multiple BISes.
 *        Values:
 *        - 0x00: Sequential
 *        - 0x01: Interleaved
 * @param Framing The format for sending BIS Data PDUs.
 *        Values:
 *        - 0x00: Unframed
 *        - 0x01: Framed
 * @param Encryption The encryption mode of the BISes.
 *        Values:
 *        - 0x00: Unencrypted
 *        - 0x01: Encrypted
 * @param Broadcast_Code 128-bit code used for deriving the session key for
 *        decrypting payloads of BISes in the BIG.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_create_big(uint8_t BIG_Handle,
                             uint8_t Advertising_Handle,
                             uint8_t Num_BIS,
                             uint8_t SDU_Interval[3],
                             uint16_t Max_SDU,
                             uint16_t Max_Transport_Latency,
                             uint8_t RTN,
                             uint8_t PHY,
                             uint8_t Packing,
                             uint8_t Framing,
                             uint8_t Encryption,
                             uint8_t Broadcast_Code[16]);
/**
 * @brief The HCI_LE_Create_BIG_Test command should only be used for testing
 *        purposes. The command is used to create one or more BISes of a BIG.
 *        All BISes in the BIG have the same values for all parameters.
 * @param BIG_Handle Used to identify the BIG.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Advertising_Handle Used to identify the periodic advertising train.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Num_BIS Total number of BISes in the BIG.
 *        Values:
 *        - 0x01 ... 0x1F
 * @param SDU_Interval The interval, in microseconds, of periodic SDUs.
 *        Values:
 *        - 0x0000FF ... 0x0FFFFF
 * @param ISO_Interval The time between consecutive BIG anchor points. Time = N
 *        * 1.25 ms Time Range: 5 ms to 4 s
 *        Values:
 *        - 0x0004 (5.00 ms)  ... 0x0C80 (4000.00 ms) 
 * @param NSE The total number of subevents in each interval of each BIS in the
 *        BIG.
 *        Values:
 *        - 0x01 ... 0x1F
 * @param Max_SDU Maximum size of an SDU, in octets.
 *        Values:
 *        - 0x0001 ... 0x0FFF
 * @param Max_PDU Maximum size, in octets, of payload
 *        Values:
 *        - 0x0001 ... 0x00FB
 * @param PHY Transmitter PHY of packets.
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x02: LE_2M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param Packing Used to indicate the preferred method of arranging subevents
 *        of multiple BISes.
 *        Values:
 *        - 0x00: Sequential
 *        - 0x01: Interleaved
 * @param Framing The format for sending BIS Data PDUs.
 *        Values:
 *        - 0x00: Unframed
 *        - 0x01: Framed
 * @param BN The number of new payloads in each interval for each BIS.
 *        Values:
 *        - 0x01 ... 0x07
 * @param IRC The number of times the scheduled payload(s) are transmitted in a
 *        given event.
 *        Values:
 *        - 0x01 ... 0x0F
 * @param PTO Offset used for pre-transmissions.
 *        Values:
 *        - 0x00 ... 0x0F
 * @param Encryption The encryption mode of the BISes.
 *        Values:
 *        - 0x00: Unencrypted
 *        - 0x01: Encrypted
 * @param Broadcast_Code 128-bit code used for deriving the session key for
 *        decrypting payloads of BISes in the BIG.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_create_big_test(uint8_t BIG_Handle,
                                  uint8_t Advertising_Handle,
                                  uint8_t Num_BIS,
                                  uint8_t SDU_Interval[3],
                                  uint16_t ISO_Interval,
                                  uint8_t NSE,
                                  uint16_t Max_SDU,
                                  uint16_t Max_PDU,
                                  uint8_t PHY,
                                  uint8_t Packing,
                                  uint8_t Framing,
                                  uint8_t BN,
                                  uint8_t IRC,
                                  uint8_t PTO,
                                  uint8_t Encryption,
                                  uint8_t Broadcast_Code[16]);
/**
 * @brief The HCI_LE_Terminate_BIG command is used to terminate a BIG identified
 *        by the BIG_Handle parameter. The command also terminates the
 *        transmission of all BISes of the BIG, destroys the associated
 *        connection handles of the BISes in the BIG and removes the data paths
 *        for all BISes in the BIG.
 * @param BIG_Handle Used to identify the BIG.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Reason Reason for disconnection. See Error Codes.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_terminate_big(uint8_t BIG_Handle,
                                uint8_t Reason);
/**
 * @brief The HCI_LE_BIG_Create_Sync command is used to synchronize to a BIG
 *        described in the periodic advertising train specified by the
 *        Sync_Handle parameter.
 * @param BIG_Handle Used to identify the BIG.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Sync_Handle Identifier of the periodic advertising train.
 *        Values:
 *        - 0x0000 ... 0x00EF
 * @param Encryption The encryption mode of the BIG.
 *        Values:
 *        - 0x00: Unencrypted
 *        - 0x01: Encrypted
 * @param Broadcast_Code 128-bit code used for deriving the session key for
 *        decrypting payloads of BISes in the BIG.
 * @param MSE The MSE (Maximum Subevents) parameter is the maximum number of
 *        subevents that a Controller should use to receive data payloads in
 *        each interval for a BIS. The Host should set MSE to reduce the maximum
 *        continuous radio receiving time for a Synchronized Receiver with
 *        limited battery capacity.
 *        Values:
 *        - 0x00: Any number of subevents
 *        - 0x01 ... 0x1F
 * @param BIG_Sync_Timeout The BIG_Sync_Timeout parameter specifies the maximum
 *        permitted time between successful receptions of BIS PDUs. If this time
 *        is exceeded, synchronization is lost. When the Controller establishes
 *        synchronization and if the BIG_Sync_Timeout set by the Host is less
 *        than 6 * ISO_Interval, the Controller shall set the timeout to 6 *
 *        ISO_Interval.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x4000 (163840 ms) 
 * @param Num_BIS Total number of BISes to synchronize.
 *        Values:
 *        - 0x01 ... 0x1F
 * @param BIS List of indices of BISes.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_big_create_sync(uint8_t BIG_Handle,
                                  uint16_t Sync_Handle,
                                  uint8_t Encryption,
                                  uint8_t Broadcast_Code[16],
                                  uint8_t MSE,
                                  uint16_t BIG_Sync_Timeout,
                                  uint8_t Num_BIS,
                                  uint8_t BIS[]);
/**
 * @brief The HCI_LE_BIG_Terminate_Sync command is used to stop synchronizing or
 *        cancel the process of synchronizing to the BIG identified by the
 *        BIG_Handle parameter. The command also terminates the reception of
 *        BISes in the BIG specified in the HCI_LE_BIG_Create_Sync command,
 *        destroys the associated connection handles of the BISes in the BIG and
 *        removes the data paths for all BISes in the BIG.
 * @param BIG_Handle Used to identify the BIG.
 *        Values:
 *        - 0x00 ... 0xEF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_big_terminate_sync(uint8_t BIG_Handle);
/**
 * @brief This command is used to read the Sleep Clock Accuracy (SCA) of the
 *        peer device. The Connection_Handle parameter is the connection handle
 *        of the ACL connection. If the Host sends this command with a
 *        Connection_Handle that does not exist, or the Connection_Handle is not
 *        for an ACL the Controller shall return the error code Unknown
 *        Connection Identifier (0x02). If the Host sends this command and the
 *        peer device does not support the Sleep Clock Accuracy Updates feature,
 *        the Controller shall return the error code Unsupported Feature or
 *        Parameter Value (0x11) in the  HCI_LE_Request_Peer_SCA_Complete event.
 *        If the Host issues this command when the Controller is aware (e.g.,
 *        through a previous feature exchange) that the peer device's Link Layer
 *        does not support the Sleep Clock Accuracy Updates feature, the
 *        Controller shall return the error code Unsupported Remote Feature
 *        (0x1A). When the HCI_LE_Request_Peer_SCA command has completed, the
 *        HCI_LE_Request_Peer_SCA_Complete event shall be generated.
 * @param Connection_Handle Connection handle of the ACL.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_request_peer_sca(uint16_t Connection_Handle);
/**
 * @brief The HCI_LE_Setup_ISO_Data_Path command is used to identify and create
 *        the isochronous data path between the Host and the Controller for an
 *        established CIS or BIS identified by the Connection_Handle parameter.
 *        This command can also be used to configure a codec for each data path.
 * @param Connection_Handle Connection handle of the CIS or BIS.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Data_Path_Direction The Data_Path_Direction parameter specifies the
 *        direction for which the data path is being configured. The input and
 *        output directions are defined from the perspective of the Controller,
 *        so "input" refers to data flowing from the Host to the Controller.
 *        Values:
 *        - 0x00: Input
 *        - 0x01: Output
 * @param Data_Path_ID The Data_Path_ID parameter specifies the data transport
 *        path used. When set to 0x00, the data path shall be over the HCI
 *        transport. When set to 0xFF the path shall be disabled. When set to a
 *        value in the range 0x01 to 0xFE, the data path shall use a vendor-
 *        specific transport interface (e.g., a PCM interface) with logical
 *        transport numbers. The meanings of these logical transport numbers are
 *        vendor-specific.
 *        Values:
 *        - 0x00: HCI
 *        - 0x01 ... 0xFE
 *        - 0xFF: Disabled
 * @param Codec_ID The Codec_ID parameter specifies the coding format used over
 *        the air. Octet 0: See Assigned Numbers for Coding Format. Octets 1 to
 *        2: Company ID, see Assigned Numbers for Company Identifier. Shall be
 *        ignored if octet 0 is not 0xFF. Octets 3 to 4: Vendor-defined codec
 *        ID. Shall be ignored if octet 0 is not 0xFF.
 * @param Controller_Delay Controller delay in microseconds. When
 *        Data_Path_Direction is set to 0x00 (input), the Controller_Delay
 *        parameter specifies the delay at the data source from the reference
 *        time of an SDU to the CIG reference point (see Bluetooth Core v5.2
 *        [Vol 6] Part B, Section 4.5.14.1) or BIG anchor point (see Core v5.2
 *        [Vol 6] Part B, Section 4.4.6.4). When Data_Path_Direction is set to
 *        0x01 (output), Controller_Delay specifies the delay from the CIG
 *        synchronization point or BIG synchronization point to the point in
 *        time at which the Controller begins to transfer the corresponding data
 *        to the data path interface.
 *        Values:
 *        - 0x000000 ... 0x3D0900
 * @param Codec_Configuration_Length Length of codec configuration.
 * @param Codec_Configuration The Codec_Configuration parameter specifies codec-
 *        specific configuration information for the specified direction.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_setup_iso_data_path(uint16_t Connection_Handle,
                                      uint8_t Data_Path_Direction,
                                      uint8_t Data_Path_ID,
                                      uint8_t Codec_ID[5],
                                      uint8_t Controller_Delay[3],
                                      uint8_t Codec_Configuration_Length,
                                      uint8_t Codec_Configuration[]);
/**
 * @brief The HCI_LE_Remove_ISO_Data_Path command is used to remove the input
 *        and/or output data path(s) associated with a CIS or BIS identified by
 *        the Connection_Handle parameter.
 * @param Connection_Handle Connection handle of the CIS or BIS.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Data_Path_Direction The Data_Path_Direction parameter specifies which
 *        directions are to have the data path removed.
 *        Flags:
 *        - 0x01: Input
 *        - 0x02: Output
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_remove_iso_data_path(uint16_t Connection_Handle,
                                       uint8_t Data_Path_Direction);
/**
 * @brief The HCI_LE_ISO_Transmit_Test command should only be used in the ISO
 *        Test mode and only for testing purposes. The command is used to
 *        configure an established CIS or BIS specified by the Connection_Handle
 *        parameter, and transmit test payloads which are generated by the
 *        Controller. When using this command for a CIS, the Host shall set up a
 *        CIG before invoking this command. When using this command for a BIS,
 *        the Host shall create the BIG before invoking this command. This
 *        command applies to all BISes in the BIG.
 * @param Connection_Handle Connection handle of the CIS or BIS.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Payload_Type The Payload_Type parameter defines the configuration of
 *        SDUs in the payload.
 *        Values:
 *        - 0x00: ZERO_LENGTH_PAYLOAD
 *        - 0x01: VARIABLE_LENGTH_PAYLOAD
 *        - 0x02: MAXIMUM_LENGTH_PAYLOAD
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_iso_transmit_test(uint16_t Connection_Handle,
                                    uint8_t Payload_Type);
/**
 * @brief The HCI_LE_ISO_Receive_Test command should only be used in the ISO
 *        Test mode and only for testing purposes. The command is used to
 *        configure an established CIS or a synchronized BIG specified by the
 *        Connection_Handle parameter to receive payloads. When using this
 *        command for a BIS, the Host shall synchronize with a BIG using the
 *        HCI_LE_BIG_Create_Sync command before invoking this command.
 * @param Connection_Handle Connection handle of the CIS or BIS.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Payload_Type The Payload_Type parameter defines the configuration of
 *        SDUs in the payload.
 *        Values:
 *        - 0x00: ZERO_LENGTH_PAYLOAD
 *        - 0x01: VARIABLE_LENGTH_PAYLOAD
 *        - 0x02: MAXIMUM_LENGTH_PAYLOAD
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_iso_receive_test(uint16_t Connection_Handle,
                                   uint8_t Payload_Type);
/**
 * @brief The HCI_LE_ISO_Read_Test_Counters command should only be used in the
 *        ISO Test mode and only for testing purposes. The command is used to
 *        read the test counters (see Core 5.2 [Vol 6] Part B, Section 7) in the
 *        Controller which is configured in ISO Receive Test mode for a CIS or
 *        BIS specified by the Connection_Handle. Reading the test counters does
 *        not reset the test counters.
 * @param Connection_Handle Connection handle of the CIS or BIS.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param[out] Received_Packet_Count Number in the Received_Packet_Count.
 * @param[out] Missed_Packet_Count Number in the Missed_Packet_Count.
 * @param[out] Failed_Packet_Count Number in the Failed_Packet_Count.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_iso_read_test_counters(uint16_t Connection_Handle,
                                         uint32_t *Received_Packet_Count,
                                         uint32_t *Missed_Packet_Count,
                                         uint32_t *Failed_Packet_Count);
/**
 * @brief The HCI_LE_ISO_Test_End command should only be used in the ISO Test
 *        mode and only for testing purposes. The command is used to terminate
 *        the ISO Transmit and/or Receive Test mode for a CIS or BIS specified
 *        by the Connection_Handle parameter but does not terminate the CIS or
 *        BIS. When the Host terminates the ISO Test mode for a CIS or BIS that
 *        is set to ISO Transmit Test mode only, the test counters in the return
 *        parameters shall be set to zero. When the Host terminates the ISO Test
 *        mode for a CIS or BIS that is set to the ISO Receive Test mode, the
 *        return parameters contain the values of the test counters as defined
 *        in [Vol 6] Part B, Section 7.
 * @param Connection_Handle Connection handle of the CIS or BIS.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param[out] Received_Packet_Count Number in the Received_Packet_Count.
 * @param[out] Missed_Packet_Count Number in the Missed_Packet_Count.
 * @param[out] Failed_Packet_Count Number in the Failed_Packet_Count.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_iso_test_end(uint16_t Connection_Handle,
                               uint32_t *Received_Packet_Count,
                               uint32_t *Missed_Packet_Count,
                               uint32_t *Failed_Packet_Count);
/**
 * @brief The HCI_LE_Set_Host_Feature command is used by the Host to set or
 *        clear a bit controlled by the Host in the Link Layer FeatureSet stored
 *        in the Controller (see [Vol 6] Part B, Section 4.6). The Bit_Number
 *        parameter specifies the bit position in the FeatureSet. The Bit_Value
 *        parameter specifies whether the feature is enabled or disabled. If
 *        Bit_Number specifies a feature bit that is not controlled by the Host,
 *        the Controller shall return the error code Unsupported Feature or
 *        Parameter Value (0x11). If Bit_Value is set to 0x01 and Bit_Number
 *        specifies a feature bit that requires support of a feature that the
 *        Controller does not support, the Controller shall return the error
 *        code Unsupported Feature or Parameter Value (0x11). If the Host issues
 *        this command while the Controller has a connection to another device,
 *        the Controller shall return the error code Command Disallowed (0x0C).
 * @param Bit_Number Bit position in the FeatureSet.
 *        Values:
 *        - 0x00 ... 0x3F
 * @param Bit_Value If 0, the Host feature is disabled, if 1 the Host feature is
 *        enablded.
 *        Values:
 *        - 0x00: DISABLED
 *        - 0x01: ENABLED
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_host_feature(uint8_t Bit_Number,
                                   uint8_t Bit_Value);
/**
 * @brief This command returns the values of various counters related to link
 *        quality that are associated with the isochronous stream specified by
 *        the Connection_Handle parameter. This command may be issued on both
 *        the central and peripheral if the connection handle identifies a CIS
 *        and on the Synchronized Receiver if the connection handle identifies a
 *        BIS.
 * @param Connection_Handle Connection handle of the CIS or BIS.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param[out] Tx_UnACKed_Packets Value of the Tx_UnACKed_Packets counter.
 *             Incremented when the Link Layer does not receive an
 *             acknowledgment for a CIS Data PDU that it transmitted at least
 *             once by its flush point (see Core 5.2 [Vol 6] Part B, Section
 *             4.5.13.5).
 * @param[out] Tx_Flushed_Packets Value of the Tx_Flushed_Packets counter.
 *             Incremented when the Link Layer does not transmit a specific
 *             payload by its flush point.
 * @param[out] Tx_Last_Subevent_Packets Value of the Tx_Last_Subevent_Packets
 *             counter. Incremented when the Link Layer transmits a CIS Data PDU
 *             in the last subevent of a CIS event.
 * @param[out] Retransmitted_Packets Value of the Retransmitted_Packets counter.
 *             Incremented when the Link Layer retransmits a CIS Data PDU.
 * @param[out] CRC_Error_Packets Value of the CRC_Error_Packets counter.
 *             Incremented when the Link Layer receives a packet with a CRC
 *             error.
 * @param[out] Rx_Unreceived_Packets Value of the Rx_Unreceived_Packets counter.
 *             Incremented when the Link Layer does not receive a specific
 *             payload by its flush point (on a CIS) or the end of the event it
 *             is associated with (on a BIS; see Core v5.2 [Vol 6] Part B,
 *             Section 4.4.6.6).
 * @param[out] Duplicate_Packets Value of the Duplicate_Packets counter.
 *             Incremented when the Link Layer receives a retransmission of a
 *             CIS Data PDU.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_iso_link_quality(uint16_t Connection_Handle,
                                        uint32_t *Tx_UnACKed_Packets,
                                        uint32_t *Tx_Flushed_Packets,
                                        uint32_t *Tx_Last_Subevent_Packets,
                                        uint32_t *Retransmitted_Packets,
                                        uint32_t *CRC_Error_Packets,
                                        uint32_t *Rx_Unreceived_Packets,
                                        uint32_t *Duplicate_Packets);
/**
 * @brief Read the current and maximum transmit power levels of the local
 *        Controller on the ACL connection identified by the Connection_Handle
 *        parameter and the PHY indicated by the PHY parameter.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param PHY PHY associated with the connection  (not necessarily the currently
 *        used one).
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY_S8
 *        - 0x04: LE_CODED_PHY_S2
 * @param[out] Current_Transmit_Power_Level Current TX power level (dBm).
 *             Values:
 *             - -127 ... 20
 *             - 127: NA
 * @param[out] Max_Transmit_Power_Level Maximum TX power level (dBm).
 *             Values:
 *             - -127 ... 20
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_enhanced_read_transmit_power_level(uint16_t Connection_Handle,
                                                     uint8_t PHY,
                                                     int8_t *Current_Transmit_Power_Level,
                                                     int8_t *Max_Transmit_Power_Level);
/**
 * @brief Read the transmit power level used by the remote Controller on the ACL
 *        connection that is identified by the Connection_Handle parameter and
 *        the PHY indicated by the PHY parameter. Initiate a Power Control
 *        Request procedure to obtain the remote transmit power level if no
 *        prior value is available or used.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param PHY PHY associated with the connection  (not necessarily the currently
 *        used one).
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY_S8
 *        - 0x04: LE_CODED_PHY_S2
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_read_remote_transmit_power_level(uint16_t Connection_Handle,
                                                   uint8_t PHY);
/**
 * @brief Set the path loss threshold reporting parameters for the ACL
 *        connection identified by the Connection_Handle parameter.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param High_Threshold High threshold for the path loss. Units: dB.
 *        Values:
 *        - 0 ... 254
 *        - 255: UNUSED
 * @param High_Hysteresis Hysteresis value for the high threshold. Units: dB.
 * @param Low_Threshold Low threshold for the path loss. Units: dB.
 * @param Low_Hysteresis Hysteresis value for the low threshold. Units: dB.
 * @param Min_Time_Spent Minimum time in number of connection events to be
 *        observed once the path crosses the threshold before an event is
 *        generated.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_path_loss_reporting_parameters(uint16_t Connection_Handle,
                                                     uint8_t High_Threshold,
                                                     uint8_t High_Hysteresis,
                                                     uint8_t Low_Threshold,
                                                     uint8_t Low_Hysteresis,
                                                     uint16_t Min_Time_Spent);
/**
 * @brief Enable or disable path loss reporting for the ACL connection
 *        identified by the Connection_Handle parameter. Initiate a new Power
 *        Control Request procedure to obtain the remote transmit power level if
 *        no prior value is available or used and no prior Power Control Request
 *        procedure has been initiated. Path loss reporting is disabled when the
 *        connection is first created.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Enable Enable (1) or disable (0) reportinig.
 *        Values:
 *        - 0x00: DISABLE
 *        - 0x01: ENABLE
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_path_loss_reporting_enable(uint16_t Connection_Handle,
                                                 uint8_t Enable);
/**
 * @brief Enable or disable the reporting of transmit power level changes in the
 *        local and remote Controllers for the ACL connection identified by the
 *        Connection_Handle parameter. Initiate a new Power Control Request
 *        procedure to obtain the remote transmit power level if Remote_Enable
 *        is 0x01, and no prior value is available or used, and no prior Power
 *        Control Request procedure has been initiated.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Local_Enable Enable (1) or disable (0) local transmit power reports.
 *        Values:
 *        - 0x00: DISABLE
 *        - 0x01: ENABLE
 * @param Remote_Enable Enable (1) or disable (0) remote transmit power reports.
 *        Values:
 *        - 0x00: DISABLE
 *        - 0x01: ENABLE
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_transmit_power_reporting_enable(uint16_t Connection_Handle,
                                                      uint8_t Local_Enable,
                                                      uint8_t Remote_Enable);
/**
 * @brief The HCI_LE_Set_Data_Related_Address_Changes command specifies
 *        circumstances when the Controller shall refresh any Resolvable Private
 *        Address used by the advertising set identified by the
 *        Advertising_Handle parameter, whether or not the address timeout
 *        period has been reached. This command may be used while advertising is
 *        enabled. The Change_Reasons parameter specifies the reason(s) for
 *        refreshing addresses. The default when an advertising set is created,
 *        or if legacy advertising commands (see Section 3.1.1) are used, is for
 *        all bits to be clear. If extended advertising commands (see Section
 *        3.1.1) are being used and the advertising set corresponding to the
 *        Advertising_Handle parameter does not exist, or if no command
 *        specified in Table 3.2 has been used, then the Controller shall return
 *        the error code Unknown Advertising Identifier (0x42). If legacy
 *        advertising commands are being used, the Controller shall ignore the
 *        Advertising_Handle parameter.
 * @param Advertising_Handle Used to identify an advertising set.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Change_Reasons Bitmap associated with the reasons to refresh the
 *        Resolvable Private Addresses used by the advertising set. If bit 0 is
 *        set, change the address whenever the advertising data changes. If bit
 *        1 is set, change the address whenever the scan response data changes.
 *        Flags:
 *        - 0x01: ADV_DATA_CHANGES
 *        - 0x02: SCAN_RESP_DATA_CHANGES
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_data_related_address_changes(uint8_t Advertising_Handle,
                                                   uint8_t Change_Reasons);
/**
 * @brief The HCI_LE_Set_Default_Subrate command is used by the Host to set the
 *        initial values for the acceptable parameters for subrating requests,
 *        as defined by the HCI_LE Subrate_Request command, for all future ACL
 *        connections where the Controller is the Central. This command does not
 *        affect any existing connection. The parameters have the same meanings
 *        and restrictions as those in the HCI_LE_Subrate_Request command.
 * @param Subrate_Min Minimum subrate factor allowed in requests by a
 *        Peripheral.
 *        Values:
 *        - 0x0001 ... 0x01F4
 * @param Subrate_Max Maximum subrate factor allowed in requests by a
 *        Peripheral.
 *        Values:
 *        - 0x0001 ... 0x01F4
 * @param Max_Latency Maximum Peripheral latency allowed in requests by a
 *        Peripheral, in units of subrated connection intervals.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Continuation_Number Minimum number of underlying connection events to
 *        remain active after a packet containing a Link Layer PDU with a non-
 *        zero Length field is sent or received in requests by a Peripheral.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Supervision_Timeout Maximum supervision timeout allowed in requests by
 *        a Peripheral. Time = N x 10 ms.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_default_subrate(uint16_t Subrate_Min,
                                      uint16_t Subrate_Max,
                                      uint16_t Max_Latency,
                                      uint16_t Continuation_Number,
                                      uint16_t Supervision_Timeout);
/**
 * @brief The HCI_LE_Subrate_Request command is used by a Central or a
 *        Peripheral to request a change to the subrating factor and/or other
 *        parameters (see Core Vol 6 Part B, Section 4.5.1) applied to an
 *        existing connection using the Connection Subrate Update procedure. The
 *        Subrate_Min and Subrate_Max parameters specify the range of acceptable
 *        subrating factors being requested. The Max_Latency parameter specifies
 *        the maximum Peripheral latency in units of subrated connection events.
 *        The same maximum shall apply irrespective of the subrating factor
 *        actually chosen. The Continuation_Number parameter specifies the
 *        number of underlying connection intervals to remain active after a
 *        packet (other than an empty packet) is transmitted or received. The
 *        Supervision_Timeout parameter specifies the link supervision timeout
 *        for the connection. The Supervision_Timeout, in milliseconds, shall be
 *        greater than 2 x current connection interval x Subrate_Max x
 *        (Max_Latency + 1). If this command is issued on the Central, the
 *        following rules shall apply when the Controller initiates the
 *        Connection Subrate Update procedure (see Core Vol 6 Part B, Section
 *        5.1.19): * The Peripheral latency shall be less than or equal to
 *        Max_Latency. * The subrate factor shall be between Subrate_Min and
 *        Subrate_Max. * The continuation number shall be equal to the lesser of
 *        Continuation_- Number and (subrate factor - 1). * The connection
 *        supervision timeout shall be equal to Supervision_Timeout. If this
 *        command is issued on the Central, it also sets the acceptable
 *        parameters for requests from the Peripheral (see Core Vol 6 Part B,
 *        Section 5.1.20). The acceptable parameters set by this command
 *        override those provided via the HCI_LE_Set_Default_Subrate command or
 *        any values set by previous uses of this command on the same
 *        connection.  If this command is issued on the Peripheral, the
 *        following rules shall apply when the Controller initiates the
 *        Connection Subrate Request procedure: * The Peripheral latency shall
 *        be less than or equal to Max_Latency. * The minimum and maximum
 *        subrate factors shall be between Subrate_Min and Subrate_Max. * The
 *        continuation number shall be equal to the lesser of
 *        Continuation_Number and (maximum subrate factor - 1). * The connection
 *        supervision timeout shall be equal to Supervision_Timeout. If the
 *        Connection_Handle parameter does not identify a current ACL
 *        connection, the Controller shall return the error code Unknown
 *        Connection Identifier (0x02). If the Host issues this command with
 *        parameters such that Subrate_Max x (Max_Latency + 1) is greater than
 *        500 or the current connection interval x Subrate_ Max x (Max_Latency +
 *        1) is greater than or equal to half the Supervision_ Timeout
 *        parameter, the Controller shall return the error code Invalid HCI
 *        Command Parameters (0x12). If the Host issues this command with
 *        Subrate_Max less than Subrate_Min, the Controller shall return the
 *        error code Invalid HCI Command Parameters (0x12). If the Host issues
 *        this command with Continuation_Number greater than or equal to
 *        Subrate_Max, then the Controller shall return the error code Invalid
 *        HCI Command Parameters (0x12). If the Central's Host issues this
 *        command when the Connection Subrating (Host Support) bit is not set in
 *        the Peripheral's FeatureSet, the Controller shall return the error
 *        code Unsupported Remote Feature (0x1A).
 * @param Connection_Handle Connection handle of the ACL.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Subrate_Min Minimum subrate factor to be applied to the underlying
 *        connection interval.
 *        Values:
 *        - 0x0001 ... 0x01F4
 * @param Subrate_Max Maximum subrate factor to be applied to the underlying
 *        connection interval.
 *        Values:
 *        - 0x0001 ... 0x01F4
 * @param Max_Latency Maximum Peripheral latency for the connection in units of
 *        subrated connection intervals.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Continuation_Number Minimum number of underlying connection events to
 *        remain active after a packet containing a Link Layer PDU with a non-
 *        zero Length field is sent or received.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Supervision_Timeout Supervision timeout for this connection. Time = N
 *        x 10 ms.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_subrate_request(uint16_t Connection_Handle,
                                  uint16_t Subrate_Min,
                                  uint16_t Subrate_Max,
                                  uint16_t Max_Latency,
                                  uint16_t Continuation_Number,
                                  uint16_t Supervision_Timeout);
/**
 * @brief The LE_Set_Extended_Advertising_Parameters command is used by the Host
 *        to set the advertising parameters. The Advertising_Handle parameter
 *        identifies the advertising set whose parameters are being configured.
 *        The Advertising_Event_Properties parameter describes the type of
 *        advertising event that is being configured and its basic properties.
 *        The type shall be one supported by the Controller.
 * @param Advertising_Handle The Advertising_Handle parameter identifies the
 *        advertising set whose parameters are being configured.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Advertising_Event_Properties The Advertising_Event_Properties
 *        parameter describes the type of advertising event that is being
 *        configured and its basic properties. The type shall be one supported
 *        by the Controller. Bits: 0 Connectable advertising 1 Scannable
 *        advertising 2 Directed advertising 3 High Duty Cycle Directed
 *        Connectable advertising (<= 3.75 ms Advertising Interval) 4 Use legacy
 *        advertising PDUs 5 Omit advertiser's address from all PDUs ("anonymous
 *        advertising") 6 Include TxPower in the extended header of the
 *        advertising PDU
 *        Flags:
 *        - 0x0001: Connectable
 *        - 0x0002: Scannable
 *        - 0x0004: Directed
 *        - 0x0008: HDC Directed Connectable
 *        - 0x0010: Legacy
 *        - 0x0020: Anonymous
 *        - 0x0040: TxPower in ext header
 * @param Primary_Advertising_Interval_Min Minimum advertising interval for
 *        undirected and low duty cycle directed advertising. Time = N * 0.625
 *        ms; Time Range: 20 ms to 10,485.759375 s.
 *        Values:
 *        - 0x000020 (20.000 ms)  ... 0xFFFFFF (10485759.375 ms) 
 * @param Primary_Advertising_Interval_Max Maximum advertising interval for
 *        undirected and low duty cycle directed advertising. Time = N * 0.625
 *        ms; Time Range: 20 ms to 10,485.759375 s.
 *        Values:
 *        - 0x000020 (20.000 ms)  ... 0xFFFFFF (10485759.375 ms) 
 * @param Primary_Advertising_Channel_Map The Primary_Advertising_Channel_Map is
 *        a bit field that indicates the advertising channels that shall be used
 *        when transmitting advertising packets. At least one channel bit shall
 *        be set in the Primary_Advertising_Channel_Map parameter.
 *        Flags:
 *        - 0x01: CH_37
 *        - 0x02: CH_38
 *        - 0x04: CH_39
 * @param Own_Address_Type The Own_Address_Type parameter specifies the type of
 *        address being used in the advertising packets. For random addresses,
 *        the address is specified by the LE_Set_Advertising_Set_Random_Address
 *        command.  0x00 Public Device Address 0x01 Random Device Address 0x02
 *        Controller generates the Resolvable Private Address based on the local
 *        IRK from the resolving list. If the resolving list contains no
 *        matching entry, use the public address. 0x03 Controller generates the
 *        Resolvable Private Address based on the local IRK from the resolving
 *        list. If the resolving list contains no matching entry, use the random
 *        address from LE_Set_Advertising_Set_Random_Address. All other values
 *        Reserved for future use
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Resolvable Private Address / Public Address
 *        - 0x03: Resolvable Private Address / Random Address
 * @param Peer_Address_Type Peer Address type
 *        Values:
 *        - 0x00: Public Device Address or Public Identity Address
 *        - 0x01: Random Device Address or Random (static) Identity Address
 * @param Peer_Address Public Device Address, Random Device Address, Public
 *        Identity Address, or Random (static) Identity Address of the device to
 *        be connected.
 * @param Advertising_Filter_Policy Advertising Filter Policy. This parameter is
 *        ignored when directed advertising is enabled.  0x00 Process scan and
 *        connection requests from all devices (i.e., the Filter Accept List is
 *        not in use) 0x01 Process connection requests from all devices and scan
 *        requests only from devices that are in the Filter Accept List 0x02
 *        Process scan requests from all devices and connection requests only
 *        from devices that are in the Filter Accept List. 0x03 Process scan and
 *        connection requests only from devices in the Filter Accept List. All
 *        other values are reserved for future use
 *        Values:
 *        - 0x00: HCI_ADV_FILTER_NONE
 *        - 0x01: HCI_ADV_FILTER_ACCEPT_LIST_SCAN
 *        - 0x02: HCI_ADV_FILTER_ACCEPT_LIST_CONNECT
 *        - 0x03: HCI_ADV_FILTER_ACCEPT_LIST_SCAN_CONNECT
 * @param Advertising_Tx_Power Units: dBm  The Advertising_Tx_Power parameter
 *        indicates the maximum power level at which the advertising packets are
 *        to be transmitted on the advertising channels. The Controller shall
 *        choose a power level lower than or equal to the one specified by the
 *        Host.
 *        Values:
 *        - -127 ... 126
 *        - 127: No preference
 * @param Primary_Advertising_PHY The Primary_Advertising_PHY parameter
 *        indicates the PHY on which the advertising packets are transmitted on
 *        the primary advertising channel. If legacy advertising PDUs are being
 *        used, the Primary_Advertising_PHY shall indicate the LE 1M PHY.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x03: LE_CODED_PHY
 * @param Secondary_Advertising_Max_Skip The Secondary_Advertising_Max_Skip
 *        parameter is the maximum number of advertising events that can be
 *        skipped before the AUX_ADV_IND can be sent. 0x00 AUX_ADV_IND shall be
 *        sent prior to the next advertising event 0x01-0xFF Maximum advertising
 *        events the Controller can skip before sending the AUX_ADV_IND packets
 *        on the secondary advertising channel
 *        Values:
 *        - 0x00 ... 0xFF
 * @param Secondary_Advertising_PHY The Secondary_Advertising_PHY parameter
 *        indicates the PHY on which the advertising packets are transmitted on
 *        the secondary advertising channel.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY
 * @param Advertising_SID The Advertising_SID parameter specifies the value to
 *        be transmitted in the Advertising SID subfield of the ADI field of the
 *        Extended Header of those advertising channel PDUs that have an ADI
 *        field. If the advertising set only uses PDUs that do not contain an
 *        ADI field, Advertising_SID is ignored.
 *        Values:
 *        - 0x00 ... 0x0F
 * @param Scan_Request_Notification_Enable The Scan_Request_Notification_Enable
 *        parameter indicates whether the Controller shall send notifications
 *        upon the receipt of a scan request PDU that is in response to an
 *        advertisement from the specified advertising set that contains its
 *        device address and is from a scanner that is allowed by the
 *        advertising filter policy.
 *        Values:
 *        - 0x00: Scan request notifications disabled
 *        - 0x01: Scan request notifications enabled
 * @param Primary_Advertising_PHY_Options Preference or requirements on coding
 *        scheme when transmitting on Primary Advertising Physical Channel.
 *        Values:
 *        - 0x00: CODED_PHY_NO_PREFERENCE
 *        - 0x01: CODED_PHY_S2_PREFERRED
 *        - 0x02: CODED_PHY_S8_PREFERRED
 *        - 0x03: CODED_PHY_S2_REQUIRED
 *        - 0x04: CODED_PHY_S8_REQUIRED
 * @param Secondary_Advertising_PHY_Options Preference or requirements on coding
 *        scheme when transmitting on Secondary Advertising Physical Channel.
 *        Values:
 *        - 0x00: CODED_PHY_NO_PREFERENCE
 *        - 0x01: CODED_PHY_S2_PREFERRED
 *        - 0x02: CODED_PHY_S8_PREFERRED
 *        - 0x03: CODED_PHY_S2_REQUIRED
 *        - 0x04: CODED_PHY_S8_REQUIRED
 * @param[out] Selected_Tx_Power Units: dBm. The Selected_Tx_Power return
 *             parameter indicates the transmit power selected by the
 *             Controller. The Controller shall not change the transmit power
 *             for this advertising set without being directed to by the Host.
 *             Values:
 *             - -127 ... 126
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_extended_advertising_parameters_v2(uint8_t Advertising_Handle,
                                                         uint16_t Advertising_Event_Properties,
                                                         uint8_t Primary_Advertising_Interval_Min[3],
                                                         uint8_t Primary_Advertising_Interval_Max[3],
                                                         uint8_t Primary_Advertising_Channel_Map,
                                                         uint8_t Own_Address_Type,
                                                         uint8_t Peer_Address_Type,
                                                         uint8_t Peer_Address[6],
                                                         uint8_t Advertising_Filter_Policy,
                                                         int8_t Advertising_Tx_Power,
                                                         uint8_t Primary_Advertising_PHY,
                                                         uint8_t Secondary_Advertising_Max_Skip,
                                                         uint8_t Secondary_Advertising_PHY,
                                                         uint8_t Advertising_SID,
                                                         uint8_t Scan_Request_Notification_Enable,
                                                         uint8_t Primary_Advertising_PHY_Options,
                                                         uint8_t Secondary_Advertising_PHY_Options,
                                                         int8_t *Selected_Tx_Power);
/**
 * @brief The HCI_LE_Set_Periodic_Sync_Subevent command is used to instruct the
 *        Controller to synchronize with a subset of the subevents within a PAwR
 *        train identified by the Sync_Handle parameter, listen for packets sent
 *        by the peer device and pass any received data up to the Host. If the
 *        Controller is synchronized with any subevents that are not in the
 *        subset of subevents in this command, then the Controller shall no
 *        longer synchronize with those subevents. The
 *        Periodic_Advertising_Properties parameter indicates which fields
 *        should be included in the AUX_SYNC_SUBEVENT_RSP PDUs. The
 *        Num_Subevents parameter identifies the number of values in the
 *        subevents parameter. The Subevents arrayed parameter identifies the
 *        subevents that the Controller shall synchronize with.
 * @param Sync_Handle Sync_Handle identifying the PAwR train.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Periodic_Advertising_Properties If bit 6 is set, include TxPower in
 *        the advertising PDU.
 *        Flags:
 *        - 0x0040: TX_POWER
 * @param Num_Subevents Number of subevent data in the command.
 *        Values:
 *        - 0x01 ... 0x0F
 * @param Subevent The subevent to synchronize with.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_periodic_sync_subevent(uint16_t Sync_Handle,
                                             uint16_t Periodic_Advertising_Properties,
                                             uint8_t Num_Subevents,
                                             uint8_t Subevent[]);
/**
 * @brief The LE_Extended_Create_Connection command is used to create a Link
 *        Layer connection to a connectable advertiser.
 *        LE_Extended_Create_Connection command can be used in place of
 *        LE_Create_Connection command.
 * @param Advertising_Handle Advertising_Handle identifying the periodic
 *        advertising train.
 *        Values:
 *        - 0x00 ... 0xEF
 *        - 0xFF: Not specified
 * @param Subevent Subevent where the connection request is to be sent.
 *        Values:
 *        - 0x00 ... 0x7F
 *        - 0xFF: Not specified
 * @param Initiator_Filter_Policy The Initiator_Filter_Policy parameter is used
 *        to determine whether the Filter Accept List is used. If the Filter
 *        Accept List is not used, the Peer_Address_Type and the Peer_Address
 *        parameters specify the address type and address of the advertising
 *        device to connect to. 0x00 - Filter Accept List is not used to
 *        determine which advertiser to connect to. Peer_Address_Type and
 *        Peer_Address shall be used. 0x01 - Filter Accept List is used to
 *        determine which advertiser to connect to. Peer_Address_Type and
 *        Peer_Address shall be ignored.
 *        Values:
 *        - 0x00: FILTER_ACCEPT_LIST_NOT_USED
 *        - 0x01: FILTER_ACCEPT_LIST_USED
 * @param Own_Address_Type The Own_Address_Type parameter indicates the type of
 *        address being used in the connection request packets.
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the public address.
 *        - 0x03: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the random address from the most recent successful
LE_Set_Random_Address Command.
 * @param Peer_Address_Type The Peer_Address_Type parameter indicates the type
 *        of address used in the connectable advertisement sent by the peer.
 *        0x00: Public Device Address or Public Identity Address 0x01: Random
 *        Device Address or Random (static) Identity Address
 *        Values:
 *        - 0x00: Public Address
 *        - 0x01: Random Address
 * @param Peer_Address Public Device Address, Random Device Address, Public
 *        Identity Address, or Random (static) Identity Address of the device to
 *        be connected.
 * @param Initiating_PHYs The Initiating_PHYs parameter indicates the PHY(s) on
 *        which the advertising packets should be received on the primary
 *        advertising channel and the PHYs for which connection parameters have
 *        been specified. The Host may enable one or more initiating PHYs. 0x01:
 *        Scan connectable advertisements on the LE 1M PHY. Connection
 *        parameters for the LE 1M PHY are provided. 0x02: Connection parameters
 *        for the LE 2M PHY are provided 0x04: Scan connectable advertisements
 *        on the LE Coded PHY. Connection parameters for the LE Coded PHY are
 *        provided.
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x02: LE_2M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param Extended_Create_Connection_Parameters See @ref
 *        Extended_Create_Connection_Parameters_t
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_extended_create_connection_v2(uint8_t Advertising_Handle,
                                                uint8_t Subevent,
                                                uint8_t Initiator_Filter_Policy,
                                                uint8_t Own_Address_Type,
                                                uint8_t Peer_Address_Type,
                                                uint8_t Peer_Address[6],
                                                uint8_t Initiating_PHYs,
                                                Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[]);
/**
 * @brief The HCI_LE_Set_Periodic_Advertising_Parameters command is used by the
 *        Host to set the parameters for periodic advertising. The
 *        Advertising_Handle parameter identifies the advertising set whose
 *        periodic advertising parameters are being configured. If the
 *        corresponding advertising set does not already exist, then the
 *        Controller shall return the error code Unknown Advertising Identifier
 *        (0x42). The Periodic_Advertising_Interval_Min parameter shall be less
 *        than or equal to the Periodic_Advertising_Interval_Max parameter. The
 *        Periodic_Advertising_- Interval_Min and
 *        Periodic_Advertising_Interval_Max parameters should not be the same
 *        value to enable the Controller to determine the best advertising
 *        interval given other activities. If the periodic advertising interval
 *        range provided by the Host (Periodic_Advertising_Interval_Min,
 *        Periodic_Advertising_Interval_Max) does not overlap with the periodic
 *        advertising interval range supported by the Controller, then the
 *        Controller shall return an error which should use the error code
 *        Unsupported Feature or Parameter Value (0x11). The
 *        Periodic_Advertising_Properties parameter indicates which fields
 *        should be included in the advertising packet. The Num_Subevents
 *        parameter identifies the number of subevents that shall be transmitted
 *        for each periodic advertising event. If the Num_Subevents parameter
 *        value is 0x00, then the Subevent_Interval, Response_Slot_Delay,
 *        Response_Slot_Spacing, and Num_Response_Slots parameters shall be
 *        ignored. The Subevent_Interval parameter identifies the time between
 *        the subevents of PAwR. The Subevent_Interval shall be less than or
 *        equal to the Periodic_Advertising_Interval_Min divided by the
 *        Num_Subevents of the advertising set. The Response_Slot_Delay
 *        parameter identifies the time between the start of the advertising
 *        packet at the start of a subevent and the start of the first response
 *        slot. The Response_Slot_Delay shall be less than the
 *        Subevent_Interval. The Response_Slot_Spacing parameter identifies the
 *        time between the start of two consecutive response slots. The
 *        Response_Slot_Spacing shall be less than or equal to 10 x
 *        (Subevent_Interval - Response_Slot_Delay) / Num_Response_Slots. If the
 *        Num_Response_Slots parameter is set to 1, then the Controller shall
 *        ignore the Response_Slot_Spacing parameter. The Num_Response_Slots
 *        parameter identifies the number of response slots in a subevent. If
 *        the Num_Response_Slots parameter value is 0x00, then the
 *        Response_Slot_Delay and Response_Slot_Spacing parameters shall be
 *        ignored. If the advertising set identified by the Advertising_Handle
 *        specified scannable, connectable, legacy, or anonymous advertising,
 *        the Controller shall return the error code Invalid HCI Command
 *        Parameters (0x12). If the Host issues this command when periodic
 *        advertising is enabled for the specified advertising set, the
 *        Controller shall return the error code Command Disallowed (0x0C). If
 *        the Advertising_Handle does not identify an advertising set that is
 *        already configured for periodic advertising and the Controller is
 *        unable to support more periodic advertising at present, the Controller
 *        shall return the error code Memory Capacity Exceeded (0x07). If the
 *        advertising set already contains periodic advertising data and the
 *        length of the data is greater than the maximum that the Controller can
 *        transmit within a periodic advertising interval of
 *        Periodic_Advertising_Interval_Max, the Controller shall return the
 *        error code Packet Too Long (0x45). If advertising on the LE Coded PHY,
 *        the S=8 coding shall be assumed unless the current advertising
 *        parameters require the use of S=2 for an advertising physical channel,
 *        in which case the S=2 coding shall be assumed for that advertising
 *        physical channel.
 * @param Advertising_Handle Used to identify a periodic advertising train.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Periodic_Advertising_Interval_Min Minimum advertising interval for
 *        periodic advertising. Time = N * 1.25 ms; Time Range: 7.5ms to
 *        81.91875 s.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 * @param Periodic_Advertising_Interval_Max Maximum advertising interval for
 *        periodic advertising. Time = N * 1.25 ms; Time Range: 7.5ms to
 *        81.91875 s.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) 
 * @param Periodic_Advertising_Properties The Periodic_Advertising_Properties
 *        parameter indicates which fields should be included in the advertising
 *        packet.
 *        Flags:
 *        - 0x0040
 * @param Num_Subevents Number of subevents.
 *        Values:
 *        - 0x00 ... 0x80
 * @param Subevent_Interval Interval between subevents. Time = N x 1.25 ms.
 *        Values:
 *        - 0x06 (7.50 ms)  ... 0xFF (318.75 ms) 
 * @param Response_Slot_Delay Time between the advertising packet in a subevent
 *        and the first response slot. Time = N x 1.25 ms.
 *        Values:
 *        - 0x00 (NaN) : No response slots
 *        - 0x01 (1.25 ms)  ... 0xFE (317.50 ms) 
 * @param Response_Slot_Spacing Time between response slots. Time = N x 0.125 ms
 *        Values:
 *        - 0x00 (0.000 ms) : No response slots
 *        - 0x02 (0.250 ms)  ... 0xFF (31.875 ms) 
 * @param Num_Response_Slots Number of subevent response slots.
 *        Values:
 *        - 0x00 ... 0xFF
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_set_periodic_advertising_parameters_v2(uint8_t Advertising_Handle,
                                                         uint16_t Periodic_Advertising_Interval_Min,
                                                         uint16_t Periodic_Advertising_Interval_Max,
                                                         uint16_t Periodic_Advertising_Properties,
                                                         uint8_t Num_Subevents,
                                                         uint8_t Subevent_Interval,
                                                         uint8_t Response_Slot_Delay,
                                                         uint8_t Response_Slot_Spacing,
                                                         uint8_t Num_Response_Slots);
/**
 * @brief API used to send HCI ACL Data Packets to exchange data between the Host and Controller.
 *
 * @note The API name is only available in link layer only mode.
 *
 * @param      Connection_Handle  Connection handle for which the command is given. Range: 0x0000-0x0EFF (0x0F00 - 0x0FFF Reserved for future use)
 * @param      PB_Flag            Packet boundary flag
 * @param      BC_Flag            Broadcast flag
 * @param      Data_Length        Length of PDU data in octets.
 * @param[in]  PDU_Data           PDU data pointer
 *
 * @return  Error code
 */
tBleStatus hci_tx_acl_data(uint16_t Connection_Handle,
                           uint8_t  PB_Flag,
                           uint8_t  BC_Flag,
                           uint16_t  Data_Length,
                           uint8_t*  PDU_Data);
/**
* @brief Function to send isochronous data to the Controller.
 *
 * @param      Connection_Handle    Connection handle. Range: 0x0000-0x0EFF (0x0F00 - 0x0FFF Reserved for future use)
 * @param      PB_Flag              Packet boundary flag
 * @param      TS_Flag              Timestamp flag. Set if the ISO_Data_Load field contains a Time_Stamp field.
 * @param      ISO_Data_Load_Length Length of ISO_Data_Load in octets.
 * @param[in]  ISO_Data_Load        The format of the ISO_Data_Load is described in Core v5.3 Vol. 4, part E, section 5.4.5
 *
 * @return  Error code
 */
tBleStatus hci_tx_iso_data(uint16_t Connection_Handle,
                           uint8_t  PB_Flag,
                           uint8_t  TS_Flag,
                           uint16_t ISO_Data_Load_Length,
                           uint8_t *ISO_Data_Load);
/**
 * @}
 */

/**
 * @}
 */


/**
 *@addtogroup HCI HCI
 *@brief Standard Host Controller Interface.
 *@{
 */
/**
 *@defgroup HCI_Test_Commands HCI Test Commands
 * Standard HCI commands for testing.
 *@{
 */
/**
 * @brief This command is used to start a test where the DUT receives test
 *        reference packets at a fixed interval. The tester generates the test
 *        reference packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
 *        7.8.28)
 * @param RX_Frequency
 *        Values:
 *        - 0x00 ... 0x27: N = (F - 2402) / 2.Frequency Range : 2402 MHz to 2480 MHz
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_receiver_test(uint8_t RX_Frequency);
/**
 * @brief This command is used to start a test where the DUT generates test
 *        reference packets at a fixed interval. The Controller shall transmit
 *        at maximum power. An LE Controller supporting the LE_Transmitter_Test
 *        command shall support Packet_Payload values 0x00, 0x01 and 0x02. An LE
 *        Controller may support other values of Packet_Payload. (See Bluetooth
 *        Specification v.4.1, Vol. 2, Part E, 7.8.29)
 * @param TX_Frequency N = (F - 2402) / 2. Frequency Range : 2402 MHz to 2480
 *        MHz
 *        Values:
 *        - 0x00 ... 0x27
 * @param Length_Of_Test_Data Length in bytes of payload data in each packet.
 *        Supported ranges:       - (0x00,0x25) if data length extension is
 *        disabled.       - (0x00,0xFF) if data length extension is enabled.
 *        Values:
 *        - 0x00 ... 0xFF
 * @param Packet_Payload Content of the Payload of the test reference packets.
 *        0: PRBS9 sequence '11111111100000111101...' (in transmission order) 1:
 *        Repeated '11110000' (in transmission order) sequence 2: Repeated
 *        '10101010' (in transmission order) sequence 3: PRBS15 sequence 4:
 *        Repeated '11111111' (in transmission order) sequence 5: Repeated
 *        '00000000' (in transmission order) sequence 6: Repeated '00001111' (in
 *        transmission order) sequence 7: Repeated '01010101' (in transmission
 *        order) sequence
 *        Values:
 *        - 0x00: PRBS9
 *        - 0x01: Repeated '11110000'
 *        - 0x02: Repeated '10101010'
 *        - 0x03: PRBS15
 *        - 0x04: Repeated '11111111'
 *        - 0x05: Repeated '00000000'
 *        - 0x06: Repeated '00001111'
 *        - 0x07: Repeated '01010101'
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_transmitter_test(uint8_t TX_Frequency,
                                   uint8_t Length_Of_Test_Data,
                                   uint8_t Packet_Payload);
/**
 * @brief This command is used to stop any test which is in progress. The
 *        Number_Of_Packets for a transmitter test shall be reported as 0x0000.
 *        The Number_Of_Packets is an unsigned number and contains the number of
 *        received packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
 *        7.8.30)
 * @param[out] Number_Of_Packets Number of packets received.
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_test_end(uint16_t *Number_Of_Packets);
/**
 * @brief This command is used to start a test where the DUT receives test
 *        reference packets at a fixed interval. The tester generates the test
 *        reference packets.
 * @param RX_Channel Frequency Range : 2402 MHz to 2480 MHz N = (F - 2402) / 2.
 *        Values:
 *        - 0x00 ... 0x27: Frequency Range : 2402 MHz to 2480 MHz
 * @param PHY PHY to be used by the receiver.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY
 * @param Modulation_index The Modulation_Index parameter specifies whether or
 *        not the Controller should assume the receiver has a stable modulation
 *        index.
 *        Values:
 *        - 0x00: Standard modulation index
 *        - 0x01: Stable modulation index
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_receiver_test_v2(uint8_t RX_Channel,
                                   uint8_t PHY,
                                   uint8_t Modulation_index);
/**
 * @brief This command is used to start a test where the DUT generates test
 *        reference packets at a fixed interval. The Controller shall transmit
 *        at maximum power. An LE Controller supporting the LE_Enhanced
 *        Transmitter_Test command shall support Packet_Payload values 0x00,
 *        0x01 and 0x02. An LE Controller supporting the LE Coded PHY shall also
 *        support Packet_Payload value 0x04. An LE Controller may support other
 *        values of Packet_Payload.
 * @param TX_Channel Frequency Range: 2402 MHz to 2480 MHz N = (F-2402) / 2
 *        Values:
 *        - 0x00 ... 0x27: Frequency Range: 2402 MHz to 2480 MHz
 * @param Length_Of_Test_Data Length in bytes of payload data in each packet.
 *        Supported ranges:       - (0x00,0x25) if data length extension is
 *        disabled.       - (0x00,0xFF) if data length extension is enabled.
 *        Values:
 *        - 0x00 ... 0xFF
 * @param Packet_Payload Content of the Payload of the test reference packets.
 *        0: PRBS9 sequence '11111111100000111101...' (in transmission order) 1:
 *        Repeated '11110000' (in transmission order) sequence 2: Repeated
 *        '10101010' (in transmission order) sequence 3: PRBS15 sequence 4:
 *        Repeated '11111111' (in transmission order) sequence 5: Repeated
 *        '00000000' (in transmission order) sequence 6: Repeated '00001111' (in
 *        transmission order) sequence 7: Repeated '01010101' (in transmission
 *        order) sequence
 *        Values:
 *        - 0x00: PRBS9
 *        - 0x01: Repeated '11110000'
 *        - 0x02: Repeated '10101010'
 *        - 0x03: PRBS15
 *        - 0x04: Repeated '11111111'
 *        - 0x05: Repeated '00000000'
 *        - 0x06: Repeated '00001111'
 *        - 0x07: Repeated '01010101'
 * @param PHY PHY to be used by the transmitter.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY_S8
 *        - 0x04: LE_CODED_PHY_S2
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_transmitter_test_v2(uint8_t TX_Channel,
                                      uint8_t Length_Of_Test_Data,
                                      uint8_t Packet_Payload,
                                      uint8_t PHY);
/**
 * @brief This command is used to start a test where the DUT receives test
 *        reference packets at a fixed interval. The tester generates the test
 *        reference packets. The RX_Channel and PHY parameters specify the RF
 *        channel and PHY to be used by the receiver. If the Host sets the PHY
 *        parameter to a PHY that the Controller does not support, including a
 *        value that is reserved for future use, the Controller shall return the
 *        error code Unsupported Feature or Parameter Value (0x11). The
 *        Modulation_Index parameter specifies whether or not the Controller
 *        should assume the receiver has a stable modulation index. The
 *        Expected_CTE_Length and Expected_CTE_Type parameters specify the
 *        expected length and type of the Constant Tone Extensions in received
 *        test reference packets. When receiving on a PHY that allows Constant
 *        Tone Extensions, if the Constant Tone Extension in a received test
 *        reference packet does not match both of these, the DUT shall discard
 *        that packet. If Expected_CTE_Length is not zero and PHY specifies a
 *        PHY that does not allow Constant Tone Extensions, the Controller shall
 *        return the error code Command Disallowed (0x0C). If the Slot_Durations
 *        parameter is set to 0x01 and the Controller does not support 1
 *        microsecond switching and sampling, the Controller shall return the
 *        error code Unsupported Feature or Parameter Value (0x11).
 *        Slot_Durations, Switching_Pattern_Length, and Antenna_IDs[i] are only
 *        used when expecting an AoA Constant Tone Extension and shall be
 *        ignored when expecting an AoD Constant Tone Extension. If the
 *        Controller determines that any of the Antenna_IDs[i] values do not
 *        identify an antenna in the device's antenna array, it shall return the
 *        error code Unsupported Feature or Parameter Value (0x11). Note: Some
 *        Controllers may be unable to determine which values do or do not
 *        identify an antenna.
 * @param RX_Channel
 *        Values:
 *        - 0x00 ... 0x27: N = (F - 2402) / 2.Frequency Range : 2402 MHz to 2480 MHz
 * @param PHY PHY to be used by the receiver.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY
 * @param Modulation_Index
 *        Values:
 *        - 0x00: Assume transmitter will have a standard modulation index
 *        - 0x01: Assume transmitter will have a stable modulation index
 * @param Expected_CTE_Length
 *        Values:
 *        - 0x00: No Constant Tone Extension expected (default)
 *        - 0x02 ... 0x14: Expected length of the Constant Tone Extension in 8 microseconds units.
 * @param Expected_CTE_Type
 *        Values:
 *        - 0x00: Expect AoA Constant Tone Extension
 *        - 0x01: Expect AoD Constant Tone Extension with 1 microsecond slots
 *        - 0x02: Expect AoD Constant Tone Extension with 2 microseconds slots
 * @param Slot_Durations Sampling rate used by the Controller.
 *        Values:
 *        - 0x01: CTE_SLOT_1us
 *        - 0x02: CTE_SLOT_2us
 * @param Switching_Pattern_Length
 *        Values:
 *        - 0x02 ... 0x4B: The number of Antenna IDs in the pattern.
 * @param Antenna_IDs List of Antenna IDs in the pattern
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_receiver_test_v3(uint8_t RX_Channel,
                                   uint8_t PHY,
                                   uint8_t Modulation_Index,
                                   uint8_t Expected_CTE_Length,
                                   uint8_t Expected_CTE_Type,
                                   uint8_t Slot_Durations,
                                   uint8_t Switching_Pattern_Length,
                                   uint8_t Antenna_IDs[]);
/**
 * @brief This command is used to start a test where the DUT generates test
 *        reference packets at a fixed interval. The Controller shall transmit
 *        at the power level indicated by the Transmit_Power_Level parameter.
 *        The TX_Channel and PHY parameters specify the RF channel and PHY to be
 *        used by the transmitter. If the Host sets the PHY parameter to a PHY
 *        that the Controller does not support, including a value that is
 *        reserved for future use, the Controller shall return the error code
 *        Unsupported Feature or Parameter Value (0x11). The Test_Data_Length
 *        and Packet_Payload parameters specify the length and contents of the
 *        Payload of the test reference packets. An LE Controller supporting the
 *        HCI_LE_Transmitter_Test command shall support Packet_Payload values
 *        0x00, 0x01 and 0x02. An LE Controller supporting the LE Coded PHY
 *        shall also support Packet_Payload value 0x04. An LE Controller may
 *        support other values of Packet_Payload. The CTE_Length and CTE_Type
 *        parameters specify the length and type of the Constant Tone Extension
 *        in the test reference packets. If the CTE_Type parameter is set to
 *        0x01 and the Controller does not support 1 microsecond switching, the
 *        Controller shall return the error code Unsupported Feature or
 *        Parameter Value (0x11). If CTE_Length is not zero and PHY specifies a
 *        PHY that does not allow Constant Tone Extensions, the Controller shall
 *        return the error code Command Disallowed (0x0C). The
 *        Switching_Pattern_Length and Antenna_IDs[i] parameters specify the
 *        antenna switching pattern. They are only used when transmitting an AoD
 *        Constant Tone Extension and shall be ignored when transmitting an AoA
 *        Constant Tone Extension. If the Controller determines that any of the
 *        Antenna_IDs[i] values do not identify an antenna in the device's
 *        antenna array, it shall return the error code Unsupported Feature or
 *        Parameter Value (0x11). Note: Some Controllers may be unable to
 *        determine which values do or do not identify an antenna. The
 *        Transmit_Power_Level parameter specifies the transmit power level to
 *        be used by the transmitter. If the parameter is set to a value other
 *        than 0x7E or 0x7F, then the Controller shall make the requested change
 *        or shall make the nearest change that it is capable of doing.
 * @param TX_Channel N = (F - 2402) / 2. Frequency Range : 2402 MHz to 2480 MHz
 *        Values:
 *        - 0x00 ... 0x27
 * @param Test_Data_Length Length in bytes of payload data in each packet.
 *        Supported ranges:       - (0x00,0x25) if data length extension is
 *        disabled.       - (0x00,0xFF) if data length extension is enabled.
 *        Values:
 *        - 0x00 ... 0xFF
 * @param Packet_Payload Content of the Payload of the test reference packets.
 *        0: PRBS9 sequence '11111111100000111101...' (in transmission order) 1:
 *        Repeated '11110000' (in transmission order) sequence 2: Repeated
 *        '10101010' (in transmission order) sequence 3: PRBS15 sequence 4:
 *        Repeated '11111111' (in transmission order) sequence 5: Repeated
 *        '00000000' (in transmission order) sequence 6: Repeated '00001111' (in
 *        transmission order) sequence 7: Repeated '01010101' (in transmission
 *        order) sequence
 *        Values:
 *        - 0x00: PRBS9
 *        - 0x01: Repeated '11110000'
 *        - 0x02: Repeated '10101010'
 *        - 0x03: PRBS15
 *        - 0x04: Repeated '11111111'
 *        - 0x05: Repeated '00000000'
 *        - 0x06: Repeated '00001111'
 *        - 0x07: Repeated '01010101'
 * @param PHY PHY to be used by the transmitter.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY_S8
 *        - 0x04: LE_CODED_PHY_S2
 * @param CTE_Length
 *        Values:
 *        - 0x00: No Constant Tone Extension expected (default)
 *        - 0x02 ... 0x14: Expected length of the Constant Tone Extension in 8 microseconds units.
 * @param CTE_Type
 *        Values:
 *        - 0x00: Expect AoA Constant Tone Extension
 *        - 0x01: Expect AoD Constant Tone Extension with 1 microsecond slots
 *        - 0x02: Expect AoD Constant Tone Extension with 2 microseconds slots
 * @param Switching_Pattern_Length The number of Antenna IDs in the pattern.
 *        Values:
 *        - 0x02 ... 0x4B
 * @param Antenna_IDs List of Antenna IDs in the pattern
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_transmitter_test_v3(uint8_t TX_Channel,
                                      uint8_t Test_Data_Length,
                                      uint8_t Packet_Payload,
                                      uint8_t PHY,
                                      uint8_t CTE_Length,
                                      uint8_t CTE_Type,
                                      uint8_t Switching_Pattern_Length,
                                      uint8_t Antenna_IDs[]);
/**
 * @brief This command is used to start a test where the DUT generates test
 *        reference packets at a fixed interval. The Controller shall transmit
 *        at the power level indicated by the Transmit_Power_Level parameter.
 *        The TX_Channel and PHY parameters specify the RF channel and PHY to be
 *        used by the transmitter. If the Host sets the PHY parameter to a PHY
 *        that the Controller does not support, including a value that is
 *        reserved for future use, the Controller shall return the error code
 *        Unsupported Feature or Parameter Value (0x11). The Test_Data_Length
 *        and Packet_Payload parameters specify the length and contents of the
 *        Payload of the test reference packets. An LE Controller supporting the
 *        HCI_LE_Transmitter_Test command shall support Packet_Payload values
 *        0x00, 0x01 and 0x02. An LE Controller supporting the LE Coded PHY
 *        shall also support Packet_Payload value 0x04. An LE Controller may
 *        support other values of Packet_Payload. The CTE_Length and CTE_Type
 *        parameters specify the length and type of the Constant Tone Extension
 *        in the test reference packets. If the CTE_Type parameter is set to
 *        0x01 and the Controller does not support 1 microsecond switching, the
 *        Controller shall return the error code Unsupported Feature or
 *        Parameter Value (0x11). If CTE_Length is not zero and PHY specifies a
 *        PHY that does not allow Constant Tone Extensions, the Controller shall
 *        return the error code Command Disallowed (0x0C). The
 *        Switching_Pattern_Length and Antenna_IDs[i] parameters specify the
 *        antenna switching pattern. They are only used when transmitting an AoD
 *        Constant Tone Extension and shall be ignored when transmitting an AoA
 *        Constant Tone Extension. If the Controller determines that any of the
 *        Antenna_IDs[i] values do not identify an antenna in the device's
 *        antenna array, it shall return the error code Unsupported Feature or
 *        Parameter Value (0x11). Note: Some Controllers may be unable to
 *        determine which values do or do not identify an antenna. The
 *        Transmit_Power_Level parameter specifies the transmit power level to
 *        be used by the transmitter. If the parameter is set to a value other
 *        than 0x7E or 0x7F, then the Controller shall make the requested change
 *        or shall make the nearest change that it is capable of doing.
 * @param TX_Channel N = (F - 2402) / 2. Frequency Range : 2402 MHz to 2480 MHz
 *        Values:
 *        - 0x00 ... 0x27
 * @param Test_Data_Length Length in bytes of payload data in each packet.
 *        Supported ranges:       - (0x00,0x25) if data length extension is
 *        disabled.       - (0x00,0xFF) if data length extension is enabled.
 *        Values:
 *        - 0x00 ... 0xFF
 * @param Packet_Payload Content of the Payload of the test reference packets.
 *        0: PRBS9 sequence '11111111100000111101...' (in transmission order) 1:
 *        Repeated '11110000' (in transmission order) sequence 2: Repeated
 *        '10101010' (in transmission order) sequence 3: PRBS15 sequence 4:
 *        Repeated '11111111' (in transmission order) sequence 5: Repeated
 *        '00000000' (in transmission order) sequence 6: Repeated '00001111' (in
 *        transmission order) sequence 7: Repeated '01010101' (in transmission
 *        order) sequence
 *        Values:
 *        - 0x00: PRBS9
 *        - 0x01: Repeated '11110000'
 *        - 0x02: Repeated '10101010'
 *        - 0x03: PRBS15
 *        - 0x04: Repeated '11111111'
 *        - 0x05: Repeated '00000000'
 *        - 0x06: Repeated '00001111'
 *        - 0x07: Repeated '01010101'
 * @param PHY PHY to be used by the transmitter.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY_S8
 *        - 0x04: LE_CODED_PHY_S2
 * @param CTE_Length
 *        Values:
 *        - 0x00: No Constant Tone Extension expected (default)
 *        - 0x02 ... 0x14: Expected length of the Constant Tone Extension in 8 microseconds units.
 * @param CTE_Type
 *        Values:
 *        - 0x00: Expect AoA Constant Tone Extension
 *        - 0x01: Expect AoD Constant Tone Extension with 1 microsecond slots
 *        - 0x02: Expect AoD Constant Tone Extension with 2 microseconds slots
 * @param Switching_Pattern_Length
 *        Values:
 *        - 0x02 ... 0x4B: The number of Antenna IDs in the pattern.
 * @param Antenna_IDs List of Antenna IDs in the pattern
 * @param Transmit_Power_Level
 *        Values:
 *        - -127 ... 20: Set transmitter to the specified or the nearest transmit power level.
 *        - 126: Set transmitter to minimum transmit power level
 *        - 127: Set transmitter to maximum transmit power level
 * @retval Value indicating success or error code.
 */
tBleStatus hci_le_transmitter_test_v4(uint8_t TX_Channel,
                                      uint8_t Test_Data_Length,
                                      uint8_t Packet_Payload,
                                      uint8_t PHY,
                                      uint8_t CTE_Length,
                                      uint8_t CTE_Type,
                                      uint8_t Switching_Pattern_Length,
                                      uint8_t Antenna_IDs[],
                                      int8_t Transmit_Power_Level);
/**
 * @}
 */

/**
 * @}
 */


/**
 *@addtogroup HAL_LL HAL/LL
 *@brief HAL and proprietary LL API layer.
 *@{
 */
/**
 *@defgroup ACI_HAL_Commands ACI HAL Commands
 * Commands for HAL and proprietary LL.
 *@{
 */
/**
 * @brief This command returns the build number associated with the firmware
 *        version currently running
 * @param[out] Build_Number Build number of the firmware.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_hal_get_fw_build_number(uint16_t *Build_Number);
/**
 * @brief This command writes a value to a low level configure data structure.
 *        It is useful to setup directly some low level parameters for the
 *        system in the runtime.NOTE: This command shall not be called if a
 *        command different than Stack Init, HCI_RESET,
 *        ACI_HAL_WRITE_CONFIG_DATA or ACI_HAL_READ_CONFIG_DATA has already been
 *        called.
 * @param Offset Offset of the element in the configuration data structure which
 *        has to be written. The valid offsets are:  - 0x00: Bluetooth public
 *        address, Value length to be written: 6 bytes - 0x08: Encryption root
 *        key used to derive LTK and CSRK, Value length to be written: 16 bytes
 *        - 0x18: Identity root key used to derive LTK and CSRK, Value length to
 *        be written: 16 bytes - 0x2C: Link layer without host (for
 *        certification purposes), Value length to be written: 1 byte - 0x2E: If
 *        set, the stack uses this address as the static random address instead
 *        of the one stored in NVM. - 0x2F: Value is a bit field that indicates
 *        the advertising channel indices that shall be used when scanning. At
 *        least one channel bit shall be set. Bit 0: ch. 37; bit 1: ch. 38; bit
 *        2: ch 39. - 0xD0: Use debug key for Secure connection: 1 byte - 0xD1:
 *        Set the maximum allowed parameter values for Data Length Extension: 8
 *        bytes, 2 bytes for each of the following parameters:
 *        supportedMaxTxOctets, supportedMaxTxTime, supportedMaxRxOctets,
 *        supportedMaxRxTime, in little-endian order.         (default
 *        251,2120,251,2120).
 *        Values:
 *        - 0x00: CONFIG_DATA_PUBADDR_OFFSET
 *        - 0x08: CONFIG_DATA_ER_OFFSET
 *        - 0x18: CONFIG_DATA_IR_OFFSET
 *        - 0x2C: LL_WITHOUT_HOST
 *        - 0x2E: CONFIG_DATA_STATIC_RANDOM_ADDRESS
 *        - 0x2F: CONFIG_DATA_SCAN_CH_MAP
 *        - 0xD0: CONFIG_DATA_DEBUG_KEY
 *        - 0xD1: CONFIG_DATA_DLE
 * @param Length Length of data to be written
 * @param Value Data to be written
 * @retval Value indicating success or error code.
 */
tBleStatus aci_hal_write_config_data(uint8_t Offset,
                                     uint8_t Length,
                                     uint8_t Value[]);
/**
 * @brief This command requests the value in the low level configure data
 *        structure. The number of read bytes changes for different Offset.
 * @param Offset Offset of the element in the configuration data structure which
 *        has to be read. The valid offsets are:  - 0x00: Bluetooth public
 *        address, Value length returned: 6 bytes - 0x08: Encryption root key
 *        used to derive LTK and CSRK, Value length returned: 16 bytes - 0x18:
 *        Identity root key used to derive LTK and CSRK, Value length returned:
 *        16 bytes - 0x2C: Link layer without host (for certification purposes),
 *        Value length returned: 1 byte - 0x80: The static random address stored
 *        in NVM. Value length returned: 6 bytes (read-only)
 *        Values:
 *        - 0x00: CONFIG_DATA_PUBADDR_OFFSET
 *        - 0x08: CONFIG_DATA_ER_OFFSET
 *        - 0x18: CONFIG_DATA_IR_OFFSET
 *        - 0x2C: LL_WITHOUT_HOST
 *        - 0x80: CONFIG_DATA_STORED_STATIC_RANDOM_ADDRESS
 * @param[out] Data_Length Length of Data in octets
 * @param[out] Data Data field associated with Offset parameter
 * @retval Value indicating success or error code.
 */
tBleStatus aci_hal_read_config_data(uint8_t Offset,
                                    uint8_t *Data_Length,
                                    uint8_t Data[]);
/**
 * @brief This command sets the TX power level of the device for all the radio
 *        activities, unless explicitly defined by other commands. The
 *        combination of En_High_Power and PA_Level parameters determines the
 *        output power level (dBm).  When the system starts up or reboots, the
 *        default TX power level will be used, which is En_High_Power = 0 and
 *        PA_Level = 31.  The En_High_Power is used to change the SMPS level.
 *        When the parameter is set to 0, SMPS level is set to 1.4V. When the
 *        parameter is set to 1, SMPS level is set to 1.9V. However, if SMPS is
 *        disabled, no action is done on the SMPS level, since the voltage must
 *        be applied externally on the VFBSD pin. To reach 8 dBm of TX power,
 *        En_High_Power must be set to 1. If SMPS is not used, this voltage
 *        level must be applied to the VFBSD pin. On devices other then
 *        STM32WB09, setting En_High_Power to 1 also bypasses the LDO_TRANSFO
 *        during transmission.  On STM32WB09 device, PA_Level 32 is used to
 *        specify the configuration to reach 8 dBm, to be used only when
 *        En_High_Power is set to 1. In this configuration, LDO_TRANSFO is
 *        bypassed during transmission, by setting TxHp bit. The output power
 *        for other PA levels will remain almost equal to the case when
 *        En_High_Power is set to 0, since LDO_TRANSFO is not bypassed (TxHp bit
 *        set to 0).  On devices other than STM32WB09, (i.e. where TxHp bit is
 *        not present), PA level 32 cannot be used. The 8 dBm configuration can
 *        be selected by using PA_Level 31, with En_High_Power set to 1.
 *        However, when setting En_High_Power to 1, also the output power of
 *        other PA levels less than 31 will change (especially for the higher
 *        ones) since LDO_TRANSFO is always bypassed during transmission for all
 *        the PA levels.  Note that, if En_High_Power = 1 and SMPS is disabled,
 *        when LDO_TRANSFO is bypassed the actual output power will depend on
 *        the voltage applied to the VFBSD pin. In case the voltage is not 1.9V,
 *        it is recommended to change the TX output levels specified in the
 *        high_power_pa_level_table. The real output power may also depend on
 *        PCB layout and associated components.  After this command is given,
 *        the new output power will be used only for new Link Layer state
 *        machines, i.e. for new Bluetooth activities, i.e. new advertising
 *        sets, new connections, new scanning procedures. For current activities
 *        the output power will not change. The only exception is for
 *        AUX_SCAN_REQ and AUX_CONNECT_REQ PDUs, for which the new output power
 *        will immediately take effect also for the current scanning procedure.
 * @param En_High_Power Enable High Power mode, by changing SMPS level. High
 *        power mode should be enabled only to reach the maximum output power.
 *        Normal power (0x00) is the default.
 *        Values:
 *        - 0x00: Normal Power
 *        - 0x01: High Power
 * @param PA_Level Power amplifier output level. PA_Level 32 is available only
 *        for STM32WB09, to select 8 dBm of output power.
 *        Values:
 *        - 0: -54/-54 dBm
 *        - 1: -21/-19 dBm
 *        - 2: -20/-18 dBm
 *        - 3: -19/-17 dBm
 *        - 4: -17/-16 dBm
 *        - 5: -16/-15 dBm
 *        - 6: -15/-14 dBm
 *        - 7: -14/-13 dBm
 *        - 8: -13/-12 dBm
 *        - 9: -12/-11 dBm
 *        - 10: -11/-10 dBm
 *        - 11: -10/-9 dBm
 *        - 12: -9/-8 dBm
 *        - 13: -8/-7 dBm
 *        - 14: -7/-6 dBm
 *        - 15: -6/-5 dBm
 *        - 16: -6/-4 dBm
 *        - 17: -4/-3 dBm
 *        - 18: -3/-3 dBm
 *        - 19: -3/-2 dBm
 *        - 20: -2/-1 dBm
 *        - 21: -2/+0 dBm
 *        - 22: -1/+1 dBm
 *        - 23: -1/+2 dBm
 *        - 24: +0/+3 dBm
 *        - 25: +0/+8 dBm
 *        - 26: +1/+8 dBm
 *        - 27: +2/+8 dBm
 *        - 28: +3/+8 dBm
 *        - 29: +4/+8 dBm
 *        - 30: +5/+8 dBm
 *        - 31: +6/+8 dBm
 *        - 32: +8 dBm
 * @retval Value indicating success or error code.
 */
tBleStatus aci_hal_set_tx_power_level(uint8_t En_High_Power,
                                      uint8_t PA_Level);
/**
 * @brief This command returns the number of packets sent in Direct Test Mode.
 *        When the Direct TX test is started, a 32-bit counter is used to count
 *        how many packets have been transmitted.  This command can be used to
 *        check how many packets have been sent during the Direct TX test. The
 *        counter starts from 0 and counts upwards. The counter can wrap and
 *        start from 0 again.  The counter is not cleared until the next Direct
 *        TX test starts.
 * @param[out] Number_Of_Packets Number of packets sent during the last Direct
 *             TX test.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_hal_le_tx_test_packet_number(uint32_t *Number_Of_Packets);
/**
 * @brief This command returns the status of the Bluetooth low energy links
 *        managed by the device.
 * @param Bank_index Index that identifies the link bank. Each bank is made by 8
 *        links. Set Bank_Index to 0 to retrieve the status of the first 8
 *        links, Bank_Index 1 to retrieve the status of the second 8 links and
 *        so on.
 *        Values:
 *        - 0x00 ... 0x15
 * @param[out] Link_Status Array of link status (8 links). Each link status is 1
 *             byte. - 0x00: Idle - 0x01: Advertising - 0x02: Connected as
 *             peripheral - 0x03: Scanning - 0x04: Initiating - 0x05: Connected
 *             as central - 0x06: TX test mode - 0x07: RX test mode
 * @param[out] Link_Connection_Handle Array of connection handles (2 bytes) for
 *             8 links.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_hal_get_link_status(uint8_t Bank_index,
                                   uint8_t Link_Status[8],
                                   uint16_t Link_Connection_Handle[16 / 2]);
/**
 * @brief This command set the bitmask associated to @ref
 *        aci_hal_end_of_radio_activity_event_rp0.  Only the radio activities
 *        enabled in the mask will be reported to application by @ref
 *        aci_hal_end_of_radio_activity_event_rp0
 * @param Radio_Activity_Mask Bitmask of radio events
 *        Flags:
 *        - 0x0001: Idle
 *        - 0x0002: Advertising
 *        - 0x0004: Connection event peripheral
 *        - 0x0008: Scanning
 *        - 0x0010: Connection request
 *        - 0x0020: Connection event central
 *        - 0x0040: TX test mode
 *        - 0x0080: RX test mode
 * @retval Value indicating success or error code.
 */
tBleStatus aci_hal_set_radio_activity_mask(uint16_t Radio_Activity_Mask);
/**
 * @brief This command is used to enable or disable the LE Power Control feature
 *        and procedure for a given PHY on the later established connections. It
 *        also provides the parameters that let the Controller initiate the LE
 *        Power Control procedure. In particular, the procedure will be
 *        initiated when the current (average) RSSI (say Curr_Avg_RSSI) gets: 1)
 *        less than (RSSI_Target - RSSI_Hysteresis) and the Controller will
 *        request the peer to increase its TX power level for the given PHY by
 *        (RSSI_Target - Curr_Avg_RSSI); 2) greater than (RSSI_Target +
 *        RSSI_Hysteresis) and the Controller will request the peer to decrease
 *        its TX power level for the given PHY by (Curr_Avg_RSSI - RSSI_Target).
 *        The Controller will start transmitting on the connections for which
 *        the power control is enabled and for the given PHY using the
 *        Initial_Tx_Power value. It will change its TX power based on the
 *        requests or feedbacks from the peer: 1) if the peer initiates an LE
 *        Power Control procedure and requests to increase or decrease the TX
 *        power of a given delta, the TX power will be increased or reduced by
 *        the requested delta within the acceptable limits; 2) if the peer
 *        reports that it can accept a TX power reduction of a given delta, the
 *        TX power will be reduced by the reported delta within the acceptable
 *        limits. If this command is not issued, the Controller will use the
 *        parameter default values.
 * @param Enable Enable (1) or disable (0) LE power control on following
 *        connections. Default: 1.
 *        Values:
 *        - 0x00: DISABLE
 *        - 0x01: ENABLE
 * @param PHY PHY on which the power control must be enabled or disabled.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY_S8
 *        - 0x04: LE_CODED_PHY_S2
 * @param RSSI_Target Target RSSI in dBm. Default: -55 dBm.
 * @param RSSI_Hysteresis Hysteresis applied on the target RSSI in dB. Default:
 *        15 dB.
 * @param Initial_TX_Power Initial TX power in dBm. Default: max TX power
 *        supported by the platform.
 * @param RSSI_Filtering_Coefficient Coefficient used for the filtering of the
 *        RSSI samples and the calculation of the average RSSI. Allowed values
 *        are from 0 (fast moving average, low accuracy, max weight of last
 *        RSSI) to 4 (slow moving average, high accuracy, min weight of last
 *        RSSI). Default: 2.
 *        Values:
 *        - 0x00 ... 0x04
 * @retval Value indicating success or error code.
 */
tBleStatus aci_hal_set_le_power_control(uint8_t Enable,
                                        uint8_t PHY,
                                        int8_t RSSI_Target,
                                        uint8_t RSSI_Hysteresis,
                                        int8_t Initial_TX_Power,
                                        uint8_t RSSI_Filtering_Coefficient);
/**
 * @brief Command used on the peripheral to force the Link Layer to keep the
 *        peripheral latency disabled. Peripheral latency is enabled by default
 *        on a connection where peripheral latency has been set to a value
 *        greaten than zero by the Central when connection is established.
 *        Disabling the peripheral latency is useful to immediately reduce
 *        latency from Central to Peripheral. Note that when peripheral latency
 *        is enabled, the Link Layer will use the first available connection
 *        event to transfer the queued data, so there is no need to force the
 *        disabling of the peripheral latency to reduce latency from Peripheral
 *        to Central. This command returns BLE_ERROR_UNKNOWN_CONNECTION_ID if
 *        the connection handle does not exist. BLE_ERROR_COMMAND_DISALLOWED is
 *        returned if the command is given when the device is not in the
 *        peripheral role on the connection handle.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Enable Enable (1) or disable (0) the peripheral latency. Default value
 *        is Enabled (1).
 *        Values:
 *        - 0x00: DISABLED
 *        - 0x01: ENABLED
 * @retval Value indicating success or error code.
 */
tBleStatus aci_hal_peripheral_latency_enable(uint16_t Connection_Handle,
                                             uint8_t Enable);
/**
 * @brief This command can be used to get the maximum used size of the stack's
 *        internal FIFO queues: isr1_fifo, isr2_fifo and user_fifo. These values
 *        can be used to chose the maximum correct size for the queues, which
 *        can be set through the BLE_STACK_Init() function. If one of these
 *        queues reaches the maximum size, an hci_hardware_error_event_rp0 is
 *        raised, with error code 0x03.
 * @param[out] ISR0_FIFO_Max_Level Maximum size reached by the FIFO used for
 *             critical controller events produced by the ISR (e.g. rx data
 *             packets). See isr0_fifo_size parameter field of
 *             BLE_STACK_InitTypeDef structure, used by BLE_STACK_Init().
 * @param[out] ISR1_FIFO_Max_Level Maximum size reached by the FIFO used for
 *             non-critical controller events produced by the ISR (e.g.
 *             advertising or IQ sampling reports). See isr1_fifo_size parameter
 *             field of BLE_STACK_InitTypeDef structure, used by
 *             BLE_STACK_Init().
 * @param[out] User_FIFO_Max_Level Maximum size reached by the FIFO used for
 *             controller and host events produced outside the ISR. See
 *             user_fifo_size parameter field of BLE_STACK_InitTypeDef
 *             structure, used by BLE_STACK_Init().
 * @retval Value indicating success or error code.
 */
tBleStatus aci_hal_get_evt_fifo_max_level(uint16_t *ISR0_FIFO_Max_Level,
                                          uint16_t *ISR1_FIFO_Max_Level,
                                          uint16_t *User_FIFO_Max_Level);
/**
 * @brief Set data pointer for legacy advertising data.
 * @param Data_Length
 * @param Data
 * @retval Value indicating success or error code.
 */
tBleStatus ll_set_legacy_advertising_data_ptr(uint8_t Data_Length,
                                              uint8_t * Data);
/**
 * @brief Set data pointer for legacy scan response data.
 * @param Data_Length
 * @param Data
 * @retval Value indicating success or error code.
 */
tBleStatus ll_set_legacy_scan_reponse_data_ptr(uint8_t Data_Length,
                                               uint8_t * Data);
/**
 * @brief Set data pointer for extended advertising data.
 * @param Advertising_Handle Used to identify an advertising set. This parameter
 *        is only meaningful if Extended Advertising Feature is enabled.
 *        Values:
 *        - 0x0000 ... 0x00EF
 * @param Operation If set to Unchanged data, just update the Advertising DID.
 *        Values:
 *        - 0x03: Complete data
 *        - 0x04: Unchanged data
 * @param Advertising_Data_Length Length of advertising data.
 * @param Advertising_Data Pointer to the buffer containing properly formatted
 *        advertising data (see Core v5.2 Vol 3, part C, chapter 11). Its
 *        content must not change, until an
 *        aci_hal_adv_scan_resp_data_update_event_rp0 is received, which informs the
 *        application that the buffer is no more used by the Bluetooth stack.
 * @retval Value indicating success or error code.
 */
tBleStatus ll_set_advertising_data_ptr(uint16_t Advertising_Handle,
                                       uint8_t Operation,
                                       uint16_t Advertising_Data_Length,
                                       uint8_t Advertising_Data[]);
/**
 * @brief Set data pointer for extended scan response data.
 * @param Advertising_Handle Used to identify an advertising set. This parameter
 *        is only meaningful if Extended Advertising Feature is enabled.
 *        Values:
 *        - 0x0000 ... 0x00EF
 * @param Scan_Response_Data_Length Length of scan response data. If the
 *        advertising set uses scannable legacy advertising PDUs maximum length
 *        is 31 octets.
 * @param Scan_Response_Data Pointer to the buffer containing properly formatted
 *        scan response data (see Core v5.1 Vol 3, part C, chapter 11). Its
 *        content must not change, until an
 *        aci_hal_adv_scan_resp_data_update_event_rp0 is received, which informs the
 *        application that the buffer is no more used by the Bluetooth stack.
 * @retval Value indicating success or error code.
 */
tBleStatus ll_set_scan_reponse_data_ptr(uint16_t Advertising_Handle,
                                        uint16_t Scan_Response_Data_Length,
                                        uint8_t Scan_Response_Data[]);
/**
 * @brief Retrieves info about an existing advertising set.
 * @param Advertising_Handle Used to identify an advertising set.
 *        Values:
 *        - 0x0000 ... 0x00EF
 * @param[out] Adv_Enabled It is 1 (TRUE) if advertising is enabled for the
 *             given advertising handle, 0 (FALSE) otherwise.
 * @param[out] Periodic_Adv_Configured It is 1 (TRUE) if periodic advertising
 *             has been configured for the given advertising handle, 0 (FALSE)
 *             otherwise.
 * @param[out] Periodic_Adv_Enabled It is 1 (TRUE) if periodic advertising has
 *             been enabled for the given advertising handle, 0 (FALSE)
 *             otherwise. Note: periodic advertising may be enabled but not
 *             started; in this case Adv_Enabled is false and
 *             Periodic_Adv_Enable is true.
 * @param[out] Advertising_Event_Properties Advertising event properties that
 *             have been previously set for the advertising set.
 * @retval Value indicating success or error code.
 */
tBleStatus ll_get_advertising_info(uint16_t Advertising_Handle,
                                   uint8_t *Adv_Enabled,
                                   uint8_t *Periodic_Adv_Configured,
                                   uint8_t *Periodic_Adv_Enabled,
                                   uint16_t *Advertising_Event_Properties);
/**
 * @brief Set data pointer for periodic extended advertising data.
 * @param Advertising_Handle Used to identify an advertising set. This parameter
 *        is only meaningful if Extended Advertising Feature is enabled.
 *        Values:
 *        - 0x0000 ... 0x00EF
 * @param Operation If set to Unchanged data, just update the Advertising DID.
 *        Values:
 *        - 0x03: Complete data
 *        - 0x04: Unchanged data
 * @param Advertising_Data_Length Length of periodic advertising data.
 * @param Advertising_Data Pointer to the buffer containing properly formatted
 *        periodic advertising data (see Core v5.2 Vol 3, part C, chapter 11).
 *        Its content must not change, until an
 *        aci_hal_adv_scan_resp_data_update_event_rp0 is received, which informs the
 *        application that the buffer is no more used by the Bluetooth stack.
 * @retval Value indicating success or error code.
 */
tBleStatus ll_set_periodic_advertising_data_ptr(uint16_t Advertising_Handle,
                                                uint8_t Operation,
                                                uint16_t Advertising_Data_Length,
                                                uint8_t Advertising_Data[]);
/**
 * @brief Function to get the value of the last anchor point for the given
 *        connection.
 * @param Connection_Handle
 * @param[out] Event_Counter
 * @param[out] Anchor_Point
 * @retval Value indicating success or error code.
 */
tBleStatus aci_hal_get_anchor_point(uint16_t Connection_Handle,
                                    uint16_t *Event_Counter,
                                    uint32_t *Anchor_Point);
/**
 * @brief
 * @param Advertising_Handle It is used to identify an advertising set
 *        Values:
 *        - 0x00 ... 0xEF: Used to identify an advertising set
 * @param Num_Subevents Number of subevent data in the command.
 *        Values:
 *        - 0x01 ... 0x0F
 * @param Subevent_Data_Ptr_Parameters See @ref Subevent_Data_Ptr_Parameters_t
 * @retval Value indicating success or error code.
 */
tBleStatus ll_set_periodic_advertising_subevent_data_ptr(uint8_t Advertising_Handle,
                                                         uint8_t Num_Subevents,
                                                         Subevent_Data_Ptr_Parameters_t Subevent_Data_Ptr_Parameters[]);
/**
 * @brief The LL_Set_Periodic_Advertising_Response_Data_Ptr command is used by
 *        the Host to set the data for a response slot in a specific subevent of
 *        the PAwR identified by the Sync_Handle. The data for a response slot
 *        shall be transmitted only once. The Request_Event parameter identifies
 *        the periodic advertising event in which the periodic advertising
 *        packet that the Host is responding to was received. The
 *        Request_Subevent parameter identifies the subevent in which the
 *        periodic advertising packet that the Host is responding to was
 *        received. The Response_Subevent parameter identifies the subevent that
 *        the response shall be sent in. The Response_Slot parameter identifies
 *        the response slot in the subevent identified by the Response_Subevent
 *        parameter in which this response data is to be transmitted. The
 *        Response_Data_Length specifies the length of the Response_Data that is
 *        significant. The Response_Data contains the advertising data to be
 *        transmitted in the response slot. If the Response_Data_Length is
 *        greater than the maximum that the Controller can transmit within the
 *        response slot, then the Response_Data shall be discarded and the
 *        Controller shall return the error code Packet Too Long (0x45). If
 *        advertising on the LE Coded PHY, then the S=8 coding shall be assumed
 *        unless the current advertising parameters require the use of S=2 for
 *        an advertising physical channel, in which case the S=2 coding shall be
 *        assumed for that advertising physical channel. If the response slot
 *        identified by the Response_Slot parameter has passed by the time this
 *        command is received by the Controller, the Controller shall return the
 *        error code Too Late (0x46) and discard the Response_Data parameter.
 * @param Sync_Handle Sync_Handle identifying the PAwR train.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Request_Event The value of paEventCounter (see [Vol 6] Part B, Section
 *        4.4.2.1) for the periodic advertising packet that the Host is
 *        responding to.
 * @param Request_Subevent Used to identify the subevent of the PAwR train.
 *        Values:
 *        - 0x00 ... 0x7F
 * @param Response_Subevent Used to identify the response slot of the PAwR
 *        train.
 * @param Response_Slot Used to identify the response slot of the PAwR train.
 * @param Response_Data_Length The number of octets in the Response_Data
 *        parameter.
 *        Values:
 *        - 0x00 ... 0xFB
 * @param Response_Data Pointer to response data formatted as defined in [Vol 3]
 *        Part C, Section 11.
 * @retval Value indicating success or error code.
 */
tBleStatus ll_set_periodic_advertising_response_data_ptr(uint16_t Sync_Handle,
                                                         uint16_t Request_Event,
                                                         uint8_t Request_Subevent,
                                                         uint8_t Response_Subevent,
                                                         uint8_t Response_Slot,
                                                         uint8_t Response_Data_Length,
                                                         uint8_t* Response_Data);
/**
 * @}
 */

/**
 * @}
 */


/**
 *@addtogroup GAP GAP
 *@brief Generic Access Profile.
 *@{
 */
/**
 *@defgroup ACI_GAP_Commands ACI GAP Commands
 * Commands for GAP layer.
 *@{
 */
/**
 * @brief Initialize the GAP layer.   WARNING: A section of the Flash memory is
 *        used by this procedure. When this section is empty, data are written
 *        inside. This normally happens once during the lifetime of the device,
 *        when the command is executed for the first time (unless the section is
 *        erased). Do not power off the device while this function is writing
 *        into Flash memory.
 * @param Privacy_Type Specify if privacy is enabled or not and which one .
 *        Values:
 *        - 0x00: Privacy disabled
 *        - 0x01: Privacy host enabled
 *        - 0x02: Privacy controller enabled
 * @param Identity_Address_Type Specify which address has to be used as Identity
 *        Address. 0x00: The public address is used as identity address 0x01:
 *        The static random address is used as identity address
 *        Values:
 *        - 0x00: Public Address
 *        - 0x01: Static Random Address
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_init(uint8_t Privacy_Type,
                        uint8_t Identity_Address_Type);
/**
 * @brief Set the IO capabilities of the device. This command cannot be sent
 *        during a pairing procedure.
 * @param IO_Capability IO capability of the device.
 *        Values:
 *        - 0x00: IO_CAP_DISPLAY_ONLY
 *        - 0x01: IO_CAP_DISPLAY_YES_NO
 *        - 0x02: IO_CAP_KEYBOARD_ONLY
 *        - 0x03: IO_CAP_NO_INPUT_NO_OUTPUT
 *        - 0x04: IO_CAP_KEYBOARD_DISPLAY
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_set_io_capability(uint8_t IO_Capability);
/**
 * @brief This command shall be given to set security requirements at device
 *        level. MITM_Mode setting will be used only when responding to an
 *        incoming Peripheral Security Request or Pairing Request received from
 *        peer device.   It is recommended to force the use of Secure
 *        Connections for pairing by using Secure Connections Only Mode, since
 *        it is the only way to protect the pairing from passive eavesdropping.
 *        The Pairing_Response parameter is used to control the way a pairing is
 *        accepted. If set to 0 (pairing response not required), pairing is
 *        always accepted, even for bonded devices, and no user interaction is
 *        required, since the response is automatically handled by the Stack
 *        Library.  If set to 1 (pairing response required for bonded devices
 *        only), the pairing is automatically accepted (no user interaction)
 *        except when the request comes from an already bonded device; in this
 *        case aci_gap_pairing_event_rp0 is notified and the application has to give
 *        a confirmation through aci_gap_pairing_resp to accept the request to
 *        rebond. If Pairing_Response is set to 2 (explicit pairing response) a
 *        pairing confirmation is always required since aci_gap_pairing_event_rp0 is
 *        always raised when a Pairing Request from a Central or a Peripheral
 *        Security Request form a Peripheral is received.   If the command is
 *        given during pairing, the command returns BLE_STATUS_NOT_ALLOWED.  The
 *        command returns BLE_STATUS_INVALID_PARAMS if some of the parameters
 *        are out of admitted range. If KeyPress_Notification_Support is set to
 *        1 but Secure Connection feature is not supported,
 *        BLE_ERROR_UNSUPPORTED_FEATURE is returned.
 * @param Bonding_Mode Bonding mode. Only if bonding is enabled (0x01), the
 *        bonding information is stored in flash
 *        Values:
 *        - 0x00: NO_BONDING
 *        - 0x01: BONDING
 * @param MITM_Mode MITM mode.
 *        Values:
 *        - 0x00: MITM_PROTECTION_NOT_REQUIRED
 *        - 0x01: MITM_PROTECTION_REQUIRED
 * @param SC_Support LE Secure connections support. Secure Connections Only Mode
 *        (0x02) is the recommended value. However it is no compatible with old
 *        devices not supporting LE Secure Connections. - 0x00: Secure
 *        Connections Pairing not supported. - 0x01: Secure Connections Pairing
 *        supported but optional. - 0x02: Secure Connections Pairing supported
 *        and mandatory (SC Only Mode). This is the recommended value.
 *        Values:
 *        - 0x00: GAP_SC_NOT_SUPPORTED
 *        - 0x01: GAP_SC_OPTIONAL
 *        - 0x02: GAP_SC_MANDATORY
 * @param KeyPress_Notification_Support Keypress notification support
 *        Values:
 *        - 0x00: GAP_KEYPRESS_NOT_SUPPORTED
 *        - 0x01: GAP_KEYPRESS_SUPPORTED
 * @param Min_Encryption_Key_Size Minimum encryption key size to be used during
 *        pairing
 *        Values:
 *        - 7 ... 16
 * @param Max_Encryption_Key_Size Maximum encryption key size to be used during
 *        pairing
 *        Values:
 *        - 7 ... 16
 * @param Pairing_Response This parameter controls how pairing confirmation is
 *        managed.
 *        Values:
 *        - 0x00: GAP_PAIRING_RESP_NONE
 *        - 0x01: GAP_PAIRING_RESP_FOR_BONDED_DEVICES
 *        - 0x02: GAP_PAIRING_RESP_FOR_ALL
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_set_security_requirements(uint8_t Bonding_Mode,
                                             uint8_t MITM_Mode,
                                             uint8_t SC_Support,
                                             uint8_t KeyPress_Notification_Support,
                                             uint8_t Min_Encryption_Key_Size,
                                             uint8_t Max_Encryption_Key_Size,
                                             uint8_t Pairing_Response);
/**
 * @brief This command should be send by the host in response to @ref
 *        aci_gap_passkey_req_event_rp0 event. The command parameter contains the
 *        pass key which will be used during the pairing process.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Passkey Pass key that will be used during the pairing process.  Must
 *        be a six-digit decimal number.
 *        Values:
 *        - 0 ... 999999
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_passkey_resp(uint16_t Connection_Handle,
                                uint32_t Passkey);
/**
 * @brief This command sets the security level for the given connection (LE
 *        security mode 1), by enabling encryption if needed. It will just
 *        enable encryption on the link if the peer is bonded with at least the
 *        specified security level. Otherwise, it will start a pairing with the
 *        peer device. This command may be given either on a Central or on a
 *        Peripheral device.  The Security_Level indicates the minimum Security
 *        Level to be achieved: 1 for no security (no authentication or
 *        encryption), 2 for unauthenticated pairing with encryption, 3 for
 *        authenticated pairing with encryption, 4 for authenticated LE Secure
 *        Connections pairing with encryption using a 128-bit strength
 *        encryption key.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Security_Level Indicates the minimum Security Level to be achieved.
 *        Values:
 *        - 0x01: GAP_SECURITY_LEVEL_1
 *        - 0x02: GAP_SECURITY_LEVEL_2
 *        - 0x03: GAP_SECURITY_LEVEL_3
 *        - 0x04: GAP_SECURITY_LEVEL_4
 * @param Force_Pairing
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_set_security(uint16_t Connection_Handle,
                                uint8_t Security_Level,
                                uint8_t Force_Pairing);
/**
 * @brief This command can be used to get the current security settings of the
 *        device.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param[out] Security_Mode Security mode.
 *             Values:
 *             - 0x01: Security Mode 1
 *             - 0x02: Security Mode 2
 * @param[out] Security_Level Security Level.
 *             Values:
 *             - 0x01: Security Level 1
 *             - 0x02: Security Level 2
 *             - 0x03: Security Level 3
 *             - 0x04: Security Level 4
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_get_security_level(uint16_t Connection_Handle,
                                      uint8_t *Security_Mode,
                                      uint8_t *Security_Level);
/**
 * @brief
 * @param LE_Event_Mask LE event mask. Default: 0x000000000000001F.
 *        Flags:
 *        - 0x0000000000000000: No LE events specified
 *        - 0x0000000000000001: LE Connection Complete Event
 *        - 0x0000000000000002: LE Advertising Report Event
 *        - 0x0000000000000004: LE Connection Update Complete Event
 *        - 0x0000000000000008: LE Read Remote Used Features Complete Event
 *        - 0x0000000000000010: LE Long Term Key Request Event
 *        - 0x0000000000000020: LE Remote Connection Parameter Request Event
 *        - 0x0000000000000040: LE Data Length Change Event
 *        - 0x0000000000000080: LE Read Local P-256 Public Key Complete Event
 *        - 0x0000000000000100: LE Generate DHKey Complete Event
 *        - 0x0000000000000200: LE Enhanced Connection Complete Event
 *        - 0x0000000000000400: LE Directed Advertising Report Event
 *        - 0x0000000000000800: LE PHY Update Complete event
 *        - 0x0000000000001000: LE Extended Advertising Report event
 *        - 0x0000000000002000: LE Periodic Advertising Sync Established event
 *        - 0x0000000000004000: LE Periodic Advertising Report event
 *        - 0x0000000000008000: LE Periodic Advertising Sync Lost event
 *        - 0x0000000000010000: LE Scan Timeout event
 *        - 0x0000000000020000: LE Advertising Set Terminated event
 *        - 0x0000000000040000: LE Scan Request Received event
 *        - 0x0000000000080000: LE Channel Selection Algorithm event
 *        - 0x0000000000100000: LE Connectionless IQ Report event
 *        - 0x0000000000200000: LE Connection IQ Report event
 *        - 0x0000000000400000: LE CTE Request Failed event
 *        - 0x0000000000800000: LE Periodic Advertising Sync Transfer Received event
 *        - 0x0000000001000000: LE CIS Established event
 *        - 0x0000000002000000: LE CIS Request event
 *        - 0x0000000004000000: LE Create BIG Complete event
 *        - 0x0000000008000000: LE Terminate BIG Complete event
 *        - 0x0000000010000000: LE BIG Sync Established event
 *        - 0x0000000020000000: LE BIG Sync Lost event
 *        - 0x0000000040000000: LE Request Peer SCA Complete event
 *        - 0x0000000080000000: LE Path Loss Threshold event
 *        - 0x0000000100000000: LE Transmit Power Reporting event
 *        - 0x0000000200000000: LE BIGInfo Advertising Report event
 *        - 0x0000000400000000: LE Subrate Change event
 *        - 0x0000000800000000: LE Periodic Advertising Sync Established event [v2]
 *        - 0x0000001000000000: LE Periodic Advertising Report event [v2]
 *        - 0x0000002000000000: LE Periodic Advertising Sync Transfer Received event [v2]
 *        - 0x0000004000000000: LE Periodic Advertising Subevent Data Request event
 *        - 0x0000008000000000: LE Periodic Advertising Response Report event
 *        - 0x0000010000000000: LE Enhanced Connection Complete event [v2]
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_set_le_event_mask(uint8_t LE_Event_Mask[8]);
/**
 * @brief Command the controller to terminate the connection. A @ref
 *        hci_disconnection_complete_event_rp0 will be generated when the link is
 *        disconnected. After this event is received, the Bluetooth stack may
 *        request to save GATT database information in non-volatile memory. So
 *        it is important not to reset or power off the system immediately after
 *        @ref hci_disconnection_complete_event_rp0 is received. This operation is
 *        normally completed within less than few milliseconds.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Reason The reason for ending the connection.
 *        Values:
 *        - 0x05: Authentication Failure
 *        - 0x13: Remote User Terminated Connection
 *        - 0x14: Remote Device Terminated Connection due to Low Resources
 *        - 0x15: Remote Device Terminated Connection due to Power Off
 *        - 0x1A: Unsupported Remote Feature
 *        - 0x3B: Unacceptable Connection Parameters
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_terminate(uint16_t Connection_Handle,
                             uint8_t Reason);
/**
 * @brief Clear the security database. All the devices in the security database
 *        will be removed. ATTENTION: It is strongly recommended not to give
 *        this command during intense radio activity (e.g. during advertising or
 *        connection with short intervals, i.e. less than 30 ms, or during
 *        scanning), since it will trigger an erase of a Flash sector. After
 *        this command, all devices previously recorded in the bonding table and
 *        connected when command has been submitted will remain connected,
 *        preserving authentication and encryption of the link.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_clear_security_db(void);
/**
 * @brief This command shall be given in response to an aci_gap_paring_event_rp0, to
 *        allow or reject either the pairing request from the Central or the
 *        security request from the Peripheral.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Accept
 *        Values:
 *        - 0x00: REJECT
 *        - 0x01: ACCEPT
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_pairing_resp(uint16_t Connection_Handle,
                                uint8_t Accept);
/**
 * @brief Creates a direct connection to a device.
 * @param Initiating_PHY PHYs that will be used for initiating the connection.
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param Peer_Address_Type The Peer_Address_Type parameter indicates the type
 *        of address used in the connectable advertisement sent by the peer. 0:
 *        Public Device Address or Public Identity Address 1: Random Device
 *        Address or Random (static) Identity Address
 *        Values:
 *        - 0x00: Public Address
 *        - 0x01: Random Address
 * @param Peer_Address Public Device Address, Random Device Address, Public
 *        Identity Address, or Random (static) Identity Address of the device to
 *        be connected.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_create_connection(uint8_t Initiating_PHY,
                                     uint8_t Peer_Address_Type,
                                     uint8_t Peer_Address[6]);
/**
 * @brief Terminate the specified GAP procedure. An @ref
 *        aci_gap_proc_complete_event_rp0 event is generated when the procedure has
 *        been completed, with the procedure code set to the corresponding
 *        procedure.
 * @param Procedure_Code Code identifying the procedure.
 *        Values:
 *        - 0x00: GAP_LIMITED_DISCOVERY_PROC
 *        - 0x01: GAP_GENERAL_DISCOVERY_PROC
 *        - 0x02: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC
 *        - 0x03: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC
 *        - 0x04: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC
 *        - 0x05: GAP_OBSERVATION_PROC
 *        - 0x06: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC
 *        - 0x07: GAP_NAME_DISCOVERY_PROC
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_terminate_proc(uint8_t Procedure_Code);
/**
 * @brief Start the connection update procedure (only when role is Central). A
 *        @ref hci_le_connection_update is called. On completion of the
 *        procedure, an @ref hci_le_connection_update_complete_event_rp0 event is
 *        returned to the upper layer.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Connection_Interval_Min Minimum value for the connection event
 *        interval. This shall be less than or equal to Connection_Interval_Max.
 *        Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Connection_Interval_Max Maximum value for the connection event
 *        interval. This shall be greater than or equal to
 *        Connection_Interval_Min. Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Max_Latency Maximum Peripheral latency for the connection in number of
 *        connection events.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Supervision_Timeout Supervision timeout for the LE Link. It shall be a
 *        multiple of 10 ms and larger than (1 + connPeripheralLatency) *
 *        connInterval * 2. Time = N * 10 msec.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 * @param Min_CE_Length The minimum length of connection event recommended for
 *        this LE connection. Time = N * 0.625 msec.
 * @param Max_CE_Length The maximum length of connection event recommended for
 *        this LE connection. Time = N * 0.625 msec.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_start_connection_update(uint16_t Connection_Handle,
                                           uint16_t Connection_Interval_Min,
                                           uint16_t Connection_Interval_Max,
                                           uint16_t Max_Latency,
                                           uint16_t Supervision_Timeout,
                                           uint16_t Min_CE_Length,
                                           uint16_t Max_CE_Length);
/**
 * @brief This command tries to resolve the address provided with the IRKs
 *        present in its database. If the address is resolved successfully with
 *        any one of the IRKs present in the database, it returns success and
 *        also the corresponding public/static random address stored with the
 *        IRK in the database.
 * @param Address Address to be resolved
 * @param[out] Actual_Address The public or static random address of the peer
 *             device, distributed during pairing phase.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_resolve_private_addr(uint8_t Address[6],
                                        uint8_t Actual_Address[6]);
/**
 * @brief This command returns the identity addresses of the bonded devices.
 * @param Offset Index of the first record to be returned.
 * @param Max_Num_Of_Addresses Used to specify the maximum number of devices to
 *        be returned.
 * @param[out] Num_of_Addresses The number of bonded devices returned by this
 *             command.
 * @param[out] Bonded_Device_Entry See @ref Bonded_Device_Entry_t
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_get_bonded_devices(uint8_t Offset,
                                      uint8_t Max_Num_Of_Addresses,
                                      uint8_t *Num_of_Addresses,
                                      Bonded_Device_Entry_t Bonded_Device_Entry[]);
/**
 * @brief The command finds whether the device, whose address is specified in
 *        the command, is bonded. If the device is using a resolvable private
 *        address and it has been bonded, then the command will return
 *        BLE_STATUS_SUCCESS.
 * @param Peer_Address_Type Address type.
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 * @param Peer_Address Address used by the peer device while advertising
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_is_device_bonded(uint8_t Peer_Address_Type,
                                    uint8_t Peer_Address[6]);
/**
 * @brief This command allows the User to validate/confirm or not the Numeric
 *        Comparison value showed through the
 *        ACI_GAP_Numeric_Comparison_Value_Event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Confirm_Yes_No 0 : The Numeric Values showed on both local and peer
 *        device are different! 1 : The Numeric Values showed on both local and
 *        peer device are equal!
 *        Values:
 *        - 0x00: No
 *        - 0x01: YES
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_numeric_comparison_value_confirm_yesno(uint16_t Connection_Handle,
                                                          uint8_t Confirm_Yes_No);
/**
 * @brief This command permits to signal to the Stack the input type detected
 *        during Passkey input.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Input_Type Passkey input type detected
 *        Values:
 *        - 0x00: Passkey entry started
 *        - 0x01: Passkey digit entered
 *        - 0x02: Passkey digit erased
 *        - 0x03: Passkey cleared
 *        - 0x04: Passkey entry completed
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_passkey_input(uint16_t Connection_Handle,
                                 uint8_t Input_Type);
/**
 * @brief This command can be used to get the local OOB authentication for LE
 *        Secure connections or the remote Temporary Key for Legacy Pairing set
 *        through aci_gap_set_oob_data(). This command is particularly useful in
 *        case of LE Secure Connections to retrieve the local OOB data generated
 *        with aci_gap_set_oob_data(). This data should then be sent to the peer
 *        through the OOB channel.
 * @param OOB_Data_Type OOB Data type. - 0x00: Legacy Pairing (LP) v.4.1 TK
 *        (Temporary Key) - 0x01: Secure Connections (SC) v.4.2 Random value r
 *        used for generation of Confirm value - 0x02: Secure Connections (SC)
 *        v.4.2 Confirm value C generated through AES-CMAC-128 based
 *        cryptographic function: C=f4(PKx, PKx, r, 0)
 *        Values:
 *        - 0x00: SM_TK
 *        - 0x01: SM_RANDOM_VALUE
 *        - 0x02: SM_CONFIRM_VALUE
 * @param[out] Address_Type Identity address type.
 *             Values:
 *             - 0x00: Public Identity Address
 *             - 0x01: Random (static) Identity Address
 * @param[out] Address Public or Random (static) address of this device
 * @param[out] OOB_Data_Len Length of OOB Data carried by next data field
 * @param[out] OOB_Data OOB Data to be exported via OOB.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_get_oob_data(uint8_t OOB_Data_Type,
                                uint8_t *Address_Type,
                                uint8_t Address[6],
                                uint8_t *OOB_Data_Len,
                                uint8_t OOB_Data[16]);
/**
 * @brief This command can be used to input the Authentication data exchanged
 *        via OOB channel: either local authentication data to be sent to the
 *        peer device through the OOB channel or the peer device authentication
 *        data received through OOB channel. Moreover, it can also be used to
 *        generate authentication data for LE Secure Connections.  Device_Type
 *        must be set to 0x00 (Local Device) to provide or generate local
 *        authentication data that will be sent to the peer through OOB channel.
 *        In this case Address_Type and Address parameters are ignored. With
 *        Device_Type=0 and OOB_Data_Len=0x00, OOB_Data_Type is ignored and the
 *        command triggers an automatic generation of OOB Authentication data r
 *        and C (that can be read with aci_gap_get_oob_data()), used for Secure
 *        Connections, otherwise the OOB_Data carried by the command will
 *        overwrite the current local authentication OOB Data. To generate OOB
 *        authentication data, the stack requires the availability of the local
 *        Public Key, to be previously generated with
 *        hci_le_read_local_p256_public_key command.  When peer authentication
 *        data are received through OOB channel for either Legacy Pairing or
 *        Secure Connections, aci_gap_set_oob_data() must be called with
 *        Device_Type set to 0x01 (Remote Device): the command will set the OOB
 *        data for the specified remote device (only one device at a time is
 *        supported).  For Legacy pairing, the TK must be provided as both local
 *        and remote data.
 * @param Device_Type If Device_Type is 0x00 (Local Device), it sets the local
 *        OOB authentication data. If Device_Type is 0x01 (Remote Device), the
 *        command sets the OOB data for the specified remote device (only one
 *        device at a time is supported).
 *        Values:
 *        - 0x00: Local device
 *        - 0x01: Remote device
 * @param Address_Type Identity address type of the remote device. Ignored if
 *        Device_Type is 0.
 *        Values:
 *        - 0x00: Public Identity Address
 *        - 0x01: Random (static) Identity Address
 * @param Address Public or Random (static) address of the peer device. Ignored
 *        if Device_Type is 0.
 * @param OOB_Data_Type OOB Data type. - 0x00: Legacy Pairing (LP) v.4.1 TK
 *        (Temporary Key) - 0x01: Secure Connections (SC) v.4.2 Random value r
 *        used for generation of Confirm value - 0x02: Secure Connections (SC)
 *        v.4.2 Confirm value C generated through AES-CMAC-128 based
 *        cryptographic function: C=f4(PKx, PKx, r, 0)
 *        Values:
 *        - 0x00: SM_TK
 *        - 0x01: SM_RANDOM_VALUE
 *        - 0x02: SM_CONFIRM_VALUE
 * @param OOB_Data_Len Length of OOB Data carried by next data field. It may be
 *        set to 0x00 to trigger the automatic generation of local Random and
 *        Confirm values for LE Secure Connections pairing.
 *        Values:
 *        - 0x00 ... 0x10
 * @param OOB_Data OOB Data to be exported via OOB.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_set_oob_data(uint8_t Device_Type,
                                uint8_t Address_Type,
                                uint8_t Address[6],
                                uint8_t OOB_Data_Type,
                                uint8_t OOB_Data_Len,
                                uint8_t OOB_Data[16]);
/**
 * @brief This command can be used to remove a specified device from the bonding
 *        table. ATTENTION: the device removed from the Bonding Table will
 *        preserve its connection and authentication, until explicit
 *        disconnection is requested by the user.
 * @param Peer_Identity_Address_Type Identity address type.
 *        Values:
 *        - 0x00: Public Identity Address
 *        - 0x01: Random (static) Identity Address
 * @param Peer_Identity_Address Public or Random (static) Identity address of
 *        the peer device
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_remove_bonded_device(uint8_t Peer_Identity_Address_Type,
                                        uint8_t Peer_Identity_Address[6]);
/**
 * @brief This commands configures the advertising parameters for the legacy
 *        advertising or for a given extended advertising set. For general or
 *        limited discoverable mode or connectable advertising, Flags AD type
 *        must be present in advertising data. See also Bluetooth Core
 *        specifications, Vol. 4, part E, section 7.8.53 (LE Set Extended
 *        Advertising Parameters command).
 * @param Advertising_Handle Used to identify an advertising set. This parameter
 *        is only meaningful if Extended Advertising Feature is enabled.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Discoverable_Mode Specifies the discoverable mode of the device.
 *        Values:
 *        - 0: Not Discoverable
 *        - 1: Limited Discoverable
 *        - 2: General Discoverable
 *        - 3: Broadcast
 * @param Advertising_Event_Properties The Advertising_Event_Properties
 *        parameter describes the type of advertising event that is being
 *        configured and its basic properties according to V5.1, Vol 2, Part E,
 *        section 7.8.53.
 *        Flags:
 *        - 0x0001: Connectable
 *        - 0x0002: Scannable
 *        - 0x0004: Directed
 *        - 0x0008: High Duty Cycle Directed Connectable
 *        - 0x0010: Legacy
 *        - 0x0020: Anonymous
 *        - 0x0040: Include TX Power
 * @param Primary_Advertising_Interval_Min Minimum advertising interval for
 *        undirected and low duty cycle directed advertising. Time = N * 0.625
 *        msec.
 *        Values:
 *        - 0x00000020 (20.000 ms)  ... 0x00FFFFFF (10485759.375 ms) 
 * @param Primary_Advertising_Interval_Max Maximum advertising interval for
 *        undirected and low duty cycle directed advertising. Time = N * 0.625
 *        msec.
 *        Values:
 *        - 0x00000020 (20.000 ms)  ... 0x00FFFFFF (10485759.375 ms) 
 * @param Primary_Advertising_Channel_Map It is a bit field that indicates the
 *        advertising channels that shall be used when transmitting advertising
 *        packets.
 *        Flags:
 *        - 0x01: CH_37
 *        - 0x02: CH_38
 *        - 0x04: CH_39
 * @param Peer_Address_Type The peer address type.
 *        Values:
 *        - 0x00: Public
 *        - 0x01: Random
 * @param Peer_Address Public Device Address, Random Device Address, Public
 *        Identity Address, or Random (static) Identity Address of the device to
 *        be connected.
 * @param Advertising_Filter_Policy Advertising Filter Policy. If Directed
 *        advertising is selected, the Peer_Address_Type and Peer_Address shall
 *        be valid and the Advertising_Filter_Policy parameter shall be ignored.
 *        0x00 Process scan and connection requests from all devices (i.e., the
 *        Filter Accept List is not in use) 0x01 Process connection requests
 *        from all devices and scan requests only from devices that are in the
 *        Filter Accept List 0x02 Process scan requests from all devices and
 *        connection requests only from devices that are in the Filter Accept
 *        List. 0x03 Process scan and connection requests only from devices in
 *        the Filter Accept List. All other values Reserved for future use
 *        Values:
 *        - 0x00: Scan and Connection requests from any
 *        - 0x01: Connection requests from any, scan requests from Filter Accept List only
 *        - 0x02: Scan requests from any, connection requests from Filter Accept List only
 *        - 0x03: Scan and connection requests from Filter Accept List only
 * @param Advertising_Tx_Power The Advertising_Tx_Power parameter indicates the
 *        maximum power level at which the advertising packets are to be
 *        transmitted on the advertising channels. The Controller shall choose a
 *        power level lower than or equal to the one specified by the Host.
 *        (Units: dBm). This parameter is ignored if extended advertising is not
 *        enabled.
 *        Values:
 *        - -127 ... 126
 *        - 127: No preference
 * @param Primary_Advertising_PHY The Primary_Advertising_PHY parameter
 *        indicates the PHY on which the advertising packets are transmitted on
 *        the primary advertising channel. If legacy advertising PDUs are being
 *        used, the Primary_Advertising_PHY shall indicate the LE 1M PHY. This
 *        parameter is ignored if extended advertising is not enabled.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x03: LE_CODED_PHY
 * @param Secondary_Advertising_Max_Skip The Secondary_Advertising_Max_Skip
 *        parameter is the maximum number of advertising events that can be
 *        skipped before the AUX_ADV_IND can be sent. This parameter is ignored
 *        if extended advertising is not enabled. 0x00 AUX_ADV_IND shall be sent
 *        prior to the next advertising event 0x01-0xFF Maximum advertising
 *        events the Controller can skip before sending the AUX_ADV_IND packets
 *        on the secondary advertising channel
 * @param Secondary_Advertising_PHY The Secondary_Advertising_PHY parameter
 *        indicates the PHY on which the advertising packets are be transmitted
 *        on the secondary advertising channel. This parameter is ignored if
 *        extended advertising is not enabled.
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY
 * @param Advertising_SID The Advertising_SID parameter specifies the value to
 *        be transmitted in the Advertising SID subfield of the ADI field of the
 *        Extended Header of those advertising channel PDUs that have an ADI
 *        field. If the advertising set only uses PDUs that do not contain an
 *        ADI field, Advertising_SID is ignored. This parameter is ignored if
 *        extended advertising is not enabled.
 *        Values:
 *        - 0x00 ... 0x0F
 * @param Scan_Request_Notification_Enable The Scan_Request_Notification_Enable
 *        parameter indicates whether the Controller shall send notifications
 *        upon the receipt of a scan request PDU that is in response to an
 *        advertisement from the specified advertising set that contains its
 *        device address and is from a scanner that is allowed by the
 *        advertising filter policy. This parameter is ignored if extended
 *        advertising is not enabled.
 *        Values:
 *        - 0x00: Scan request notifications disabled
 *        - 0x01: Scan request notifications enabled
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_set_advertising_configuration(uint8_t Advertising_Handle,
                                                 uint8_t Discoverable_Mode,
                                                 uint16_t Advertising_Event_Properties,
                                                 uint32_t Primary_Advertising_Interval_Min,
                                                 uint32_t Primary_Advertising_Interval_Max,
                                                 uint8_t Primary_Advertising_Channel_Map,
                                                 uint8_t Peer_Address_Type,
                                                 uint8_t Peer_Address[6],
                                                 uint8_t Advertising_Filter_Policy,
                                                 int8_t Advertising_Tx_Power,
                                                 uint8_t Primary_Advertising_PHY,
                                                 uint8_t Secondary_Advertising_Max_Skip,
                                                 uint8_t Secondary_Advertising_PHY,
                                                 uint8_t Advertising_SID,
                                                 uint8_t Scan_Request_Notification_Enable);
/**
 * @brief This command is used to request the Controller to enable or disable
 *        one or more advertising sets using the advertising sets identified by
 *        the Advertising_Handle[i] parameter. The Controller manages the timing
 *        of advertisements in accordance with the advertising parameters given
 *        with @ref aci_gap_set_advertising_configuration command. Only the
 *        Enable parameter is used if extended advertising feature is disabled
 *        through modular configuration (CONTROLLER_EXT_ADV_SCAN_ENABLED=0),
 *        others are ignored. The command returns an error if adverting data are
 *        not set properly, according to the used discoverable mode: Flags AD
 *        type may be required (see @ref aci_gap_set_advertising_data). An error
 *        is also returned if either the length of advertising data is greater
 *        than 245 octets and advertising type is connectable, or if no scan
 *        response data is set and advertising type is scannable. See also
 *        Bluetooth Core specifications, Vol. 4, part E, section 7.8.56 (LE Set
 *        Extended Advertising Enable command).
 * @param Enable It allows to enable or disable one or more advertising sets
 *        using the advertising sets identified by the Advertising_Handle[i]
 *        parameter.
 *        Values:
 *        - 0x00: Disable
 *        - 0x01: Enable
 * @param Number_of_Sets The Number_of_Sets parameter is the number of
 *        advertising sets contained in the parameter arrays. 0x00: Disable all
 *        advertising sets 0x01 to 0x3F: Number of advertising sets to enable or
 *        disable. Ignored if extended advertising feature is disabled through
 *        modular configuration (CONTROLLER_EXT_ADV_SCAN_ENABLED=0).
 *        Values:
 *        - 0x00: Disable all sets
 *        - 0x01 ... 0x3F
 * @param Advertising_Set_Parameters See @ref Advertising_Set_Parameters_t
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_set_advertising_enable(uint8_t Enable,
                                          uint8_t Number_of_Sets,
                                          Advertising_Set_Parameters_t Advertising_Set_Parameters[]);
/**
 * @brief The ACI_GAP_SET_SCAN_CONFIGURATION function configures the scan
 *        parameters for a given PHY. To configure more than one PHY, this
 *        function must be called more times.
 * @param Filter_Duplicates The Filter_Duplicates parameter controls whether the
 *        Link Layer should filter out duplicate advertising reports (filtering
 *        duplicates enabled) to the Host or if the Link Layer should generate
 *        advertising reports for each packet received (filtering duplicates
 *        disabled). See [Vol 6] Part B, Section 4.4.3.5.
 *        Values:
 *        - 0x00: Duplicate filtering disabled
 *        - 0x01: Duplicate filtering enabled
 *        - 0x02: Duplicate filtering enabled, reset for each scan period
 * @param Scanning_Filter_Policy 0x00 Accept all advertisement packets. Directed
 *        advertising packets which are not addressed for this device shall be
 *        ignored. 0x01 Ignore advertisement packets from devices not in the
 *        Filter Accept List Only. Directed advertising packets which are not
 *        addressed for this device shall be ignored 0x02 Accept all undirected
 *        advertisement packets. Directed advertisement packets where initiator
 *        address is a RPA and  Directed advertisement packets addressed to this
 *        device shall be accepted. 0x03 Accept all undirected advertisement
 *        packets from devices that are in the Filter Accept List.Directed
 *        advertisement packets where initiator address is RPA and Directed
 *        advertisement packets addressed to this device shall be accepted.
 *        Values:
 *        - 0x00: Accept All
 *        - 0x01: Filter Accept List Only
 *        - 0x02: Accept All (use resolving list)
 *        - 0x03: Filter Accept List Only (use resolving list)
 * @param Scanning_PHY PHY that is going to be configured. Only one bit can be
 *        set.
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param Scan_Type The Scan_Type parameter specifies the type of scan to
 *        perform. 0: Passive Scanning. No scan request PDUs shall be sent. 1:
 *        Active Scanning. Scan request PDUs may be sent.
 *        Values:
 *        - 0x00: Passive Scanning
 *        - 0x01: Active Scanning
 * @param Scan_Interval Time interval from when the Controller started its last
 *        scan until it begins the subsequent scan on the primary advertising
 *        physical channel.  Time = N * 0.625 ms
 *        Values:
 *        - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
 * @param Scan_Window Time interval from when the Controller started its last
 *        scan until it begins the subsequent scan on the primary advertising
 *        physical channel. Time = N * 0.625 msec.
 *        Values:
 *        - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_set_scan_configuration(uint8_t Filter_Duplicates,
                                          uint8_t Scanning_Filter_Policy,
                                          uint8_t Scanning_PHY,
                                          uint8_t Scan_Type,
                                          uint16_t Scan_Interval,
                                          uint16_t Scan_Window);
/**
 * @brief This function configures the connection parameters. To configure more
 *        than one PHY, this function must be called more times.
 * @param Initiating_PHY PHY that is going to be configured. Only one bit can be
 *        set.
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x02: LE_2M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param Connection_Interval_Min Minimum value for the connection event
 *        interval. This shall be less than or equal to Connection_Interval_Max.
 *        Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Connection_Interval_Max Maximum value for the connection event
 *        interval. This shall be greater than or equal to
 *        Connection_Interval_Min. Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Max_Latency Maximum Peripheral latency for the connection in number of
 *        connection events.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Supervision_Timeout Supervision timeout for the LE Link. It shall be a
 *        multiple of 10 ms and larger than (1 + connPeripheralLatency) *
 *        connInterval * 2. Time = N * 10 msec.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 * @param Min_CE_Length The minimum length of connection event recommended for
 *        this LE connection. Time = N * 0.625 msec.
 * @param Max_CE_Length The maximum length of connection event recommended for
 *        this LE connection. Time = N * 0.625 msec.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_set_connection_configuration(uint8_t Initiating_PHY,
                                                uint16_t Connection_Interval_Min,
                                                uint16_t Connection_Interval_Max,
                                                uint16_t Max_Latency,
                                                uint16_t Supervision_Timeout,
                                                uint16_t Min_CE_Length,
                                                uint16_t Max_CE_Length);
/**
 * @brief Starts a GAP procedure according to the procedure code.
 * @param Procedure_Code Procedure to be started.
 *        Values:
 *        - 0x00: GAP_LIMITED_DISCOVERY_PROC
 *        - 0x01: GAP_GENERAL_DISCOVERY_PROC
 *        - 0x02: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC
 *        - 0x03: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC
 *        - 0x04: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC
 *        - 0x05: GAP_OBSERVATION_PROC
 * @param PHYs PHYs that will be used for Scanning or Initiating .
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param Duration Ignored. Reserved for future use.
 * @param Period Ignored. Reserved for future use.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_start_procedure(uint8_t Procedure_Code,
                                   uint8_t PHYs,
                                   uint16_t Duration,
                                   uint16_t Period);
/**
 * @brief Creates a direct connection to a device and read the name
 *        characteristic.
 * @param PHYs PHYs that will be used for initiating the connection.
 *        Flags:
 *        - 0x01: LE_1M_PHY_BIT
 *        - 0x04: LE_CODED_PHY_BIT
 * @param Peer_Address_Type The Peer_Address_Type parameter indicates the type
 *        of address used in the connectable advertisement sent by the peer. 0:
 *        Public Device Address or Public Identity Address 1: Random Device
 *        Address or Random (static) Identity Address
 *        Values:
 *        - 0x00: Public Address
 *        - 0x01: Random Address
 * @param Peer_Address Public Device Address, Random Device Address, Public
 *        Identity Address, or Random (static) Identity Address of the device to
 *        be connected.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_discover_name(uint8_t PHYs,
                                 uint8_t Peer_Address_Type,
                                 uint8_t Peer_Address[6]);
/**
 * @brief Add specific device addresses to the Filter Accept and/or resolving
 *        list.
 * @param Lists Select in which list the device addresses will be added: Filter
 *        Accept List, resolving list or both.
 *        Flags:
 *        - 0x01: Filter Accept List
 *        - 0x02: Resolving List
 * @param Clear_Lists Clear the selected lists before adding the device
 *        addresses.
 *        Values:
 *        - 0x00: Do not clear
 *        - 0x01: Clear before adding
 * @param Num_of_List_Entries Number of devices that have to be added to the
 *        Filter Accept List.
 *        Values:
 *        - 0x00 ... 0xFF
 * @param List_Entry See @ref List_Entry_t
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_add_devices_to_filter_accept_and_resolving_list(uint8_t Lists,
                                                                   uint8_t Clear_Lists,
                                                                   uint8_t Num_of_List_Entries,
                                                                   List_Entry_t List_Entry[]);
/**
 * @brief Clear the specified lists and add all bonded devices.
 * @param Lists Select in which list the device addresses will be added: Filter
 *        Accept List, resolving list or both.
 *        Flags:
 *        - 0x01: Filter Accept List
 *        - 0x02: Resolving List
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_configure_filter_accept_and_resolving_list(uint8_t Lists);
/**
 * @brief The GAP_Remove_Advertising_Set command is used to remove an
 *        advertising set from the Controller. If the advertising set
 *        corresponding to the Advertising_Handle parameter does not exist, then
 *        the Controller shall return the error code Unknown Advertising
 *        Identifier (0x42). If advertising on the advertising set is enabled,
 *        then the Controller shall return the error code Command Disallowed
 *        (0x0C).
 * @param Advertising_Handle It is used to identify an advertising set
 *        Values:
 *        - 0x00 ... 0xEF: Used to identify an advertising set
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_remove_advertising_set(uint8_t Advertising_Handle);
/**
 * @brief The GAP_Clear_Advertising_Sets command is used to remove all existing
 *        advertising sets from the Controller. If advertising is enabled on any
 *        advertising set, then the Controller shall return the error code
 *        Command Disallowed (0x0C). Note: All advertising sets are cleared on
 *        HCI reset.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_clear_advertising_sets(void);
/**
 * @brief This command is used to create a connection between a periodic
 *        advertiser and a synchronized device. See LE Extended Create
 *        Connection [v2] command.
 * @param Advertising_Handle Advertising_Handle identifying the periodic
 *        advertising train.
 *        Values:
 *        - 0x00 ... 0xEF
 *        - 0xFF: Not specified
 * @param Subevent Subevent where the connection request is to be sent.
 *        Values:
 *        - 0x00 ... 0x7F
 *        - 0xFF: Not specified
 * @param Initiator_Filter_Policy The Initiator_Filter_Policy parameter is used
 *        to determine whether the Filter Accept List is used. If the Filter
 *        Accept List is not used, the Peer_Address_Type and the Peer_Address
 *        parameters specify the address type and address of the device to
 *        connect to.  0x00 - Filter Accept List is not used to determine which
 *        device to connect to. Peer_Address_Type and Peer_Address shall be
 *        used. 0x01 - Filter Accept List is used to determine which device to
 *        connect to. Peer_Address_Type and Peer_Address shall be ignored.
 *        Values:
 *        - 0x00: FILTER_ACCEPT_LIST_NOT_USED
 *        - 0x01: FILTER_ACCEPT_LIST_USED
 * @param Own_Address_Type The Own_Address_Type parameter indicates the type of
 *        address being used in the connection request packets.
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the public address.
 *        - 0x03: Controller generates the Resolvable Private Address based on the local
IRK from the resolving list. If the resolving list contains no matching
entry, then use the random address from the most recent successful
LE_Set_Random_Address Command.
 * @param Peer_Address_Type The Peer_Address_Type parameter indicates the type
 *        of address used in the connectable advertisement sent by the peer.
 *        0x00: Public Device Address or Public Identity Address 0x01: Random
 *        Device Address or Random (static) Identity Address
 *        Values:
 *        - 0x00: Public Address
 *        - 0x01: Random Address
 * @param Peer_Address Public Device Address, Random Device Address, Public
 *        Identity Address, or Random (static) Identity Address of the device to
 *        be connected.
 * @param Connection_Interval_Min Minimum value for the connection interval.
 *        This shall be less than or equal to Connection_Interval_Max. Time = N
 *        x 1.25 ms.
 *        Values:
 *        - 0x0006 ... 0x0C80
 * @param Connection_Interval_Max Maximum value for the connection interval.
 *        This shall be greater than or equal to Connection_Interval_Min.  Time
 *        = N x 1.25 ms
 *        Values:
 *        - 0x0006 ... 0x0C80
 * @param Max_Latency Maximum Peripheral latency for the connection in number of
 *        connection events.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Supervision_Timeout Supervision timeout for the LE Link.  Time = N x
 *        10 ms
 *        Values:
 *        - 0x000A ... 0x0C80
 * @param Min_CE_Length The minimum length of connection event recommended for
 *        this LE connection.
 * @param Max_CE_Length The maximum length of connection event recommended for
 *        this LE connection.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_create_periodic_advertising_connection(uint8_t Advertising_Handle,
                                                          uint8_t Subevent,
                                                          uint8_t Initiator_Filter_Policy,
                                                          uint8_t Own_Address_Type,
                                                          uint8_t Peer_Address_Type,
                                                          uint8_t Peer_Address[6],
                                                          uint16_t Connection_Interval_Min,
                                                          uint16_t Connection_Interval_Max,
                                                          uint16_t Max_Latency,
                                                          uint16_t Supervision_Timeout,
                                                          uint16_t Min_CE_Length,
                                                          uint16_t Max_CE_Length);
/**
 * @brief The ACI_GAP_SET_ADVERTISING_DATA function is used to set the data in
 *        advertising PDUs. Data must be formatted as defined in Bluetooth Core
 *        spec Vol. 3 Part C, Section 11.  If the device is in Limited
 *        Discoverable Mode, Flags data type (0x06) in advertising data must
 *        have the flags set as described: - The LE Limited Discoverable Mode
 *        flag set to one. - The 'BR/EDR Not Supported' flag set to one. - All
 *        other flags set to zero.  If the device is in General Discoverable
 *        Mode, Flags data type (0x06) in advertising data must have the flags
 *        set as described: - The LE General Discoverable Mode flag set to one.
 *        - The 'BR/EDR Not Supported' flag set to one. - All other flags set to
 *        zero.  If the device is in one of the other modes, Flags data type
 *        (0x06) in advertising data must have the flags set as described: - The
 *        'BR/EDR Not Supported' flag set to one. - All other flags set to zero.
 *        In this case (none of the discoverable modes is used), Flags data type
 *        may be omitted in advertising data if a device is sending non
 *        connectable events, otherwise it must be present.  For non-legacy
 *        PDUs, length of advertising data is limited to 245 octets in case of
 *        connectable advertising and cannot be present for scannable
 *        advertising. See also Bluetooth Core specifications, Vol. 4, part E,
 *        section 7.8.54 (LE Set Extended Advertising Data command).
 * @param Advertising_Handle Used to identify an advertising set. This parameter
 *        is only meaningful if Extended Advertising Feature is enabled.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Operation If set to Unchanged data, just update the Advertising DID.
 *        Values:
 *        - 0x03: Complete data
 *        - 0x04: Unchanged data
 * @param Advertising_Data_Length Length of advertising data. For legacy PDUs
 *        which supports advertising data maximum value is 31 octets. Data must
 *        be formatted as defined in Bluetooth Core spec Vol. 3 Part C, Section
 *        11.
 * @param Advertising_Data Pointer to the buffer containing properly formatted
 *        advertising data (see Core v5.1 Vol 3, part C, chapter 11). Its
 *        content must not change, until an
 *        aci_hal_adv_scan_resp_data_update_event_rp0 is received, which informs the
 *        application that the buffer is no more used by the Bluetooth stack.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_set_advertising_data(uint8_t Advertising_Handle,
                                        uint8_t Operation,
                                        uint16_t Advertising_Data_Length,
                                        uint8_t Advertising_Data[]);
/**
 * @brief The ACI_GAP_SET_SCAN_RESPONSE_DATA function configures the scan
 *        response data as requested by the application.
 * @param Advertising_Handle Used to identify an advertising set. This parameter
 *        is only meaningful if Extended Advertising Feature is enabled.
 *        Values:
 *        - 0x00 ... 0xEF
 * @param Scan_Response_Data_Length Length of scan response data. If the
 *        advertising set uses scannable legacy advertising PDUs maximum length
 *        is 31 octets.
 * @param Scan_Response_Data Pointer to the buffer containing properly formatted
 *        scan response data (see Core v5.1 Vol 3, part C, chapter 11). Its
 *        content must not change, until an
 *        aci_hal_adv_scan_resp_data_update_event_rp0 is received, which informs the
 *        application that the buffer is no more used by the Bluetooth stack.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_set_scan_response_data(uint8_t Advertising_Handle,
                                          uint16_t Scan_Response_Data_Length,
                                          uint8_t Scan_Response_Data[]);
/**
 * @brief This command is used by the application to encrypt data used in
 *        advertising packets.
 * @param Session_Key The shared session key.
 * @param IV The initialization vector.
 * @param Data_Length Length of data.
 * @param Data Plain data to be encrypted.
 * @param[out] Encrypted_Data Pointer to the buffer that will contain encrypted
 *             data.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_encrypt_adv_data(uint8_t Session_Key[16],
                                    uint8_t IV[8],
                                    uint8_t Data_Length,
                                    uint32_t * Data,
                                    uint8_t *Encrypted_Data);
/**
 * @brief Decrypt encrypted advertsing data.
 * @param Session_Key The shared session key.
 * @param IV The initialization vector.
 * @param Encrypted_Data_Length Length of encrypted data.
 * @param Encrypted_Data Encrypted data.
 * @param[out] Decrypted_Data Pointer to the buffer that will contain decrypted
 *             data.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gap_decrypt_adv_data(uint8_t Session_Key[16],
                                    uint8_t IV[8],
                                    uint8_t Encrypted_Data_Length,
                                    uint8_t * Encrypted_Data,
                                    uint32_t *Decrypted_Data);
/**
 * @}
 */

/**
 * @}
 */


/**
 *@addtogroup GATT GATT
 *@brief Generic Attribute Profile.
 *@{
 */
/**
 *@defgroup ACI_GATT_Commands ACI GATT Commands
 * Commands for GATT layer.
 *@{
 */
/**
 * @brief Masks events from the GATT. The default configuration is all the
 *        events unmasked (enabled).
 * @param GATT_Evt_Mask GATT/ATT event mask.
 *        Values:
 *        - 0x00000001: ACI_GATT_ATTRIBUTE_MODIFIED_EVENT
 *        - 0x00000002: ACI_GATT_PROC_TIMEOUT_EVENT
 *        - 0x00000004: ACI_ATT_EXCHANGE_MTU_RESP_EVENT
 *        - 0x00000008: ACI_ATT_FIND_INFO_RESP_EVENT
 *        - 0x00000010: ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT
 *        - 0x00000020: ACI_ATT_READ_BY_TYPE_RESP_EVENT
 *        - 0x00000040: ACI_ATT_READ_RESP_EVENT
 *        - 0x00000080: ACI_ATT_READ_BLOB_RESP_EVENT
 *        - 0x00000100: ACI_ATT_READ_MULTIPLE_RESP_EVENT
 *        - 0x00000200: ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT
 *        - 0x00000800: ACI_ATT_PREPARE_WRITE_RESP_EVENT
 *        - 0x00001000: ACI_ATT_EXEC_WRITE_RESP_EVENT
 *        - 0x00002000: ACI_GATT_INDICATION_EVENT
 *        - 0x00004000: ACI_GATT_NOTIFICATION_EVENT
 *        - 0x00008000: ACI_GATT_ERROR_RESP_EVENT
 *        - 0x00010000: ACI_GATT_PROC_COMPLETE_EVENT
 *        - 0x00020000: ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT
 *        - 0x00040000: ACI_GATT_TX_POOL_AVAILABLE_EVENT
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_set_event_mask(uint32_t GATT_Evt_Mask);
/**
 * @brief Performs an ATT MTU exchange procedure. When the ATT MTU exchange
 *        procedure is completed, a @ref aci_att_exchange_mtu_resp_event_rp0 event
 *        is generated. A @ref aci_gatt_clt_proc_complete_event_rp0 event is also
 *        generated to indicate the end of the procedure.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_exchange_config(uint16_t Connection_Handle);
/**
 * @brief Sends a Prepare Write Request. The Prepare Write Request is used to
 *        request the server to prepare to write the value of an attribute.  The
 *        responses of the procedure are given through the @ref
 *        aci_att_clt_prepare_write_resp_event_rp0 event.  The end of the procedure
 *        is indicated by a @ref aci_gatt_clt_proc_complete_event_rp0.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Attr_Handle Handle of the attribute to be written
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param Val_Offset The offset of the first octet to be written
 *        Values:
 *        - 0 ... 511
 * @param Attribute_Val_Length Length of attribute value (maximum value is
 *        ATT_MTU - 5).
 * @param Attribute_Val The value of the attribute to be written
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_prepare_write_req(uint16_t Connection_Handle,
                                          uint16_t CID,
                                          uint16_t Attr_Handle,
                                          uint16_t Val_Offset,
                                          uint16_t Attribute_Val_Length,
                                          uint8_t Attribute_Val[]);
/**
 * @brief Sends an Execute Write Request. The Execute Write Request is used to
 *        request the server to write or cancel the write of all the prepared
 *        values currently held in the prepare queue from this client.  The
 *        result of the procedure is given through the @ref
 *        aci_att_clt_exec_write_resp_event_rp0 event.  The end of the procedure is
 *        indicated by a @ref aci_gatt_clt_proc_complete_event_rp0 event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Execute Execute or cancel writes.
 *        Values:
 *        - 0x00: Cancel all prepared writes
 *        - 0x01: Immediately write all pending prepared values
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_execute_write_req(uint16_t Connection_Handle,
                                          uint16_t CID,
                                          uint8_t Execute);
/**
 * @brief Starts the GATT client procedure to discover all primary services on
 *        the server. The responses of the procedure are given through the @ref
 *        aci_att_clt_read_by_group_type_resp_event_rp0 event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_disc_all_primary_services(uint16_t Connection_Handle,
                                                  uint16_t CID);
/**
 * @brief Starts the procedure to discover the primary services of the specified
 *        UUID on the server. The responses of the procedure are given through
 *        the @ref aci_att_clt_find_by_type_value_resp_event_rp0 event. The end of
 *        the procedure is indicated by a @ref aci_gatt_clt_proc_complete_event_rp0
 *        event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param UUID_Type UUID type.
 *        Values:
 *        - 0x01: 16-bit UUID
 *        - 0x02: 128-bit UUID
 * @param UUID See @ref UUID_t
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_disc_primary_service_by_uuid(uint16_t Connection_Handle,
                                                     uint16_t CID,
                                                     uint8_t UUID_Type,
                                                     UUID_t *UUID);
/**
 * @brief Starts the procedure to find all included services. The responses of
 *        the procedure are given through the @ref
 *        aci_att_clt_read_by_type_resp_event_rp0 event. The end of the procedure is
 *        indicated by a @ref aci_gatt_clt_proc_complete_event_rp0 event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Start_Handle Start attribute handle of the service
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param End_Handle End attribute handle of the service
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_find_included_services(uint16_t Connection_Handle,
                                               uint16_t CID,
                                               uint16_t Start_Handle,
                                               uint16_t End_Handle);
/**
 * @brief Starts the procedure to discover all the characteristics of a given
 *        service. When the procedure is completed, a @ref
 *        aci_gatt_clt_proc_complete_event_rp0 event is generated. Before procedure
 *        completion the response packets are given through @ref
 *        aci_att_clt_read_by_type_resp_event_rp0 event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Start_Handle Start attribute handle of the service
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param End_Handle End attribute handle of the service
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_disc_all_char_of_service(uint16_t Connection_Handle,
                                                 uint16_t CID,
                                                 uint16_t Start_Handle,
                                                 uint16_t End_Handle);
/**
 * @brief Starts the procedure to discover all the characteristics specified by
 *        a UUID. When the procedure is completed, a @ref
 *        aci_gatt_clt_proc_complete_event_rp0 event is generated. Before procedure
 *        completion the response packets are given through @ref
 *        aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0 event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Start_Handle Start attribute handle of the service
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param End_Handle End attribute handle of the service
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param UUID_Type UUID type.
 *        Values:
 *        - 0x01: 16-bit UUID
 *        - 0x02: 128-bit UUID
 * @param UUID See @ref UUID_t
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_disc_char_by_uuid(uint16_t Connection_Handle,
                                          uint16_t CID,
                                          uint16_t Start_Handle,
                                          uint16_t End_Handle,
                                          uint8_t UUID_Type,
                                          UUID_t *UUID);
/**
 * @brief Starts the procedure to discover all characteristic descriptors on the
 *        server. When the procedure is completed, a @ref
 *        aci_gatt_clt_proc_complete_event_rp0 event is generated. Before procedure
 *        completion the response packets are given through @ref
 *        aci_att_clt_find_info_resp_event_rp0 event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Char_Handle Handle of the characteristic value
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param End_Handle End handle of the characteristic
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_disc_all_char_desc(uint16_t Connection_Handle,
                                           uint16_t CID,
                                           uint16_t Char_Handle,
                                           uint16_t End_Handle);
/**
 * @brief Starts the procedure to read an attribute value. When the procedure is
 *        completed, a @ref aci_gatt_clt_proc_complete_event_rp0 event is generated.
 *        Before procedure completion the response packet is given through @ref
 *        aci_att_clt_read_resp_event_rp0 event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Attr_Handle Handle of the attribute to be read
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_read(uint16_t Connection_Handle,
                             uint16_t CID,
                             uint16_t Attr_Handle);
/**
 * @brief Starts the procedure to read all the characteristics specified by the
 *        UUID. When the procedure is completed, a @ref
 *        aci_gatt_clt_proc_complete_event_rp0 event is generated. Before procedure
 *        completion the response packets are given through @ref
 *        aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0 event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Start_Handle Starting handle of the range to be searched
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param End_Handle End handle of the range to be searched
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param UUID_Type UUID type.
 *        Values:
 *        - 0x01: 16-bit UUID
 *        - 0x02: 128-bit UUID
 * @param UUID See @ref UUID_t
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_read_using_char_uuid(uint16_t Connection_Handle,
                                             uint16_t CID,
                                             uint16_t Start_Handle,
                                             uint16_t End_Handle,
                                             uint8_t UUID_Type,
                                             UUID_t *UUID);
/**
 * @brief Starts the procedure to read a long attribute value. the procedure is
 *        completed, a @ref aci_gatt_clt_proc_complete_event_rp0 event is generated.
 *        Before procedure completion the response packets are given through
 *        @ref aci_att_clt_read_blob_resp_event_rp0 event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Attr_Handle Handle of the attribute to be read
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param Val_Offset Offset from which the value needs to be read
 *        Values:
 *        - 0 ... 511
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_read_long(uint16_t Connection_Handle,
                                  uint16_t CID,
                                  uint16_t Attr_Handle,
                                  uint16_t Val_Offset);
/**
 * @brief Starts a procedure to read multiple characteristic values from a
 *        server. This sub-procedure is used to read multiple Characteristic
 *        Values from a server when the client knows the Characteristic Value
 *        Handles. Only values that have a known fixed size can be read, with
 *        the exception of the last value that can have a variable length. When
 *        the procedure is completed, a @ref aci_gatt_clt_proc_complete_event_rp0
 *        event is generated. Before procedure completion the response packets
 *        are given through @ref aci_att_clt_read_multiple_resp_event_rp0 event. The
 *        response only contains a set of Characteristic Values that is less
 *        than or equal to (ATT_MTU - 1) octets in length. If the Set Of Values
 *        is greater than (ATT_MTU - 1) octets in length, only the first
 *        (ATT_MTU - 1) octets are included in the response.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Number_of_Handles The number of handles for which the value has to be
 *        read. From 2 to (ATT_MTU-1)/2
 *        Values:
 *        - 0x02 ... 0xFF
 * @param Handle The handles for which the attribute value has to be read
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_read_multiple_char_value(uint16_t Connection_Handle,
                                                 uint16_t CID,
                                                 uint8_t Number_of_Handles,
                                                 uint16_t Handle[]);
/**
 * @brief Starts the procedure to write a characteristic value without waiting
 *        for any response from the server. No events are generated after this
 *        command is executed. Writing attributes using this function is not
 *        considered reliable by the standard: packets may be discarded by the
 *        peer if too many write commands are received.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Attr_Handle Handle of the attribute to be written
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param Attribute_Val_Length Length of the value to be written (maximum value
 *        is ATT_MTU - 3)
 * @param Attribute_Val Value to be written
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_write_without_resp(uint16_t Connection_Handle,
                                           uint16_t CID,
                                           uint16_t Attr_Handle,
                                           uint16_t Attribute_Val_Length,
                                           uint8_t Attribute_Val[]);
/**
 * @brief Starts a signed write without response from the server. The procedure
 *        is used to write a characteristic value with an authentication
 *        signature without waiting for any response from the server. It cannot
 *        be used when the link is encrypted, and therefore it cannot be used on
 *        enhanced ATT bearers.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Attr_Handle Handle of the attribute to be written
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param Attribute_Val_Length Length of the value to be written (up to ATT_MTU
 *        - 13)
 * @param Attribute_Val Value to be written
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_signed_write_without_resp(uint16_t Connection_Handle,
                                                  uint16_t Attr_Handle,
                                                  uint16_t Attribute_Val_Length,
                                                  uint8_t Attribute_Val[]);
/**
 * @brief Allow application to confirm indication. This command has to be sent
 *        when the application receives the event @ref
 *        aci_gatt_clt_indication_event_rp0.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_confirm_indication(uint16_t Connection_Handle,
                                           uint16_t CID);
/**
 * @brief Send an indication or notification for the provided attribute handle.
 *        The Flags parameter indicates what kind of message will be sent: -)
 *        0x00 Send a notification -) 0x02 Send an indication
 * @param Connection_Handle Connection handle to be used to identify the
 *        connection with the peer device.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Attr_Handle Handle of the attribute to be notified
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param Flags Select the notification type.
 *        Values:
 *        - 0x00: GATT_NOTIFICATION
 *        - 0x02: GATT_INDICATION
 * @param Val_Length Length of the Val field.
 * @param Val
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_notify(uint16_t Connection_Handle,
                               uint16_t CID,
                               uint16_t Attr_Handle,
                               uint8_t Flags,
                               uint16_t Val_Length,
                               uint8_t Val[]);
/**
 * @brief Updates an attribute value for that kind of attributes that have
 *        different values for each connection, i.e. the Client Characteristic
 *        Configuration Descriptors. WARNING: use of this function can affect
 *        interoperability. Do not use the function unless you are aware of what
 *        you are doing.
 * @param Connection_Handle Connection handle for which the attribute value will
 *        be written.
 * @param Attr_Handle Handle of the attribute
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param Value_Length Length of the attribute value in octets.
 * @param Value Attribute value.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_write_multiple_instance_handle_value(uint16_t Connection_Handle,
                                                             uint16_t Attr_Handle,
                                                             uint16_t Value_Length,
                                                             uint8_t Value[]);
/**
 * @brief Notify multiple characteristic values to a client.
 * @param Connection_Handle Connection handle for which the attribute value will
 *        be read.
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Flags Reserved for future use. Its value must be set to 0.
 *        Values:
 *        - 0x00
 * @param Num_Of_Attr
 * @param Gatt_Srv_Notify_Attr See @ref Gatt_Srv_Notify_Attr_t
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_multi_notify(uint16_t Connection_Handle,
                                     uint16_t CID,
                                     uint8_t Flags,
                                     uint8_t Num_Of_Attr,
                                     Gatt_Srv_Notify_Attr_t Gatt_Srv_Notify_Attr[]);
/**
 * @brief This sub-procedure is used to read multiple Characteristic Values from
 *        a server when the client knows the Characteristic Value Handles. This
 *        procedure is useful when the attributes to read have a variable or
 *        unknown value length (otherwise aci_gatt_clt_read_multiple_char_value
 *        may be used). When the procedure is completed, a @ref
 *        aci_gatt_clt_proc_complete_event_rp0 event is generated. Before procedure
 *        completion the response packets are given through @ref
 *        aci_att_clt_read_multiple_var_len_resp_event_rp0 event.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Number_of_Handles The number of handles for which the value has to be
 *        read. From 2 to (ATT_MTU-1)/2
 *        Values:
 *        - 0x02 ... 0xFF
 * @param Handle The handles for which the attribute value has to be read
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_read_multiple_var_len_char_value(uint16_t Connection_Handle,
                                                         uint16_t CID,
                                                         uint8_t Number_of_Handles,
                                                         uint16_t Handle[]);
/**
 * @brief Adds a service to the GATT database. When a service is created, the
 *        host may reserve a range of handles for this service.
 * @param Service_p The pointer to the service definition.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_add_service(ble_gatt_srv_def_t * Service_p);
/**
 * @brief Includes a service given by Included_Service_Handle to another service
 *        given by Service_Handle. Attribute server creates an Include
 *        definition attribute and returns the handle of this attribute.
 * @param Service_Handle Handle of the Service to which another service has to
 *        be included.
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param Included_Service_Handle Attribute Handle of the Service which has to
 *        be included in service
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_include_service(uint16_t Service_Handle,
                                        uint16_t Included_Service_Handle);
/**
 * @brief Adds a characteristic to a service.
 * @param Char_p The pointer to the Characteristic definition.
 * @param Service_Handle Handle of the Service to which the characteristic will
 *        be added.
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_add_char(ble_gatt_chr_def_t * Char_p,
                                 uint16_t Service_Handle);
/**
 * @brief Adds a characteristic descriptor to a characteristic.
 * @param Descr_p The pointer to the Descriptor definition.
 * @param Char_Handle The Characteristic handle.
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_add_char_desc(ble_gatt_descr_def_t * Descr_p,
                                      uint16_t Char_Handle);
/**
 * @brief Deletes the specified service from the GATT server database.
 * @param Serv_Handle Handle of the service to be deleted
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_rm_service(uint16_t Serv_Handle);
/**
 * @brief Deletes the include definition from the service.
 * @param Include_Handle Handle of the included service which has to be deleted
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_rm_include_service(uint16_t Include_Handle);
/**
 * @brief Deletes the specified characteristic from the service.
 * @param Char_Handle Handle of the characteristic which has to be deleted
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_rm_char(uint16_t Char_Handle);
/**
 * @brief This function retrieve the Attribute Handle assigned to the Service
 *        registered using the provided definition structure.
 * @param Serv_p The Service definition structure.
 * @return Attribute Handle of Service or BLE_ATT_INVALID_ATTR_HANDLE on error.
 */
uint16_t aci_gatt_srv_get_service_handle(ble_gatt_srv_def_t * Serv_p);
/**
 * @brief This function retrieve the Attribute Handle assigned to the Include
 *        Service.
 * @param Serv_Attr_Handle The Handle of the including Service.
 * @param Included_Srv_p The Included Service definition structure.
 * @return Attribute Handle of Service or BLE_ATT_INVALID_ATTR_HANDLE on error.
 */
uint16_t aci_gatt_srv_get_include_service_handle(uint16_t Serv_Attr_Handle,
                                                   ble_gatt_srv_def_t * Included_Srv_p);
/**
 * @brief This function retrieve the Attribute Handle assigned to the
 *        Characteristic registered using the provided definition structure.
 * @param Char_p The Characteristic definition structure.
 * @return Attribute Handle of Service or BLE_ATT_INVALID_ATTR_HANDLE on error.
 */
uint16_t aci_gatt_srv_get_char_decl_handle(ble_gatt_chr_def_t * Char_p);
/**
 * @brief This function retrieve the Attribute Handle assigned to the
 *        Characteristic Descriptor registered using the provided definition
 *        structure.
 * @param Descr_p The Characteristic Descriptor definition structure.
 * @return Attribute Handle of Service or BLE_ATT_INVALID_ATTR_HANDLE on error.
 */
uint16_t aci_gatt_srv_get_descriptor_handle(ble_gatt_descr_def_t * Descr_p);
/**
 * @brief Reads the value of the attribute handle specified from the local GATT
 *        database. This command cannot be used to read attributes that have
 *        different values for each connection, e.g. the Client Characteristic
 *        Configuration Descriptors or Client Supported Features Characteristic
 *        (in this case, aci_gatt_srv_read_multiple_instance_handle_value needs
 *        to be used).
 * @param Attr_Handle Handle of the attribute to read
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param[out] Length Length of the attribute value
 * @param[out] Value Pointer to the Attribute Value.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_read_handle_value(uint16_t Attr_Handle,
                                          uint16_t *Length,
                                          uint8_t * *Value);
/**
 * @brief Command to be given in response to aci_gatt_srv_read_event_rp0,
 *        aci_gatt_srv_write_event_rp0, aci_att_srv_prepare_write_req_event_rp0 or
 *        aci_att_srv_exec_write_req_event_rp0. It ends the ATT transaction
 *        initiated by the remote client.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Attr_Handle Attribute handle for which the response command is issued.
 * @param Error_Code The reason why the request has generated an error response
 *        (ATT error codes)
 *        Values:
 *        - 0x01: Invalid handle
 *        - 0x02: Read not permitted
 *        - 0x03: Write not permitted
 *        - 0x04: Invalid PDU
 *        - 0x05: Insufficient authentication
 *        - 0x06: Request not supported
 *        - 0x07: Invalid offset
 *        - 0x08: Insufficient authorization
 *        - 0x09: Prepare queue full
 *        - 0x0A: Attribute not found
 *        - 0x0B: Attribute not long
 *        - 0x0C: Insufficient encryption key size
 *        - 0x0D: Invalid attribute value length
 *        - 0x0E: Unlikely error
 *        - 0x0F: Insufficient encryption
 *        - 0x10: Unsupported group type
 *        - 0x11: Insufficient resources
 * @param Val_Length Length of the Val field.
 * @param Val Pointer to the value that must be returned in the response, in
 *        case this is a reply to an aci_gatt_srv_read_event_rp0. In other cases
 *        it is ignored.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_resp(uint16_t Connection_Handle,
                             uint16_t CID,
                             uint16_t Attr_Handle,
                             uint8_t Error_Code,
                             uint16_t Val_Length,
                             uint8_t Val[]);
/**
 * @brief Starts the procedure to write an attribute (characteristic value or
 *        descriptor). When the procedure is completed, a @ref
 *        aci_gatt_clt_proc_complete_event_rp0 event is generated.  Note: the buffer
 *        containing the value to be written must be kept valid until the @ref
 *        aci_gatt_clt_proc_complete_event_rp0 is received
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Attr_Handle Handle of the attribute to be written
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param Attribute_Val_Length Length of the value to be written
 * @param Attribute_Val
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_write(uint16_t Connection_Handle,
                              uint16_t CID,
                              uint16_t Attr_Handle,
                              uint16_t Attribute_Val_Length,
                              uint8_t Attribute_Val[]);
/**
 * @brief This procedure is used to write an Attribute Value to a Server when
 *        the Client knows the Attribute Handle but the length of the Value is
 *        longer than what can be sent in a single Write Request Attribute
 *        Protocol message. During the procedure,
 *        aci_att_clt_prepare_write_resp_event_rp0 and
 *        aci_att_clt_exec_write_resp_event_rp0 are raised.  Note: The memory
 *        pointed by Write_Ops_p parameter and the buffer containing the value
 *        to be written must be kept valid while the procedure is running. They
 *        can be released (or their content can be changed) when the
 *        aci_gatt_clt_proc_complete_event_rp0 is emitted indicating that the
 *        procedure is completed, or an error was received.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Write_Ops_p The pointer to structure that holds the write information.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_write_long(uint16_t Connection_Handle,
                                   uint16_t CID,
                                   ble_gatt_clt_write_ops_t * Write_Ops_p);
/**
 * @brief Starts the procedure to write a characteristic reliably (a check is
 *        made on the written values). When the procedure is completed, a  @ref
 *        aci_gatt_clt_proc_complete_event_rp0 event is generated. During the
 *        procedure, @ref aci_att_clt_prepare_write_resp_event_rp0 and @ref
 *        aci_att_clt_exec_write_resp_event_rp0 events are raised.  Note: The memory
 *        pointed by Write_Ops_p parameter and the buffer containing the value
 *        to be written must be kept valid while the procedure is running. They
 *        can be released (or their content can be changed) when the
 *        aci_gatt_clt_proc_complete_event_rp0 is emitted indicating that the
 *        procedure is completed, or an error was received.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID Channel Identifier of the ATT bearer. It must be set to 0x0004 for
 *        unenhanced ATT bearer.
 * @param Num_Attrs The number of attributes to write, i.e. the number of
 *        elements in the list pointed by Write_Ops_p.
 * @param Write_Ops_p The pointer to the list of structures that hold the write
 *        information.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_clt_write_char_reliable(uint16_t Connection_Handle,
                                            uint16_t CID,
                                            uint8_t Num_Attrs,
                                            ble_gatt_clt_write_ops_t * Write_Ops_p);
/**
 * @brief Read the value for that kind of attributes that have different values
 *        for each connection, i.e. Client Characteristic Configuration
 *        Descriptors or Client Supported Features Characteristic.
 * @param Connection_Handle Connection handle for which the attribute value will
 *        be read.
 * @param Attr_Handle Handle of the attribute
 *        Values:
 *        - 0x0001 ... 0xFFFF
 * @param[out] Value_Length
 * @param[out] Value Pointer to the buffer containing the value. Content may no
 *             more be valid after another call to this function or to
 *             BLE_STACK_Tick().
 * @retval Value indicating success or error code.
 */
tBleStatus aci_gatt_srv_read_multiple_instance_handle_value(uint16_t Connection_Handle,
                                                            uint16_t Attr_Handle,
                                                            uint16_t *Value_Length,
                                                            uint8_t * *Value);
/**
 * @}
 */

/**
 * @}
 */


/**
 *@addtogroup L2CAP L2CAP
 *@brief Logical Link Control and Adaptation Protocol.
 *@{
 */
/**
 *@defgroup ACI_L2CAP_Commands ACI L2CAP Commands
 * Commands for L2CAP layer.
 *@{
 */
/**
 * @brief Send an L2CAP connection parameter update request from the peripheral
 *        to the central. An @ref aci_l2cap_connection_update_resp_event_rp0 event
 *        will be raised when the central will respond to the  request (accepts
 *        or rejects).
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Connection_Interval_Min Minimum value for the connection event
 *        interval. This shall be less than or equal to Connection_Interval_Max.
 *        Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Connection_Interval_Max Maximum value for the connection event
 *        interval. This shall be greater than or equal to
 *        Connection_Interval_Min. Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Peripheral_Latency Maximum Peripheral latency for the connection in
 *        number of connection events.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Timeout_Multiplier Defines connection timeout parameter in the
 *        following manner: Timeout Multiplier * 10ms.
 *        Values:
 *        - 10 (100 ms)  ... 3200 (32000 ms) 
 * @retval Value indicating success or error code.
 */
tBleStatus aci_l2cap_connection_parameter_update_req(uint16_t Connection_Handle,
                                                     uint16_t Connection_Interval_Min,
                                                     uint16_t Connection_Interval_Max,
                                                     uint16_t Peripheral_Latency,
                                                     uint16_t Timeout_Multiplier);
/**
 * @brief Accept or reject a connection update. This command should be sent in
 *        response to a @ref aci_l2cap_connection_update_req_event_rp0 event from
 *        the controller. The accept parameter has to be set if the connection
 *        parameters given in the event are acceptable.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Connection_Interval_Min Minimum value for the connection event
 *        interval. This shall be less than or equal to Connection_Interval_Max.
 *        Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Connection_Interval_Max Maximum value for the connection event
 *        interval. This shall be greater than or equal to
 *        Connection_Interval_Min. Time = N * 1.25 msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Peripheral_Latency Maximum Peripheral latency for the connection in
 *        number of connection events.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Timeout_Multiplier Defines connection timeout parameter in the
 *        following manner: Timeout Multiplier * 10ms.
 *        Values:
 *        - 10 (100 ms)  ... 3200 (32000 ms) 
 * @param Min_CE_Length The minimum length of connection event recommended for
 *        this LE connection. Time = N * 0.625 msec.
 * @param Max_CE_Length The maximum length of connection event recommended for
 *        this LE connection. Time = N * 0.625 msec.
 * @param Identifier Identifier received in ACI_L2CAP_Connection_Update_Req
 *        event.
 * @param Accept Specify if connection update parameters are acceptable or not.
 *        Values:
 *        - 0x00: Reject
 *        - 0x01: Accept
 * @retval Value indicating success or error code.
 */
tBleStatus aci_l2cap_connection_parameter_update_resp(uint16_t Connection_Handle,
                                                      uint16_t Connection_Interval_Min,
                                                      uint16_t Connection_Interval_Max,
                                                      uint16_t Peripheral_Latency,
                                                      uint16_t Timeout_Multiplier,
                                                      uint16_t Min_CE_Length,
                                                      uint16_t Max_CE_Length,
                                                      uint8_t Identifier,
                                                      uint8_t Accept);
/**
 * @brief Create and configure an L2CAP channel between two devices using either
 *        LE Credit Based Flow Control Mode or Enhanced Credit Based Flow
 *        Control Mode.
 * @param Connection_Handle Handle identifying the connection.
 * @param SPSM Simplified Protocol/Service Multiplexer
 *        Values:
 *        - 0x0001 ... 0x00FF
 * @param MTU The maximum SDU size (in octets) that the L2CAP layer entity
 *        sending the L2CAP_LE_CREDIT_BASED_CONNECTION_REQ can receive on this
 *        channel.
 *        Values:
 *        - 23 ... 65535
 * @param MPS The maximum PDU payload size (in octets) that the L2CAP layer
 *        entity sending the L2CAP_LE_CREDIT_BASED_CONNECTION_REQ is capable of
 *        receiving on this channel.
 *        Values:
 *        - 23 ... 65533
 * @param Channel_Type Type of channel: LE Credit Based Flow Control Mode or
 *        Enhanced Credit Based Flow Control Mode.
 *        Values:
 *        - 0x00: L2CAP_CHANNEL_TYPE_LE_CFC
 *        - 0x01: L2CAP_CHANNEL_TYPE_ECFC
 * @param CID_Count
 * @retval Value indicating success or error code.
 */
tBleStatus aci_l2cap_cos_connection_req(uint16_t Connection_Handle,
                                        uint16_t SPSM,
                                        uint16_t MTU,
                                        uint16_t MPS,
                                        uint8_t Channel_Type,
                                        uint8_t CID_Count);
/**
 * @brief Command to be sent to respond to a request to open an L2CAP channel
 *        using LE Credit based Flow Control or Enhanced Credit Based Flow
 *        Control Mode. The request is notified through
 *        aci_l2cap_cos_connection_req_event_rp0.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Identifier Identifier of the request.
 * @param MTU The MTU field specifies the maximum SDU size (in octets) that the
 *        L2CAP layer entity sending the L2CAP_LE_CREDIT_BASED_CONNECTION_RSP
 *        can receive on this channel.
 *        Values:
 *        - 23 ... 65535
 * @param MPS The MPS field specifies the maximum PDU payload size (in octets)
 *        that the L2CAP layer entity sending the
 *        L2CAP_LE_CREDIT_BASED_CONNECTION_RSP is capable of receiving on this
 *        channel.
 *        Values:
 *        - 23 ... 65533
 * @param Result It indicates the outcome of the connection request. A result
 *        value of 0x0000 indicates success while a non-zero value indicates a
 *        fail. Code values starting from 0x000C can be used only for ECFC
 *        channel type.
 *        Values:
 *        - 0x0000: L2CAP_CONN_SUCCESSFUL
 *        - 0x0002: L2CAP_CONN_FAIL_SPSM_NOT_SUPPORTED
 *        - 0x0004: L2CAP_CONN_FAIL_INSUFFICIENT_RESOURCES
 *        - 0x0005: L2CAP_CONN_FAIL_INSUFFICIENT_AUTHENTICATION
 *        - 0x0006: L2CAP_CONN_FAIL_INSUFFICIENT_AUTHORIZATION
 *        - 0x0007: L2CAP_CONN_FAIL_KEY_SIZE_TOO_SHORT
 *        - 0x0008: L2CAP_CONN_FAIL_INSUFFICIENT_ENCRYPTION
 *        - 0x000B: L2CAP_CONN_FAIL_UNACCEPTABLE_PARAMETERS
 *        - 0x000C: L2CAP_CONN_FAIL_INVALID_PARAMETERS
 *        - 0x000D: L2CAP_CONN_FAIL_NO_INFO
 *        - 0x000E: L2CAP_CONN_FAIL_AUTHENTICATION_PENDING
 *        - 0x000F: L2CAP_CONN_FAIL_AUTHORIZATION_PENDING
 * @param CID_Count
 * @param[out] CID
 * @retval Value indicating success or error code.
 */
tBleStatus aci_l2cap_cos_connection_resp(uint16_t Connection_Handle,
                                         uint8_t Identifier,
                                         uint16_t MTU,
                                         uint16_t MPS,
                                         uint16_t Result,
                                         uint8_t CID_Count,
                                         uint16_t CID[]);
/**
 * @brief Command to terminate an L2CAP channel.
 * @param Connection_Handle
 * @param CID Local endpoint of the channel to be disconnected.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_l2cap_cos_disconnect_req(uint16_t Connection_Handle,
                                        uint16_t CID);
/**
 * @brief Function to be called to send an SDU using an  L2CAP channel in LE
 *        Credit Based Flow Control mode or Enhanced Credit Based Flow Control
 *        Mode.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID The local channel endpoint that identifies the L2CAP channel.
 * @param SDU_Length Length of the SDU to be transmitted.
 * @param SDU_Data Data contained in the SDU to be transmitted. Data must be
 *        valid until the SDU is transmitted.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_l2cap_cos_sdu_data_transmit(uint16_t Connection_Handle,
                                           uint16_t CID,
                                           uint16_t SDU_Length,
                                           uint8_t SDU_Data[]);
/**
 * @brief Command to send an L2CAP_CREDIT_BASED_RECONFIGURE_REQ packet in order
 *        to request to change its receive MTU or MPS values compared to when
 *        the channels were created or last reconfigured.
 * @param Connection_Handle Identifier received in the
 *        aci_eatt_connection_event_rp0.
 * @param MTU The maximum SDU size (in octets) that the L2CAP layer entity can
 *        receive on each of the Source CID channels (represented by Local_CID
 *        array parameter). This is equal to the maximum size of an ATT packet
 *        on the Enhanced ATT bearer.
 *        Values:
 *        - 0x0040 ... 0xFFFF
 * @param MPS The maximum PDU payload size (in octets) that the local L2CAP
 *        layer is capable of receiving on each of the Source CID channels
 *        (represented by Local_CID array parameter).
 *        Values:
 *        - 0x0040 ... 0xFFFF
 * @param CID_Count The number of potential Enhanced ATT bearers that are going
 *        to be opened. This is the number of L2CAP channels to be opened in
 *        Enhanced Credit Based Flow Control mode.
 *        Values:
 *        - 0x01 ... 0x05
 * @param CID List of CID values representing the channel endpoints on the local
 *        device. Each entry in the array shall be non-zero and represents a
 *        request for a channel. The value of each CID shall be from the
 *        dynamically allocated range for LE devices (0x0040-0x007F) and shall
 *        not be already allocated to a different channel on the device sending
 *        the request.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_l2cap_cos_reconfigure_req(uint16_t Connection_Handle,
                                         uint16_t MTU,
                                         uint16_t MPS,
                                         uint8_t CID_Count,
                                         uint16_t CID[]);
/**
 * @brief Command to send an L2CAP_CREDIT_BASED_RECONFIGURE_RSP packet in order
 *        to respond to an incoming L2CAP_CREDIT_BASED_RECONFIGURE_REQ. It has
 *        to be used upon the reception of an
 *        ACI_L2CAP_ECFC_RECONFIGURATION_EVENT.
 * @param Connection_Handle Identifier received in the
 *        aci_eatt_connection_event_rp0.
 * @param Identifier Identifier received in the aci_eatt_connection_event_rp0.
 * @param Result It indicates the outcome of the connection request. A result
 *        value of 0x0000 indicates success while a non-zero value indicates the
 *        connection request was refused.
 *        Values:
 *        - 0x0000: L2CAP_RECONFIG_SUCCESSFUL
 *        - 0x0001: L2CAP_MTU_REDUCTION_NOT_ALLOWED
 *        - 0x0002: L2CAP_MPS_REDUCTION_NOT_ALLOWED
 *        - 0x0003: L2CAP_INVALID_DESTINATION_CID
 *        - 0x0004: L2CAP_UNACCEPTABLE_PARAMETERS
 * @retval Value indicating success or error code.
 */
tBleStatus aci_l2cap_cos_reconfigure_resp(uint16_t Connection_Handle,
                                          uint8_t Identifier,
                                          uint16_t Result);
/**
 * @brief Function to be used to extract an SDU from receiving buffer.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID The local channel endpoint that identifies the L2CAP channel.
 * @param SDU_Data_Buffer_Size Size of the buffer where SDU will be copied.
 * @param[in] SDU_Data_Buffer Buffer where the extracted SDU will be copied.
 * @param[out] SDU_Length Length of the extracted SDU.
 * @retval Value indicating success or error code.
 */
tBleStatus aci_l2cap_cos_sdu_data_extract(uint16_t Connection_Handle,
                                          uint16_t CID,
                                          uint16_t SDU_Data_Buffer_Size,
                                          void * SDU_Data_Buffer,
                                          uint16_t *SDU_Length);
/**
 * @}
 */

/**
 * @}
 */

#endif /* _BLE_API_H_ */
